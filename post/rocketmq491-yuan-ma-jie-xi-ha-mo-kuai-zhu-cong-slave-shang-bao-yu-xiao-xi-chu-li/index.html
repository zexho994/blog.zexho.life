<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="芝兰生于幽谷，不因无人而不芳">
<meta name="theme-color" content="#000">
<title>RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理 | Zexho&#39; blog</title>
<link rel="shortcut icon" href="/favicon.ico?v=1647912783376">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



  <meta name="description" content="RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理" />
  <meta name="keywords" content="RocketMQ,源码" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Zexho&#39; blog</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Blog &amp; Life</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="https://zexho994.github.io/blog.zexho.life/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 时间线
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签集
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Zexho</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>芝兰生于幽谷，不因无人而不芳</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">28</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="http://github.com/zexho994">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
      </div>
    </div>
  

  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#haclient">HAClient</a>
<ul>
<li><a href="#haclient-%E5%90%AF%E5%8A%A8">HAClient 启动</a></li>
<li><a href="#slave%E8%BF%9E%E6%8E%A5master">Slave连接Master</a></li>
<li><a href="#slave%E6%B1%87%E6%8A%A5offset">Slave汇报offset</a></li>
<li><a href="#slave%E5%A4%84%E7%90%86%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE">Slave处理同步数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li/">
      RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2021-10-14 11:07:58</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/">
        <span>RocketMQ</span>
      </a>、
      
      
      
      <a href="https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/">
        <span>源码</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>7分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1500<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>接着上一篇 [RocketMQv4.9.1源码分析-HA主从 Master读写处理] 解答了Master相关的问题，这篇文章围绕Slave相关的一些问题继续看代码。</p>
<p>对于slave，我们有如下一些疑惑：</p>
<ol>
<li><code>slave</code>如何获取<code>master</code>的路由信息</li>
<li><code>slave</code>如何向<code>master</code>报告<code>offset</code>的</li>
<li><code>slave</code>如何处理<code>master</code>同步的数据</li>
</ol>
<!-- more -->
<p>在整体的类图布局中，slave相关的代码都在HAClient类中</p>
<figure data-type="image" tabindex="1"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed3a2d9fc0214105b8bbf8f96114a677~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="haclient">HAClient</h2>
<p>HAClient部分是Slave处理的核心，其中包括三部分：</p>
<ol>
<li>slave与master建立连接</li>
<li>slave向master汇报同步进度</li>
<li>slave接收master的同步数据并处理</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49ce7b1d1f3a4b6bb097e0aef244cc56~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h3 id="haclient-启动">HAClient 启动</h3>
<p>之前提到了，HAClient启动的触发时机是HAService启动的方法中，在<code>store/src/main/java/org/apache/rocketmq/store/ha/HAService.start()</code>中。</p>
<pre><code class="language-java">// HAService 启动
public void start() throws Exception {
    this.acceptSocketService.beginAccept();
    this.acceptSocketService.start();
    this.groupTransferService.start();
    this.haClient.start();
}
</code></pre>
<p>HAClient的启动代码在<code>store/src/main/java/org/apache/rocketmq/store/ha/HAService$HAClient.run()</code>路径下。</p>
<p>其中3个核心的步骤在代码注释中有进行标记</p>
<pre><code class="language-java">@Override
public void run() {
    log.info(this.getServiceName() + &quot; service started&quot;);

    while (!this.isStopped()) {
        try {
            // 步骤一：连接到master
            if (this.connectMaster()) {
                // 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告
                if (this.isTimeToReportOffset()) {
                    // 报告slave offset
                    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);
                    if (!result) {
                        this.closeMaster();
                    }
                }
                // 检查是否有读事件
                this.selector.select(1000);
                //步骤三：处理master返回的消息
                boolean ok = this.processReadEvent();
                if (!ok) {
                    this.closeMaster();
                }
                // 处理完读事件后，如果slave offset更新，需要再次发送新的slave offset
                if (!reportSlaveMaxOffsetPlus()) {
                    continue;
                }

                long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;
                if (interval &gt; HAService.this.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {
                    log.warn(&quot;HAClient, housekeeping, found this connection[&quot; + this.masterAddress + &quot;] expired, &quot; + interval);
                    this.closeMaster();
                    log.warn(&quot;HAClient, master not response some time, so close connection&quot;);
                }
            } else {
                this.waitForRunning(1000 * 5);
            }
        } catch (Exception e) {
            log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
            this.waitForRunning(1000 * 5);
        }
    }

    log.info(this.getServiceName() + &quot; service end&quot;);
}
</code></pre>
<h3 id="slave连接master">Slave连接Master</h3>
<p><code>connectMaster()</code>方法的目的是与master进行连接。</p>
<pre><code class="language-java">// master 地址(master的地址在配置文件中配置)
private final AtomicReference&lt;String&gt; masterAddress = new AtomicReference&lt;&gt;();

private boolean connectMaster() throws ClosedChannelException {
    if (null == socketChannel) {
        String addr = this.masterAddress.get();
        if (addr != null) {
            SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);
            if (socketAddress != null) {
                this.socketChannel = RemotingUtil.connect(socketAddress);
                if (this.socketChannel != null) {
                    // 读事件,用于监听master的返回消息
                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);
                }
            }
        }
        // 设置为当前commitlog的偏移量
        this.currentReportedOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();
        this.lastWriteTimestamp = System.currentTimeMillis();
    }

    return this.socketChannel != null;
}
</code></pre>
<p>有一个点关注下，就是<code>currentReportedOffset</code>字段，这个字段的目的是表示当前slave已同步的进度，后续在向master进行汇报时也是使用该字段的值。这里进行初始化的时候直接设置为commitlog文件的最大偏移量，如果没有commitlog文件则为0。</p>
<h3 id="slave汇报offset">Slave汇报offset</h3>
<pre><code class="language-java">// 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告
if (this.isTimeToReportOffset()) {
    // 报告slave offset
    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);
    if (!result) {
        this.closeMaster();
    }
}
</code></pre>
<p><code>isTimeToReportOffset()</code>的作用是判断上一次进行汇报的时间与当前时间差是否大于最大等待间隔（默认5s），这意味着即使5s没有收到master的任何消息，slave也会发送一个汇报请求给master，作用相对于一个心跳包。</p>
<p>看下<code>reportSlaveMaxOffset()</code>方法：</p>
<pre><code class="language-java">private boolean reportSlaveMaxOffset(final long maxOffset) {
    // 写位置设为0
    this.reportOffset.position(0);
    // 可写长度为8字节
    this.reportOffset.limit(8);
    // 数据内容为slave当前的offset
    this.reportOffset.putLong(maxOffset);
    // 写模式切换到模式
    // 将读位置设为0
    this.reportOffset.position(0);
    // 可读长度为8字节
    this.reportOffset.limit(8);

    for (int i = 0; i &lt; 3 &amp;&amp; this.reportOffset.hasRemaining(); i++) {
        try {
            // 将数据写入channel中
            this.socketChannel.write(this.reportOffset);
        } catch (IOException e) {
            log.error(this.getServiceName() + &quot;reportSlaveMaxOffset this.socketChannel.write exception&quot;, e);
            return false;
        }
    }

    lastWriteTimestamp = HAService.this.defaultMessageStore.getSystemClock().now();
    return !this.reportOffset.hasRemaining();
}
</code></pre>
<p>可以知道slave的汇报请求的数据包内容很简单，就是一个8字节大小的offset数据。</p>
<p>这里代码中有一个细节，rocketmq的作用再进行写模式切换到读模式时没有使用<code>flip()</code>方法，而是手动设置<code>position</code>和<code>limit</code>,这是由于NIO是一个非阻塞IO，write方法不一定会一次将ByteBuffer的数据全部写入。</p>
<h3 id="slave处理同步数据">Slave处理同步数据</h3>
<p>步骤三中，调用<code>processReadEvent()</code>对master返回的数据进行处理，看代码前，我们已经知道master返回的数据是未同步的消息，那么slave要做的事情是什么？当然就是把这个未同步的数据保存到本地的commitlog文件中。</p>
<pre><code class="language-java">private boolean processReadEvent() {
    // 连续读取到数据大小为0的次数
    int readSizeZeroTimes = 0;
    // 一直读取缓冲区的数据，直到没有剩余
    while (this.byteBufferRead.hasRemaining()) {
        try {
            int readSize = this.socketChannel.read(this.byteBufferRead);
            if (readSize &gt; 0) {
                readSizeZeroTimes = 0;
                boolean result = this.dispatchReadRequest();
                if (!result) {
                    log.error(&quot;HAClient, dispatchReadRequest error&quot;);
                    return false;
                }
            } else if (readSize == 0) {
                // 如果连续三次读到为空,则跳出方法,这里的作用？
                if (++readSizeZeroTimes &gt;= 3) {
                    break;
                }
            } else {
                log.info(&quot;HAClient, processReadEvent read socket &lt; 0&quot;);
                return false;
            }
        } catch (IOException e) {
            log.info(&quot;HAClient, processReadEvent read socket exception&quot;, e);
            return false;
        }
    }

    return true;
}
</code></pre>
<p>代码里调用了<code>dispatchReadRequest()</code>方法进行请求的处理，看下这个方法：</p>
<pre><code class="language-java">private boolean dispatchReadRequest() {
    final int msgHeaderSize = 8 + 4; // phyoffset + size

    while (true) {
        int diff = this.byteBufferRead.position() - this.dispatchPosition;
        if (diff &gt;= msgHeaderSize) {
            // master commitlog 偏移量
            long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPosition);
            // 消息大小
            int bodySize = this.byteBufferRead.getInt(this.dispatchPosition + 8);
            // 本地  commitlog 偏移量
            long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();
            if (slavePhyOffset != 0) {
                // 如果slave的offset和master的offset不一样，说明数据同步过程发生了问题，不再继续同步。
                if (slavePhyOffset != masterPhyOffset) {
                    log.error(&quot;master pushed offset not equal the max phy offset in slave, SLAVE: &quot; + slavePhyOffset + &quot; MASTER: &quot; + masterPhyOffset);
                    return false;
                }
            }

            // 剩余空间够用,将消息追加到commitlog中
            if (diff &gt;= (msgHeaderSize + bodySize)) {
                // 消息数组
                byte[] bodyData = byteBufferRead.array();
                // 消息的
                int dataStart = this.dispatchPosition + msgHeaderSize;
                // 添加数据到本地commitlog中
                HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData, dataStart, bodySize);
                this.dispatchPosition += msgHeaderSize + bodySize;

                if (!reportSlaveMaxOffsetPlus()) {
                    return false;
                }

                continue;
            }
        }

        if (!this.byteBufferRead.hasRemaining()) {
            this.reallocateByteBuffer();
        }

        break;
    }

    return true;
}
</code></pre>
<p>整体的逻辑可以分为俩部分，第一部分是解析请求包，获取消息数据，第二部分是把消息数据写入到commitlog文件中。</p>
<p>这两部分代码已经写的很清楚了，比较容易理解，就不再赘述。</p>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Zexho
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li/" title="RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理">https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/"># RocketMQ</a>
    
      <a href="https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/"># 源码</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/">RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="RocketMQ4.9.1源码分析(HA模块) Master读写处理" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-ha-mo-kuai-master-du-xie-chu-li/">RocketMQ4.9.1源码分析(HA模块) Master读写处理</a>
        <a class="nav-mobile-next" title="RocketMQ4.9.1源码分析(HA模块) Master读写处理" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-ha-mo-kuai-master-du-xie-chu-li/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.4/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('https://upimage.alexhchu.com/2020/04/21/47eda59424daa.gif');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: '',
    appKey: '',
    avatar: '',
    placeholder: '观点不同才有火花，欢迎表达',
    pageSize: '20',
    lang: 'zh-cn',
    visitor: 'true' === 'false',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'true',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/wo-li-jie-de-cap/"" data-c="
          &lt;p&gt;最近在梳理我们系统架构的时候，想从分布式领域的角度来分析架构设计，但是由于之前没系统性接触过分布式相关的知识，正好借此机会来学习分布式相关的知识，并进行自己的总结。本文的目的是搞清楚什么是CAP。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式系统的最大难点，就是各个节点的状态如何同步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;历史背景&#34;&gt;历史背景&lt;/h1&gt;
&lt;p&gt;时间回到 1985 年，彼时，后来证明了 CAP 理论的 Lynch 教授此时给当时的 IT 界来了一记惊雷：她通过不可辩驳的证明告诉业界的工程师们，如果在一个不稳定（消息要么乱序要么丢了）的网络环境里（分布式异步模型），想始终保持数据一致是不可能的。这是个什么概念呢？就是她打破了那些既想提供超高质量服务，又想提供超高性能服务的技术人员的幻想。这本质是在告诉大家，在分布式系统里，需要妥协。&lt;br&gt;
过了15年，在2000 年时，Eric Brewer 教授在 PODC 会议上提出了 CAP 理论，但是由于没有被证明过，所以，当时只能被称为 CAP 猜想。这个猜想引起了巨大的反响，因为 CAP 很符合人们对设计纲领的预期。在 2002 年后，经过 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP 猜想后，CAP 理论正式成为了分布式系统理论的基石之一。&lt;/p&gt;
&lt;h1 id=&#34;概念解释&#34;&gt;概念解释&lt;/h1&gt;
&lt;p&gt;要准确的理解CAP，首先必须明白CAP中3个概念的准确定义，3个概念分别对应CAP的3个缩写 Consistency、Availability、Partition Tolerance。&lt;br&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iegjbmz8j20u00u0gno.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;consistency-一致性&#34;&gt;Consistency 一致性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;all nodes see the same data at the same time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在服务节点进行更新操作后，所有节点同一时间的数据完全一致，也称数据一致性。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iegrn0bdj20lu0i00tb.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在DB1更新完成后，步骤3的查询结果一定是最新的数据，那么步骤4的查询结果必须要和3一样，不然就是数据不一致。&lt;/p&gt;
&lt;h2 id=&#34;availability-可靠性&#34;&gt;Availability 可靠性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Reads and writes always succeed&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在预期的响应时间内，必须返回结果（非异常的）。这里有两个概念，一个是预期响应时间，一个是非异常的结果。&lt;/p&gt;
&lt;p&gt;预期响应时间应该是早在系统设计时就定义好的，要结合业务场景的考虑，例如我们google搜索要在0.5s内返回我们想要的结果，那么0.5就是定义好的结果，&lt;/p&gt;
&lt;p&gt;一个文件转换的服务，预期响应时间可能会是数十秒甚至以分钟计算。只要能在预期响应时间内返回，都可以算作未超时的。&lt;/p&gt;
&lt;p&gt;非异常的结果是指能被客户端接收并进行正常后续处理的，12306抢票时刷新后看到有票，点击购买又告知没票了，刷新后看到的是旧数据，但整个流程是没有发生异常，也可以说是可靠性。&lt;/p&gt;
&lt;h2 id=&#34;partition-tolerance-分区容错性&#34;&gt;Partition Tolerance 分区容错性&lt;/h2&gt;
&lt;p&gt;分布式场景下节点间都是通过网络进行通信的，网络肯定不是100%可靠的，也会有异常的时候。&lt;/p&gt;
&lt;p&gt;当两个节点间发生了异常不能正常通信了，就可以说这两个节点之间发生&lt;strong&gt;分区&lt;/strong&gt;了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iehceicrj20zq0muta5.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么对于A服务而言，假设B发生异常了，A是否要容忍这种情况呢？选择不容忍，那么对应的措施就是A马上对外停止服务。这对于分布式系统来说绝对是不能接受的，所以我们必须容忍网络分区的发生，即使相关服务发生了异常，服务也不能停止运行。&lt;br&gt;
这么看来CAP中P是必须要的，同时也知道CAP3这不能同时满足，现在的难题就是C和A中如何进行取舍&lt;/p&gt;
&lt;h1 id=&#34;为什么c和a不能同时存在&#34;&gt;为什么C和A不能同时存在&lt;/h1&gt;
&lt;p&gt;假如必须要满足一致性，那么数据中心只能有一个，这样所有的节点拿到的数据肯定都是最新的了。&lt;/p&gt;
&lt;p&gt;那就会有一个问题，数据中心一旦发生网络分区，就导致所有节点无法处理请求，这样可靠性必然不能保证。&lt;/p&gt;
&lt;p&gt;假如必须要满足可靠性，那么我们可以采用多数据中心的方式，这样即使个别节点发生网络分区，也不会导致整个服务不可用。可是这就有一个问题，最新的数据无法同步给其他分区的节点，就可能会导致数据不一下的可能。&lt;/p&gt;
&lt;h1 id=&#34;如何取舍c和a&#34;&gt;如何取舍C和A&lt;/h1&gt;
&lt;p&gt;在没有发生网络分区的时候，CAP三者都是满足的，只有当发生网络分区这种小概率事件的时候。&lt;br&gt;
先看一些开源框架是如何进行设计的&lt;br&gt;
cp - Zookeeper，Redis：当zookeeper和redis会保证数据的一致性，保证任何时候获取到的数据都是最新的。&lt;br&gt;
ca - Mysql，RocketMQ:  在Mysql和RocketMQ的主从架构中，当主从之间发生网络分区时&lt;br&gt;
，从从库获取到的数据可能是不一致的。&lt;/p&gt;
&lt;p&gt;说到底，还是看业务场景。例如涉及到钱的系统，那么一致性是肯定要保证的，银行系统哪怕停止服务也要保证数据的一致性。用过12306，肯定遇到过页面刷新后同一车次有时候有票有时候没票的情况，这就是为了提高可用性，保证刷新操作成功，但是一致性就无法得到保证了。&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/6PgqyigrgVICl0JiI73oNg&#34;&gt;https://mp.weixin.qq.com/s/6PgqyigrgVICl0JiI73oNg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/54105974/answer/1643846752&#34;&gt;https://www.zhihu.com/question/54105974/answer/1643846752&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hollischuang.com/archives/666&#34;&gt;https://www.hollischuang.com/archives/666&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">我理解的CAP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/kuai-su-kan-qing-lambda-de-ben-zhi/"" data-c="
          &lt;p&gt;在JDK8之后，Lambda表达式的功能为日常开发提供了很多便捷的操作，但是没接触过的人会对这种表达式有很大的疑惑，为什么要这样表示？我要怎么写出Lambda风格的代码？本文旨在快速理解lambda。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;先看下lambda表达式是什么。在JDK8中，我们可以对接口添加一个注解&lt;code&gt;@FunctionalInterface&lt;/code&gt;,我们看下JDK中&lt;code&gt;Runnalble&lt;/code&gt;接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Runnable {
    
    void run();
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口内有一个抽象方法&lt;code&gt;run()&lt;/code&gt;，要注意一点，如果我们自己要实现一个lambda接口，那么接口内有且仅有一个抽象方法（&lt;code&gt;default&lt;/code&gt;修饰的不算），为什么要这么限制？看完后文就知道了。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;Runnable&lt;/code&gt;常常一起出现的是&lt;code&gt;Thread&lt;/code&gt;类，看下Thread中是如何使用&lt;code&gt;Runnable&lt;/code&gt;的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Thread(Runnable target) {
    init(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造方法中可以传入一个&lt;code&gt;Runnable&lt;/code&gt;对象，在JDK8之前可以使用匿名类的方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // 编写运行逻辑
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就相当于传入了一个Runnalble实例对象了。&lt;/p&gt;
&lt;p&gt;现在思考一下，我们知道接口的参数对象是Runnable，知到Runnable仅有一个抽象方法（上文提到的限制），那我们可以简化这个表达式吗？&lt;/p&gt;
&lt;p&gt;尝试去掉多余的参数声明语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d806efa7ee00439bacd42920b680277c~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接着去掉多余的方法声明语句&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b0646872074fac998da89e8225d212~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;是的，最后剩下的就是实际有效的部分，方法的参数和方法的逻辑。&lt;/p&gt;
&lt;p&gt;最后我们加个箭头&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2af1d6ea86aa4f34982b8b8040fb658c~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;没错，这个就是lambda表达式了，就是这么变化过来的。&lt;/p&gt;
&lt;p&gt;考虑有参数的情况，加入Runnable接口的run方法是有参数的，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface Runnable {
    
    void run(String key,int val);
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么对应，lambda表达式就变成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread((&amp;quot;hello&amp;quot;,20) -&amp;gt; {
    String k = key; // k == &amp;quot;hello&amp;quot;
    int v = val;    // v == 20
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果方法的代码只有一行，我们可以省略中括号&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Thread((&amp;quot;hello&amp;quot;,20) -&amp;gt; log.info(&amp;quot;key = {}&amp;quot;,key));
&lt;/code&gt;&lt;/pre&gt;
">快速看清lambda的本质</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/shi-xian-yi-zhi-xing-hash-suan-fa/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;假设已经了解一致性Hash的相关知识，如果不了解可以先看&lt;a href=&#34;https://www.zsythink.net/archives/1182&#34;&gt;https://www.zsythink.net/archives/1182&lt;/a&gt;&lt;br&gt;
代码地址：&lt;a href=&#34;https://github.com/zexho994/ConsistentHash&#34;&gt;https://github.com/zexho994/ConsistentHash&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道一致性hash的核心思想是对2^32进行取模，然后保存到一个Hash环上:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20726d0655964e89a79dbb2f4d91e809~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;要实现一致性Hash，先解决几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何表示这个环？&lt;/li&gt;
&lt;li&gt;如何在环上插入节点、删除节点、查找最近的节点？&lt;/li&gt;
&lt;li&gt;虚拟节点如何表示，怎么插入到环中？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hash环&#34;&gt;Hash环&lt;/h2&gt;
&lt;p&gt;思考下这个hash环的特点，我们的节点要插入到哪个位置由节点的hash值决定，现在加入有两个节点A和B，&lt;code&gt;A.hashcode = 50&lt;/code&gt;,&lt;code&gt;B.hashcode = 100&lt;/code&gt;,由于环是按顺时针方向查找，那么查找的逻辑就是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[0,50] , (50,2^32] 的数据会找到A&lt;/li&gt;
&lt;li&gt;(50,100] 的数据会找到B&lt;br&gt;
可以发现一个特点，就是要有序，以及可以支持快速找到下一个节点，&lt;code&gt;TreeMap&lt;/code&gt;就十分契合, 每个节点的右子树就是最小的最近的大于某个hashcode的节点。&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f70674010c44788ba3189a9a3522965~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
整个算法核心的部分也是基于&lt;code&gt;TreeMap&lt;/code&gt;实现的，首先声明&lt;code&gt;ring&lt;/code&gt;，后面所有的节点数据都将存储到ring上。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConsistentHashManager {

    private final SortedMap&amp;lt;Integer/*索引大小*/, Node/*节点*/&amp;gt; ring = new TreeMap();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;中&lt;code&gt;key&lt;/code&gt;存储的节点的&lt;code&gt;索引&lt;/code&gt;值（后面会讲计算方式），&lt;code&gt;val&lt;/code&gt;中存储节点对象实例&lt;code&gt;Node&lt;/code&gt;，其中&lt;code&gt;Node&lt;/code&gt;是模拟表示现实服务器信息的对象，需要重写&lt;code&gt;equals()&lt;/code&gt;和&lt;code&gt;hashcode()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Node {

    //服务器名称
    private String name;
    //服务器域名
    private String host;
    //服务器端口
    private Integer port;

    public Node(String name, String host, int port) {
        this.name = name;
        this.host = host;
        this.port = port;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Node)) return false;
        Node node = (Node) o;
        return getPort() == node.getPort() &amp;amp;&amp;amp; getName().equals(node.getName()) &amp;amp;&amp;amp; getHost().equals(node.getHost());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getHost(), getPort());
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;添加新节点&#34;&gt;添加新节点&lt;/h2&gt;
&lt;p&gt;要将一个节点存储到环上，首先是要知道存储到哪个位置上，位置由索引的大小决定，这就需要计算&lt;code&gt;Node对象&lt;/code&gt;的索引值&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349fd9c6f8ca43268c9abdaf5e1d92c5~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先声明一个接口对象，因为以后可能会有各种计算方式，那么会有各种不同的具体实现类，所以这里采用基于接口而非实例的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface HashUtil {

    int hash(String key);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是使用MD5的方式，这肯定不是最好的方法，重点是表达&lt;code&gt;hash()&lt;/code&gt;的作用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Md5HashUtil implements HashUtil {

    private MessageDigest messageDigest;

    public Md5HashUtil() {
        try {
            this.messageDigest = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    @Override
    public int hash(String key) {
        this.messageDigest.update(String.valueOf(key).getBytes();
        byte[] digest = this.messageDigest.digest();
        int h = 0;
        for (int i = 0; i &amp;lt; 4; i++) {
            h |= ((int) digest[i]) &amp;amp; 0xFF;
            // 循环4次，每次移动8位，正好32次
            h &amp;lt;&amp;lt;= 8;
        }
        return h;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了&lt;code&gt;hash()&lt;/code&gt;方法，可以知道节点的索引值了，就可以将Node存储到ring中了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addNode(Node node) {
    ring.put(hashUtil.hash(node.getKey()), node);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么这时候还有一件事要做，如何添加虚拟节点呢？刚开始的时候我认为为了保证平均分布，那么虚拟节点的分布特征应该如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ff31e6502b4cc195d50224ce7951a7~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是会发现一个问题，要继续增加更多物理节点时，如何继续保持平均分布？这很难实现，从另一个方面再想，虚拟节点的作用是什么？是为了让分配更平均，防止血崩的概率，其实哪怕这些虚拟节点的位置都是随机的，只要节点数量够多，就已经达到了目的。&lt;/p&gt;
&lt;p&gt;完善一下&lt;code&gt;addNode()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void addNode(Node node) {
    ring.put(hashUtil.hash(node.getKey()), node);
    for (int i = 0; i &amp;lt; this.virNodeCount; i++) {
        this.ring.put(hashUtil.hash(node.getKey() + i), node);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除节点&#34;&gt;删除节点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;中存储的val是Node，这样在遍历ring的匹配node进行删除即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void removeNote(Node node) {
    ring.entrySet().removeIf(next -&amp;gt; next.getValue().equals(node));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取下一个节点&#34;&gt;获取下一个节点&lt;/h2&gt;
&lt;p&gt;这部分看代码了解下&lt;code&gt;TreeMap&lt;/code&gt;的&lt;code&gt;api&lt;/code&gt;就可以理解，没什么难度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Node getNextNode(String key) {
    SortedMap&amp;lt;Integer, Node&amp;gt; longNodeSortedMap = ring.tailMap(hashUtil.hash(key));
    if (longNodeSortedMap.isEmpty()) {
        return ring.get(ring.firstKey());
    }
    return longNodeSortedMap.get(longNodeSortedMap.firstKey());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;测试&#34;&gt;测试&lt;/h1&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
void loadBalancingTest() {
    ConsistentHashManager consistentHashManager = new ConsistentHashManager();
    // 添加四个节点
    consistentHashManager.addNode(new Node(&amp;quot;node1&amp;quot;, &amp;quot;192.0.0.1&amp;quot;, 8080));
    consistentHashManager.addNode(new Node(&amp;quot;node2&amp;quot;, &amp;quot;192.0.0.2&amp;quot;, 8080));
    consistentHashManager.addNode(new Node(&amp;quot;node3&amp;quot;, &amp;quot;192.0.0.3&amp;quot;, 8080));
    consistentHashManager.addNode(new Node(&amp;quot;node4&amp;quot;, &amp;quot;192.0.0.4&amp;quot;, 8080));

    String preKey = &amp;quot;Data_&amp;quot;;
    // map用来记录每个节点命中的次数
    Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(200000);
    map.put(&amp;quot;node1&amp;quot;, 0);
    map.put(&amp;quot;node2&amp;quot;, 0);
    map.put(&amp;quot;node3&amp;quot;, 0);
    map.put(&amp;quot;node4&amp;quot;, 0);
    // 假设有20w个数据
    for (int i = 0; i &amp;lt; 200000; i++) {
        Node nextNote = consistentHashManager.getNextNote(preKey + i);
        // 累加命中次数
        map.computeIfPresent(nextNote.getName(), (k, v) -&amp;gt; v + 1);
    }
    // 打印
    map.entrySet().forEach(System.out::println);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88147670d09b40c8aab81a41269e700d~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;整体的比例是 &lt;code&gt;5 : 6 : 4.5 : 4.5&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除节点后的命中率&#34;&gt;删除节点后的命中率&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
void removeNodeTest() {
    // 省略添加节点的代码 ...
    
    // 移除一个节点
    consistentHashManager.removeNote(node4);
    // 测试下移除节点后的命中率
    AtomicInteger n1 = new AtomicInteger(0);
    AtomicInteger n2 = new AtomicInteger(0);
    AtomicInteger n3 = new AtomicInteger(0);
    for (int i = 0; i &amp;lt; 200000; i++) {
        Node nextNode = consistentHashManager.getNextNode(preKey + i);
        if (nextNode.getName().equals(&amp;quot;node1&amp;quot;)) {
            n1.incrementAndGet();
        } else if (nextNode.getName().equals(&amp;quot;node2&amp;quot;)) {
            n2.incrementAndGet();
        } else if (nextNode.getName().equals(&amp;quot;node3&amp;quot;)) {
            n3.incrementAndGet();
        } else {
            throw new RuntimeException(&amp;quot;node4 未清理干净&amp;quot;);
        }
    }

    // 打印命中率, 原本的次数/删除后的次数
    statistic.forEach((key, value) -&amp;gt; {
        if (key.equals(&amp;quot;node1&amp;quot;)) {
            System.out.println(&amp;quot;Node1,总访问次数=&amp;quot; + n1 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n1.get());
        } else if (key.equals(&amp;quot;node2&amp;quot;)) {
            System.out.println(&amp;quot;Node2,总访问次数=&amp;quot; + n2 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n2.get());
        } else if (key.equals(&amp;quot;node3&amp;quot;)) {
            System.out.println(&amp;quot;Node3,总访问次数=&amp;quot; + n3 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n3.get());
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72b63651f134c3eade1c41a75fdd122~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">实现一致性Hash算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/li-yong-cglib-he-jdk-dong-tai-dai-li-shi-xian-aop/"" data-c="
          &lt;p&gt;前提：本文假设你已经了解AOP切面编程的基础概念&lt;br&gt;
项目地址：&lt;a href=&#34;https://github.com/zexho994/IOC-AOP&#34;&gt;https://github.com/zexho994/IOC-AOP&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;aop的逻辑&#34;&gt;AOP的逻辑&lt;/h1&gt;
&lt;p&gt;首先我们定义一个被代理类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public class A interface I{

    public void print() {
        System.out.println(&amp;quot;aaa&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义切点和切面&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
@Aspect
public class AdviceSample {

    @Before
    @Pointcut(beanName = &amp;quot;A&amp;quot;)
    public void enhance2Before() {
        System.out.println(&amp;quot;before&amp;quot;);
    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后续我们使用A的时候，都会先打印切面的内容，也就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;before
aaa
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83758a4da5594e43aee236ff3ba476df~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如何将切面的内容添加到代理的方法里面去呢？&lt;/p&gt;
&lt;h1 id=&#34;切面切入实现&#34;&gt;切面切入实现&lt;/h1&gt;
&lt;h2 id=&#34;jdk动态代理实现&#34;&gt;JDK动态代理实现&lt;/h2&gt;
&lt;p&gt;提到代理，最先想到的是JDK提供的动态代理类&lt;code&gt;InvocationHandler&lt;/code&gt;，下面尝试使用JDK动态代理实现 ，切入的方式假设使用&lt;code&gt;before&lt;/code&gt;，而&lt;code&gt;after&lt;/code&gt;和&lt;code&gt;around&lt;/code&gt;看完就懂如何实现了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JDKDynamicProxy implements InvocationHandler {
    
    private Method before = null;
    private Object beforeObj = null;

    
    /**
     * @param proxy  代理的真实对象
     * @param method 要调用的真实对象的方法
     * @param args   方法的参数
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 执行before方法
        if (before != null) {
            before.invoke(beforeObj);
        }

        // 执行本体方法
        Object invoke = method.invoke(target, args);

        return invoke;
    }
    
    /**
     * 获取动态代理对象
     *
     * @param obj 被代理类
     * @return obj的父接口实现子类, 因为返回的是T父接口重写的类
     */
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public &amp;lt;T&amp;gt; T getDynamicProxyImpl(T obj,Method before, Object beforeObj) {
        assert obj != null;
        this.before = before;
        this.beforeObj = beforeObj;

        // newProxyInstance() 会创建类$A，$A实现了obj的父接口，所有接口方法内容都为 {@link #invoke()} 。
        return (T) newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;统一调用&lt;code&gt;getDynamicProxyImpl()&lt;/code&gt;来获取新的代理类，参数里面传入before的Method对象，&lt;code&gt;invoke()&lt;/code&gt;方法定义了在执行本体方法之前执行&lt;code&gt;before&lt;/code&gt;方法，这样新的代理类都会先执行&lt;code&gt;before&lt;/code&gt;方法再执行本体方法了。&lt;/p&gt;
&lt;p&gt;实现非常简单易懂，那么要实现&lt;code&gt;after&lt;/code&gt;方法就是可以传入after的&lt;code&gt;Method&lt;/code&gt;对象，然后在&lt;code&gt;invoke()&lt;/code&gt;的本体方法之后执行，&lt;code&gt;around&lt;/code&gt;的实现不用再增加新的逻辑了，只要同时传入&lt;code&gt;before&lt;/code&gt;和&lt;code&gt;after&lt;/code&gt;的&lt;code&gt;Method&lt;/code&gt;对象，这样新的代理类就会同时执行&lt;code&gt;before()&lt;/code&gt;和&lt;code&gt;after()&lt;/code&gt;了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e5dca4c4a049519f0edaa0986605f5~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;cglib实现&#34;&gt;Cglib实现&lt;/h2&gt;
&lt;p&gt;JDK动态代理可以实现，但是有约束条件就是被代理类必须要有父接口，因为JDK动态实现的原理就是实现接口生成增强的子类。那么如果一个类没有父接口该如何进行切面增强呢？&lt;code&gt;Spring&lt;/code&gt;中使用了&lt;code&gt;cglib&lt;/code&gt;这个库来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CglibProxy implements MethodInterceptor {

    public static final Enhancer ENHANCER = new Enhancer();

    private Method before = null;
    private Object beforeObj = null;

    private Method after = null;
    private Object afterObj = null;

    /**
     * @param obj         cglib动态代理生成的实例
     * @param method      被调用的方法的引用
     * @param params      参数列表
     * @param methodProxy 代理类对方法的代理引用
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {
        if (before != null) {
            before.invoke(beforeObj);
        }
        Object result = methodProxy.invokeSuper(obj, params);
        if (after != null) {
            after.invoke(afterObj);
        }
        return result;
    }

    public void setBefore(Method before, Object beforeObj) {
        this.before = before;
        this.beforeObj = beforeObj;
    }

    public void setAfter(Method after, Object afterObj) {
        this.after = after;
        this.afterObj = afterObj;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public static &amp;lt;T&amp;gt; T getProxy(T target, Method before, Object beforeObj, Method after, Object afterObj) {
        ENHANCER.setSuperclass(target.getClass());
        CglibProxy cglibProxy = new CglibProxy();
        cglibProxy.setBefore(before, beforeObj);
        cglibProxy.setAfter(after, afterObj);

        ENHANCER.setCallback(cglibProxy);
        return (T) ENHANCER.create();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现的思路和JDK动态代理几乎一致，通过调用&lt;code&gt;getProxy()&lt;/code&gt;方法传入&lt;code&gt;before()&lt;/code&gt;或&lt;code&gt;after()&lt;/code&gt;方法就可以获得代理类了。&lt;/p&gt;
&lt;p&gt;为什么cglib的实现不需要接口呢？cglib的实现原理是为被代理类创建一个子类，然后将切面通过ASM提供的字节码技术织入到目标方法中，这样子类的方法就包含了本体和切面的逻辑了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8116c3d61d4f8d8b72d525d210355d~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">利用Cglib和JDK动态代理实现AOP</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/"" data-c="
          &lt;p&gt;何为路由中心？&lt;br&gt;
在通常的理解中，提到消息队列，最简单的模型如下图：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f71895f47ec4236a5bea69b046546dc~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;很好理解，生产者只要知道消息队列的网络地址，然后发送消息到这个网络地址上。但是实际往往不是这么简单，因为消息队列一般是集群模式，再如下图，4个实例组成集群：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506c5a983c63464da45316ec8e8d91ae~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假如现在继续采用生产者/消费者直接记录4个实例网络地址的方式，也是可以实现的。随着业务的发展，需要对队列进行水平扩展，要将4台实例临时扩展到6台，那么生产者和消费者是不知道新增的两个实例网络地址的，这时只能重启，记录两个新实例的网络地址再重启。这是不是非常麻烦？针对这个问题可以思考下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于集群模式的服务，有没有更好更灵活的方式去记录路由信息？&lt;/li&gt;
&lt;li&gt;当集群实例数量增加或者减少时，怎么让其他服务可以知道？并且不用做任何操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时如果我们新增一个路由中心系统，负责两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有服务可以去路由中心上报自己的网络地址。&lt;/li&gt;
&lt;li&gt;所有服务可以去路由中心获取其他服务的网络地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6aa125536e4dfb83330ef43de7e9d7~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这样我们系统有多少的业务系统，我们只要知道路由中心的地址就可以了。&lt;/p&gt;
&lt;p&gt;那么路由中心怎么感知实例数量的变化呢？最朴素的手段就是心跳，路由中心定期向所有上报的系统发送心跳包，如果心跳包没有响应则说明实例已经停止运行了，在路由记录中剔除该服务地址就可以了。&lt;/p&gt;
&lt;p&gt;其实这两个步骤都有专门名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册：将某个服务调用信息记录到一个公共组件中&lt;/li&gt;
&lt;li&gt;服务发现：当服务新增/减少，要能被其他调用者自动发现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;市面上已有的代表性产品有：zookeeper、consul、etcd。&lt;/p&gt;
&lt;h1 id=&#34;rocketmq中的namesrv&#34;&gt;RocketMQ中的Namesrv&lt;/h1&gt;
&lt;p&gt;图中展示了Namesrv的3个功能，也是核心的3个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册broker&lt;/li&gt;
&lt;li&gt;获取路由信息&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;定时心跳检测&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c54c19fc50942ddbdd8bc47e62990b1~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;接下来看看rocketmq的源码是如何实现这3个功能的&lt;/p&gt;
&lt;h1 id=&#34;路由元信息&#34;&gt;路由元信息&lt;/h1&gt;
&lt;p&gt;namesrv作为路由信息的管理者，本质上可以这么对namesrv进行理解：&lt;strong&gt;保存路由信息的数据结构 + 操作数据结构的算法&lt;/strong&gt;，路由元信息便是第一部分，所以先看看namesrv保存路由信息的数据结构是什么样子？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java&lt;/code&gt;类下，包含了所有的路由元信息&lt;/p&gt;
&lt;h3 id=&#34;topicqueuetable&#34;&gt;topicQueueTable&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 保存Topic和队列的信息，也叫真正的路由信息。
     * 一个Topic的queue可能分布在不同的broker中，也有可能分布在同一个broker中。
     * key:topic . val:QueueData
     */
    private final HashMap&amp;lt;String, List&amp;lt;QueueData&amp;gt;&amp;gt; topicQueueTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e4c5596d5446c904f294c0309bc2c~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;brokeraddrtable&#34;&gt;brokerAddrTable&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Broker基础信息，broker名称和broker信息的对应信息
     * key:broker name . val:broker data
     */
    private final HashMap&amp;lt;String, BrokerData&amp;gt; brokerAddrTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddec0178522a42d791986edd1daf1756~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;clusteraddrtable&#34;&gt;clusterAddrTable&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Broker集群信息,集群中所有Broker名称
     * key: cluster name . val:set&amp;lt;broker name&amp;gt;
     */
    private final HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; clusterAddrTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac1bd42e6464d548a8df4725b37a8ab~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;brokerlivetable&#34;&gt;brokerLiveTable&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Broker状态信息，NameServer每次收心跳包都会替换该信息
     * key: broker addr . val:broker live info
     */
    private final HashMap&amp;lt;String, BrokerLiveInfo&amp;gt; brokerLiveTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24bca7def87a46868684c025076f71cd~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;filterservertable&#34;&gt;filterServerTable&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * 用于类模式消息过滤
     * key:broker addr . val:filter server
     */
    private final HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; filterServerTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;知道了路由元信息的数据结构，再看看路由信息是如何保存到这些map中的以及如何查询的。&lt;/p&gt;
&lt;h1 id=&#34;服务注册&#34;&gt;服务注册&lt;/h1&gt;
&lt;p&gt;注册broker和获取路由信息是namesrv提供的API，位于&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java&lt;/code&gt;类下的&lt;code&gt;processRequest()&lt;/code&gt;，根据请求的code判断请求的类型。下面包含了namesrv所有的对外接口API。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;switch (request.getCode()) {
    case RequestCode.PUT_KV_CONFIG:
        // 添加配置
        return this.putKVConfig(ctx, request);
    case RequestCode.GET_KV_CONFIG:
        // 获取配置
        return this.getKVConfig(ctx, request);
    case RequestCode.DELETE_KV_CONFIG:
        // 删除配置
        return this.deleteKVConfig(ctx, request);
    case RequestCode.QUERY_DATA_VERSION:
        return queryBrokerTopicConfig(ctx, request);
    case RequestCode.REGISTER_BROKER:
        // 注册broker
        Version brokerVersion = MQVersion.value2Version(request.getVersion());
        if (brokerVersion.ordinal() &amp;gt;= MQVersion.Version.V3_0_11.ordinal()) {
            // 3.0.11之后
            return this.registerBrokerWithFilterServer(ctx, request);
        } else {
            // 3.0.11之前
            return this.registerBroker(ctx, request);
        }
    case RequestCode.UNREGISTER_BROKER:
        // 注销broker
        return this.unregisterBroker(ctx, request);
    case RequestCode.GET_ROUTEINFO_BY_TOPIC:
        // 根据topic获取路由信息
        return this.getRouteInfoByTopic(ctx, request);
    case RequestCode.GET_BROKER_CLUSTER_INFO:
        // 获取broker集群信息
        return this.getBrokerClusterInfo(ctx, request);
    case RequestCode.WIPE_WRITE_PERM_OF_BROKER:
        // 删除Broker的写权限
        return this.wipeWritePermOfBroker(ctx, request);
    case RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:
        // 获取全部Topic信息
        return getAllTopicListFromNameserver(ctx, request);
    case RequestCode.DELETE_TOPIC_IN_NAMESRV:
        // 删除Topic信息
        return deleteTopicInNamesrv(ctx, request);
    case RequestCode.GET_KVLIST_BY_NAMESPACE:
        // 获取kv列表
        return this.getKVListByNamespace(ctx, request);
    case RequestCode.GET_TOPICS_BY_CLUSTER:
        // 获取topic根据集群
        return this.getTopicsByCluster(ctx, request);
	..
    default:
        break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中服务注册对应的是code是&lt;code&gt;REGISTER_BROKER&lt;/code&gt;，下面看到根据版本的不同分为&lt;code&gt;registerBrokerWithFilterServer()&lt;/code&gt;和&lt;code&gt;registerBroker()&lt;/code&gt;，我使用的是v4.9.1，所以看看&lt;code&gt;registerBrokerWithFilterServer()&lt;/code&gt;的实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public RemotingCommand registerBrokerWithFilterServer(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {
	...省略...        
        
    // 注册的方法
	RegisterBrokerResult result = this.namesrvController.getRouteInfoManager().registerBroker(...);

    ...省略...
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;核心的注册逻辑在&lt;code&gt;registerBroker()&lt;/code&gt;中 ,继续看下&lt;code&gt;registerBroker()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public RegisterBrokerResult registerBroker(final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List&amp;lt;String&amp;gt; filterServerList, final Channel channel) {
    RegisterBrokerResult result = new RegisterBrokerResult();
    try {
        try {
            this.lock.writeLock().lockInterruptibly();

            // step1
            // 根据集群名称获取 broker name 集合
            Set&amp;lt;String&amp;gt; brokerNames = this.clusterAddrTable.get(clusterName);
            if (null == brokerNames) {
                brokerNames = new HashSet&amp;lt;&amp;gt;();
                this.clusterAddrTable.put(clusterName, brokerNames);
            }
            // 添加broker name 到集合中
            brokerNames.add(brokerName);

            // 是否第一次注册
            boolean registerFirst = false;

            // step2
            // 如果 broker table 里没有数据，则表示broker为第一次注册
            BrokerData brokerData = this.brokerAddrTable.get(brokerName);
            if (null == brokerData) {
                registerFirst = true;
                brokerData = new BrokerData(clusterName, brokerName, new HashMap&amp;lt;&amp;gt;());
                this.brokerAddrTable.put(brokerName, brokerData);
            }
            Map&amp;lt;Long, String&amp;gt; brokerAddrsMap = brokerData.getBrokerAddrs();
            //Switch slave to master: first remove &amp;lt;1, IP:PORT&amp;gt; in namesrv, then add &amp;lt;0, IP:PORT&amp;gt;
            //The same IP:PORT must only have one record in brokerAddrTable
            brokerAddrsMap.entrySet().removeIf(item -&amp;gt; null != brokerAddr &amp;amp;&amp;amp; brokerAddr.equals(item.getValue()) &amp;amp;&amp;amp; brokerId != item.getKey());

            String oldAddr = brokerAddrsMap.put(brokerId, brokerAddr);
            registerFirst = registerFirst || (null == oldAddr);

            // step3
            // 如果 topic 信息不为空，而且是 master
            if (null != topicConfigWrapper &amp;amp;&amp;amp; MixAll.MASTER_ID == brokerId) {
                // 如果是第一次注册，或者 broker topic 信息发生变动过
                if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || registerFirst) {
                    // 获取 topic info 列表
                    ConcurrentMap&amp;lt;String, TopicConfig&amp;gt; tcTable = topicConfigWrapper.getTopicConfigTable();
                    if (tcTable != null) {
                        for (Map.Entry&amp;lt;String, TopicConfig&amp;gt; entry : tcTable.entrySet()) {
                            this.createAndUpdateQueueData(brokerName, entry.getValue());
                        }
                    }
                }
            }

            // step4
            BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr, new BrokerLiveInfo(System.currentTimeMillis(), topicConfigWrapper.getDataVersion(), channel, haServerAddr));
            if (null == prevBrokerLiveInfo) {
                log.info(&amp;quot;new broker registered, {} HAServer: {}&amp;quot;, brokerAddr, haServerAddr);
            }

            // step5
            if (filterServerList != null) {
                if (filterServerList.isEmpty()) {
                    this.filterServerTable.remove(brokerAddr);
                } else {
                    this.filterServerTable.put(brokerAddr, filterServerList);
                }
            }

            // 如果broker的身份是slave
            if (MixAll.MASTER_ID != brokerId) {
                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
                if (masterAddr != null) {
                    BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);
                    if (brokerLiveInfo != null) {
                        // 在返回结果中，携带master的地址，主从同步步骤需要。
                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());
                        result.setMasterAddr(masterAddr);
                    }
                }
            }
        } finally {
            this.lock.writeLock().unlock();
        }
    } catch (Exception e) {
        log.error(&amp;quot;registerBroker Exception&amp;quot;, e);
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码注释中使用step1 ~ step5对5个不同阶段进行标记，这5个阶段的作用可以这么理解&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b53e34de8e48ca8e5adcbb371babcd~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;路由剔除&#34;&gt;路由剔除&lt;/h1&gt;
&lt;p&gt;namesrv要删除一个broker的路由信息的只有一个：这个broker目前不能正常提供服务了。这也可以分为两种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;broker正常停止。&lt;/li&gt;
&lt;li&gt;broker发生异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;broker-正常停止&#34;&gt;Broker 正常停止&lt;/h2&gt;
&lt;p&gt;broker在停止的时候会给namesrv发送一个&lt;code&gt;unregisterBroker&lt;/code&gt;类型的消息，发送代码部分在&lt;code&gt;broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java&lt;/code&gt;类的&lt;code&gt;unregisterBrokerAll()&lt;/code&gt;，namesrv处理这个消息的入口上文服务注册部分提到过，代码的逻辑很直白，就是从&lt;code&gt;topicQueueTable&lt;/code&gt; 、&lt;code&gt;brokerAddrTable&lt;/code&gt; 、&lt;code&gt;brokerLiveTable&lt;/code&gt; 、&lt;code&gt;filterServerTable&lt;/code&gt; 删除与该Broker相关的信息。&lt;/p&gt;
&lt;h2 id=&#34;broker-异常&#34;&gt;Broker 异常&lt;/h2&gt;
&lt;p&gt;broker异常的时候，肯定是无法主动向namesrv发送注销消息的，所以需要namesrv主动去发现哪些异常的broker。按照这个思路，可以想到两种实现手段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt; namesrv启动一个定时任务，然后向所有broker发送心跳请求，无法响应的broker可以怀疑是发生了异常了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt; 记录broker向namesrv最后发送心跳消息的时间，namesrv启动定时任务，判断每个最后心跳时间与当前的时间是否超时，超时说明broker异常导致无法发送心跳包&lt;/p&gt;
&lt;p&gt;RocketMQ的设计思路和方案二类似。&lt;/p&gt;
&lt;h3 id=&#34;启动定时任务&#34;&gt;启动定时任务&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/NamesrvController#initailize()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean initialize() {
    //...略
    
    this.scheduledExecutorService.scheduleAtFixedRate(NamesrvController.this.routeInfoManager::scanNotActiveBroker, 5, 10, TimeUnit.SECONDS);
    
	//... 略
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager#scanNotActiveBroker()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void scanNotActiveBroker() {
    // 从存活列表里获取broker数据
    Iterator&amp;lt;Entry&amp;lt;String, BrokerLiveInfo&amp;gt;&amp;gt; it = this.brokerLiveTable.entrySet().iterator();
    while (it.hasNext()) {
        Entry&amp;lt;String, BrokerLiveInfo&amp;gt; next = it.next();
        long last = next.getValue().getLastUpdateTimestamp();
        // 判断消息发送间隔
        if ((last + BROKER_CHANNEL_EXPIRED_TIME) &amp;lt; System.currentTimeMillis()) {
            RemotingUtil.closeChannel(next.getValue().getChannel());
			// 移除该broker信息
            it.remove();
            log.warn(&amp;quot;The broker channel expired, {} {}ms&amp;quot;, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);
            this.onChannelDestroy(next.getKey(), next.getValue().getChannel());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">RocketMQ4.9.1源码分析-Namesrv服务注册&路由发现</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li/"" data-c="
          &lt;p&gt;接着上一篇 [RocketMQv4.9.1源码分析-HA主从 Master读写处理] 解答了Master相关的问题，这篇文章围绕Slave相关的一些问题继续看代码。&lt;/p&gt;
&lt;p&gt;对于slave，我们有如下一些疑惑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何获取&lt;code&gt;master&lt;/code&gt;的路由信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何向&lt;code&gt;master&lt;/code&gt;报告&lt;code&gt;offset&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何处理&lt;code&gt;master&lt;/code&gt;同步的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;p&gt;在整体的类图布局中，slave相关的代码都在HAClient类中&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed3a2d9fc0214105b8bbf8f96114a677~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;haclient&#34;&gt;HAClient&lt;/h2&gt;
&lt;p&gt;HAClient部分是Slave处理的核心，其中包括三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;slave与master建立连接&lt;/li&gt;
&lt;li&gt;slave向master汇报同步进度&lt;/li&gt;
&lt;li&gt;slave接收master的同步数据并处理&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49ce7b1d1f3a4b6bb097e0aef244cc56~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;haclient-启动&#34;&gt;HAClient 启动&lt;/h3&gt;
&lt;p&gt;之前提到了，HAClient启动的触发时机是HAService启动的方法中，在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService.start()&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// HAService 启动
public void start() throws Exception {
    this.acceptSocketService.beginAccept();
    this.acceptSocketService.start();
    this.groupTransferService.start();
    this.haClient.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;HAClient的启动代码在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService$HAClient.run()&lt;/code&gt;路径下。&lt;/p&gt;
&lt;p&gt;其中3个核心的步骤在代码注释中有进行标记&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void run() {
    log.info(this.getServiceName() + &amp;quot; service started&amp;quot;);

    while (!this.isStopped()) {
        try {
            // 步骤一：连接到master
            if (this.connectMaster()) {
                // 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告
                if (this.isTimeToReportOffset()) {
                    // 报告slave offset
                    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);
                    if (!result) {
                        this.closeMaster();
                    }
                }
                // 检查是否有读事件
                this.selector.select(1000);
                //步骤三：处理master返回的消息
                boolean ok = this.processReadEvent();
                if (!ok) {
                    this.closeMaster();
                }
                // 处理完读事件后，如果slave offset更新，需要再次发送新的slave offset
                if (!reportSlaveMaxOffsetPlus()) {
                    continue;
                }

                long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;
                if (interval &amp;gt; HAService.this.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {
                    log.warn(&amp;quot;HAClient, housekeeping, found this connection[&amp;quot; + this.masterAddress + &amp;quot;] expired, &amp;quot; + interval);
                    this.closeMaster();
                    log.warn(&amp;quot;HAClient, master not response some time, so close connection&amp;quot;);
                }
            } else {
                this.waitForRunning(1000 * 5);
            }
        } catch (Exception e) {
            log.warn(this.getServiceName() + &amp;quot; service has exception. &amp;quot;, e);
            this.waitForRunning(1000 * 5);
        }
    }

    log.info(this.getServiceName() + &amp;quot; service end&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;slave连接master&#34;&gt;Slave连接Master&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;connectMaster()&lt;/code&gt;方法的目的是与master进行连接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// master 地址(master的地址在配置文件中配置)
private final AtomicReference&amp;lt;String&amp;gt; masterAddress = new AtomicReference&amp;lt;&amp;gt;();

private boolean connectMaster() throws ClosedChannelException {
    if (null == socketChannel) {
        String addr = this.masterAddress.get();
        if (addr != null) {
            SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);
            if (socketAddress != null) {
                this.socketChannel = RemotingUtil.connect(socketAddress);
                if (this.socketChannel != null) {
                    // 读事件,用于监听master的返回消息
                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);
                }
            }
        }
        // 设置为当前commitlog的偏移量
        this.currentReportedOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();
        this.lastWriteTimestamp = System.currentTimeMillis();
    }

    return this.socketChannel != null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一个点关注下，就是&lt;code&gt;currentReportedOffset&lt;/code&gt;字段，这个字段的目的是表示当前slave已同步的进度，后续在向master进行汇报时也是使用该字段的值。这里进行初始化的时候直接设置为commitlog文件的最大偏移量，如果没有commitlog文件则为0。&lt;/p&gt;
&lt;h3 id=&#34;slave汇报offset&#34;&gt;Slave汇报offset&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告
if (this.isTimeToReportOffset()) {
    // 报告slave offset
    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);
    if (!result) {
        this.closeMaster();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;isTimeToReportOffset()&lt;/code&gt;的作用是判断上一次进行汇报的时间与当前时间差是否大于最大等待间隔（默认5s），这意味着即使5s没有收到master的任何消息，slave也会发送一个汇报请求给master，作用相对于一个心跳包。&lt;/p&gt;
&lt;p&gt;看下&lt;code&gt;reportSlaveMaxOffset()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean reportSlaveMaxOffset(final long maxOffset) {
    // 写位置设为0
    this.reportOffset.position(0);
    // 可写长度为8字节
    this.reportOffset.limit(8);
    // 数据内容为slave当前的offset
    this.reportOffset.putLong(maxOffset);
    // 写模式切换到模式
    // 将读位置设为0
    this.reportOffset.position(0);
    // 可读长度为8字节
    this.reportOffset.limit(8);

    for (int i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; this.reportOffset.hasRemaining(); i++) {
        try {
            // 将数据写入channel中
            this.socketChannel.write(this.reportOffset);
        } catch (IOException e) {
            log.error(this.getServiceName() + &amp;quot;reportSlaveMaxOffset this.socketChannel.write exception&amp;quot;, e);
            return false;
        }
    }

    lastWriteTimestamp = HAService.this.defaultMessageStore.getSystemClock().now();
    return !this.reportOffset.hasRemaining();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以知道slave的汇报请求的数据包内容很简单，就是一个8字节大小的offset数据。&lt;/p&gt;
&lt;p&gt;这里代码中有一个细节，rocketmq的作用再进行写模式切换到读模式时没有使用&lt;code&gt;flip()&lt;/code&gt;方法，而是手动设置&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;limit&lt;/code&gt;,这是由于NIO是一个非阻塞IO，write方法不一定会一次将ByteBuffer的数据全部写入。&lt;/p&gt;
&lt;h3 id=&#34;slave处理同步数据&#34;&gt;Slave处理同步数据&lt;/h3&gt;
&lt;p&gt;步骤三中，调用&lt;code&gt;processReadEvent()&lt;/code&gt;对master返回的数据进行处理，看代码前，我们已经知道master返回的数据是未同步的消息，那么slave要做的事情是什么？当然就是把这个未同步的数据保存到本地的commitlog文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean processReadEvent() {
    // 连续读取到数据大小为0的次数
    int readSizeZeroTimes = 0;
    // 一直读取缓冲区的数据，直到没有剩余
    while (this.byteBufferRead.hasRemaining()) {
        try {
            int readSize = this.socketChannel.read(this.byteBufferRead);
            if (readSize &amp;gt; 0) {
                readSizeZeroTimes = 0;
                boolean result = this.dispatchReadRequest();
                if (!result) {
                    log.error(&amp;quot;HAClient, dispatchReadRequest error&amp;quot;);
                    return false;
                }
            } else if (readSize == 0) {
                // 如果连续三次读到为空,则跳出方法,这里的作用？
                if (++readSizeZeroTimes &amp;gt;= 3) {
                    break;
                }
            } else {
                log.info(&amp;quot;HAClient, processReadEvent read socket &amp;lt; 0&amp;quot;);
                return false;
            }
        } catch (IOException e) {
            log.info(&amp;quot;HAClient, processReadEvent read socket exception&amp;quot;, e);
            return false;
        }
    }

    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码里调用了&lt;code&gt;dispatchReadRequest()&lt;/code&gt;方法进行请求的处理，看下这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean dispatchReadRequest() {
    final int msgHeaderSize = 8 + 4; // phyoffset + size

    while (true) {
        int diff = this.byteBufferRead.position() - this.dispatchPosition;
        if (diff &amp;gt;= msgHeaderSize) {
            // master commitlog 偏移量
            long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPosition);
            // 消息大小
            int bodySize = this.byteBufferRead.getInt(this.dispatchPosition + 8);
            // 本地  commitlog 偏移量
            long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();
            if (slavePhyOffset != 0) {
                // 如果slave的offset和master的offset不一样，说明数据同步过程发生了问题，不再继续同步。
                if (slavePhyOffset != masterPhyOffset) {
                    log.error(&amp;quot;master pushed offset not equal the max phy offset in slave, SLAVE: &amp;quot; + slavePhyOffset + &amp;quot; MASTER: &amp;quot; + masterPhyOffset);
                    return false;
                }
            }

            // 剩余空间够用,将消息追加到commitlog中
            if (diff &amp;gt;= (msgHeaderSize + bodySize)) {
                // 消息数组
                byte[] bodyData = byteBufferRead.array();
                // 消息的
                int dataStart = this.dispatchPosition + msgHeaderSize;
                // 添加数据到本地commitlog中
                HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData, dataStart, bodySize);
                this.dispatchPosition += msgHeaderSize + bodySize;

                if (!reportSlaveMaxOffsetPlus()) {
                    return false;
                }

                continue;
            }
        }

        if (!this.byteBufferRead.hasRemaining()) {
            this.reallocateByteBuffer();
        }

        break;
    }

    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整体的逻辑可以分为俩部分，第一部分是解析请求包，获取消息数据，第二部分是把消息数据写入到commitlog文件中。&lt;/p&gt;
&lt;p&gt;这两部分代码已经写的很清楚了，比较容易理解，就不再赘述。&lt;/p&gt;
">RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-ha-mo-kuai-master-du-xie-chu-li/"" data-c="
          &lt;p&gt;从最抽象的角度看，主从同步流程可以分为3个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master启动&lt;/li&gt;
&lt;li&gt;slave的启动&lt;/li&gt;
&lt;li&gt;m/s 数据同步&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4040fe9fe04d9b877449592aaa9770~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;针对上述步骤，结合rocketmq的设计，可以先提一些问题。&lt;/p&gt;
&lt;h1 id=&#34;疑问点&#34;&gt;疑问点&lt;/h1&gt;
&lt;h2 id=&#34;master&#34;&gt;Master&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何接受&lt;code&gt;slave&lt;/code&gt;的请求？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;处理&lt;code&gt;slave&lt;/code&gt;请求时，如何判断哪些数据需要同步？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何保证发送的数据同步成功的？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;slave&#34;&gt;Slave&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何获取&lt;code&gt;master&lt;/code&gt;的路由信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何向&lt;code&gt;master&lt;/code&gt;报告&lt;code&gt;offset&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何处理&lt;code&gt;master&lt;/code&gt;同步的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高级&#34;&gt;高级&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;同步通知&lt;/strong&gt;和&lt;strong&gt;异步通知&lt;/strong&gt;是如何实现的？&lt;/li&gt;
&lt;li&gt;RocketMQ的&lt;strong&gt;读写分离&lt;/strong&gt;是如何实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文先对Master的部分进行解析：&lt;/p&gt;
&lt;h1 id=&#34;ha类&#34;&gt;HA类&lt;/h1&gt;
&lt;p&gt;主从相关的代码位于 &lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/&lt;/code&gt;路径下，其中主要为两个类&lt;code&gt;HAService&lt;/code&gt;和&lt;code&gt;HAConnection&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;ha类说明&#34;&gt;HA类说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HAService: RocketMQ 主从同步核心实现类&lt;/li&gt;
&lt;li&gt;HAService$AcceptSocketService: Master 监听客户端连接&lt;/li&gt;
&lt;li&gt;HAService$GroupTransferService: 主从同步通知&lt;/li&gt;
&lt;li&gt;HAService$HAClient: Client 端&lt;/li&gt;
&lt;li&gt;HAConnection: M/S间Channel的封装，同时负责MS数据同步逻辑。&lt;/li&gt;
&lt;li&gt;HAConnection$ReadSocketService： Master 网络读实现类&lt;/li&gt;
&lt;li&gt;HAConnection$WriteSocketService：Master 网络写实现类&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9f4b11e8cac44a3940e929af0f2f839~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;源码部分&#34;&gt;源码部分&lt;/h1&gt;
&lt;h2 id=&#34;haservice-模块启动&#34;&gt;HAService 模块启动&lt;/h2&gt;
&lt;p&gt;HA模块的启动路径在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService#start()&lt;/code&gt;下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// HAService 启动
public void start() throws Exception {
    // master相关
    this.acceptSocketService.beginAccept();
    this.acceptSocketService.start();
    this.groupTransferService.start();  // 同步模式的实现
    
    //slave相关
    this.haClient.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;acceptSocketService.beginAccept() : 启动slave的监听服务&lt;/li&gt;
&lt;li&gt;acceptSocketService.start(): 处理slave的连接事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;acceptsocketservicebeginaccept&#34;&gt;acceptSocketService.beginAccept()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void beginAccept() throws Exception {
    // 创建 channel
    this.serverSocketChannel = ServerSocketChannel.open();
    // 创建 selector
    this.selector = RemotingUtil.openSelector();
    // 设置 TCP reuseAddress
    this.serverSocketChannel.socket().setReuseAddress(true);
    // 绑定监听端口,默认10912
    this.serverSocketChannel.socket().bind(this.socketAddressListen);
    // 设置为非阻塞模式
    this.serverSocketChannel.configureBlocking(false);
    // 注册OP_ACCEPT(连接事件)
    this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;acceptsocketservicestart&#34;&gt;acceptSocketService.start()&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void run() {
    log.info(this.getServiceName() + &amp;quot; service started&amp;quot;);

    while (!this.isStopped()) {
        try {
            // 每1s钟处理一次slave连接事件
            this.selector.select(1000);
            Set&amp;lt;SelectionKey&amp;gt; selected = this.selector.selectedKeys();

            if (selected != null) {
                for (SelectionKey k : selected) {
                    if ((k.readyOps() &amp;amp; SelectionKey.OP_ACCEPT) != 0) {
                        // slave的连接channel
                        SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();

                        if (sc != null) {
                            HAService.log.info(&amp;quot;HAService receive new connection, &amp;quot; + sc.socket().getRemoteSocketAddress());

                            try {
                                // 创建一个HAConnection对象，保存slave的Channel
                                HAConnection conn = new HAConnection(HAService.this, sc);
                                // 启动HAConnection
                                conn.start();
                                // 保存HAConnection到connectionList中
                                HAService.this.addConnection(conn);
                            } catch (Exception e) {
                                log.error(&amp;quot;new HAConnection exception&amp;quot;, e);
                                sc.close();
                            }
                        }
                    } else {
                        log.warn(&amp;quot;Unexpected ops in select &amp;quot; + k.readyOps());
                    }
                }

                selected.clear();
            }
        } catch (Exception e) {
            log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);
        }
    }

    log.info(this.getServiceName() + &amp;quot; service end&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当有新的连接时，会将该连接封装成一个&lt;code&gt;HAConnection&lt;/code&gt;对象，调用&lt;code&gt;HAConnection.start()&lt;/code&gt;方法，然后将连接保存到连接列表中。&lt;/p&gt;
&lt;p&gt;master如何处理slave的请求以及如何向slave发送消息的逻辑全部在&lt;code&gt;HAConnection&lt;/code&gt;对象里，继续追踪&lt;code&gt;HAConnection#start()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;haconnection启动&#34;&gt;HAConnection启动&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void start() {
    // master处理slave的消息部分
    this.readSocketService.start();
    // mastger向slave发送消息部分
    this.writeSocketService.start();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里分为&lt;code&gt;readSocketService&lt;/code&gt;和&lt;code&gt;writeSocketService&lt;/code&gt;，顾名思义，一个处理slave的读事件，一个处理写事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;readSocketService : 处理接收到的slave的请求&lt;/li&gt;
&lt;li&gt;writeSocketService: 负责master向slave同步数据的逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;master处理slave请求&#34;&gt;Master处理slave请求&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAConnection.run()&lt;/code&gt;中，主要关注这部分逻辑:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while (!this.isStopped()) {
    try {
        // 1s检查一次读请求
        this.selector.select(1000);
        // 处理读事件
        boolean ok = this.processReadEvent();
        if (!ok) {
            HAConnection.log.error(&amp;quot;processReadEvent error&amp;quot;);
            break;
        }

        // 两次读事件的间隔超过了既定的值，则master和slave的连接失效，跳出循环。
        long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;
        if (interval &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {
            log.warn(&amp;quot;ha housekeeping, found this connection[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] expired, &amp;quot; + interval);
            break;
        }
    } catch (Exception e) {
        HAConnection.log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;处理读事件的代码：&lt;/p&gt;
&lt;p&gt;slave发送的消息内容为要拉取的数据的offset，而master接收要这个offset后，含义有两层&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这个offset表示slave这次要拉取的位置，给master提供参考。&lt;/li&gt;
&lt;li&gt;这个offset也表示slave以及同步到的位置，可以当作一个ack包的作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean processReadEvent() {
    int readSizeZeroTimes = 0;

    // 若byteBufferRead没有剩余
    if (!this.byteBufferRead.hasRemaining()) {
        this.byteBufferRead.flip();
        this.processPosition = 0;
    }

    while (this.byteBufferRead.hasRemaining()) {
        try {
            int readSize = this.socketChannel.read(this.byteBufferRead);
            if (readSize &amp;gt; 0) {
                readSizeZeroTimes = 0;
                this.lastReadTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();
                // 超过8字节就处理,因为slave发送的心跳包就是8字节的offset
                if ((this.byteBufferRead.position() - this.processPosition) &amp;gt;= 8) {
                    // 获取离byteBufferRead.position()最近的8的整数
                    int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);
                    long readOffset = this.byteBufferRead.getLong(pos - 8);
                    this.processPosition = pos;
                    // 更新slave 已拉取的 offset
                    HAConnection.this.slaveAckOffset = readOffset;
                    // 假如是第一次拉取的情况
                    if (HAConnection.this.slaveRequestOffset &amp;lt; 0) {
                        HAConnection.this.slaveRequestOffset = readOffset;
                        log.info(&amp;quot;slave[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] request offset &amp;quot; + readOffset);
                    }
                    // 通知slave已经更新，更新push2SlaveMaxOffset字段
                    HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);
                }
            } else if (readSize == 0) {
                if (++readSizeZeroTimes &amp;gt;= 3) {
                    break;
                }
            } else {
                log.error(&amp;quot;read socket[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] &amp;lt; 0&amp;quot;);
                return false;
            }
        } catch (IOException e) {
            log.error(&amp;quot;processReadEvent exception&amp;quot;, e);
            return false;
        }
    }

    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;master获取到offset后，更新&lt;code&gt;push2SlavemaxOffset&lt;/code&gt;字段，这个字段的作用是表示当前M/S之间已成功同步的位置，在master向slave发送数据时需要。&lt;/p&gt;
&lt;h2 id=&#34;master传输数据&#34;&gt;Master传输数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while (!this.isStopped()) {
    try {
        this.selector.select(1000);

        if (-1 == HAConnection.this.slaveRequestOffset) {
            Thread.sleep(10);
            continue;
        }

        // 是否第一次进行传输
        if (-1 == this.nextTransferFromWhere) {
            // request为0
            if (0 == HAConnection.this.slaveRequestOffset) {
                long masterOffset = HAConnection.this.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();
                masterOffset = masterOffset - (masterOffset % HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getMappedFileSizeCommitLog());

                if (masterOffset &amp;lt; 0) {
                    masterOffset = 0;
                }

                this.nextTransferFromWhere = masterOffset;
            } else {
                // slaveRequestOffset != 0
                this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset;
            }

            log.info(&amp;quot;master transfer data from &amp;quot; + this.nextTransferFromWhere + &amp;quot; to slave[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;], and slave request &amp;quot; + HAConnection.this.slaveRequestOffset);
        }

        // 上次传输是否成功
        if (this.lastWriteOver) {
            // 距离上次写的时间间隔
            long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;
            // 如果等待时间间隔 &amp;gt; ha心跳时间间隔
            if (interval &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) {
                // Build Header
                this.byteBufferHeader.position(0);
                this.byteBufferHeader.limit(headerSize);
                this.byteBufferHeader.putLong(this.nextTransferFromWhere);
                this.byteBufferHeader.putInt(0);
                this.byteBufferHeader.flip();
                this.lastWriteOver = this.transferData();
                if (!this.lastWriteOver) continue;
            }
        } else {
            //上次失败，需要进行重新传输
            this.lastWriteOver = this.transferData();
            if (!this.lastWriteOver) continue;
        }

        // 根据nextTransferFromWhere获取commitlog数据
        SelectMappedBufferResult selectResult = HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);
        if (selectResult != null) {
            int size = selectResult.getSize();
            if (size &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) {
                size = HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();
            }

            long thisOffset = this.nextTransferFromWhere;
            this.nextTransferFromWhere += size;

            selectResult.getByteBuffer().limit(size);
            this.selectMappedBufferResult = selectResult;

            // Build Header
            this.byteBufferHeader.position(0);
            this.byteBufferHeader.limit(headerSize);
            this.byteBufferHeader.putLong(thisOffset);
            this.byteBufferHeader.putInt(size);
            this.byteBufferHeader.flip();

            this.lastWriteOver = this.transferData();
        } else {

            HAConnection.this.haService.getWaitNotifyObject().allWaitForRunning(100);
        }
    } catch (Exception e) {

        HAConnection.log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);
        break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/438c5aae0acf4ea3b06b92a35b010648~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何接受&lt;code&gt;slave&lt;/code&gt;的请求？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：在readSocketService类中进行OP_READ事件处理。master收到slave发送的的offset，表示slave当前同步的位置，master保存该offset。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;处理&lt;code&gt;slave&lt;/code&gt;请求时，如何判断哪些数据需要同步？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：slave的请求会携带同步完的offset，master在readSocketService中保存了该offset，后续writeSocketService在执行OP_WRITE事件时，会与 master的offset进行比较，如果有新的数据则发送给slave。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何保证发送的数据同步成功的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：ack机制，slave -&amp;gt; master 发送的请求中的offset即代表slave已同步完成的进度，假如slave在同步操作时发送异常，那么未同步成功的数据下一次master会再发送过来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于slave于高级部分在后续文章中更新。&lt;/p&gt;
&lt;/blockquote&gt;
">RocketMQ4.9.1源码分析(HA模块) Master读写处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-_shi-wu-half-ban-xiao-xi-chu-li/"" data-c="
          &lt;p&gt;half消息属于RocketMQ事务处理的第一个阶段，可以包括两部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;producer -&amp;gt; broker 发送half消息&lt;/li&gt;
&lt;li&gt;broker 处理half消息&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;p&gt;对应图中的步骤1、2。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bd34b7c086149a298df6672e9c5dda2~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;带着问题看源码, 先提几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;producer 如何发送 half 消息的？&lt;/li&gt;
&lt;li&gt;broker 又是如何区分普通消息和事务消息的&lt;/li&gt;
&lt;/ol&gt;
&lt;!----&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;half消息不会被Consumer消费，是如何实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完就有答案了。&lt;/p&gt;
&lt;h1 id=&#34;producer-half-消息发送&#34;&gt;Producer Half 消息发送&lt;/h1&gt;
&lt;p&gt;首先生产者的使用代码如下，要使用事务消息的功能，生产者对象要使用&lt;code&gt;TransactionMQProducer&lt;/code&gt;进行声明。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws MQClientException {
    // 创建 TransactionMQProducer 实例，并设置生产者组名
    TransactionMQProducer producer = new TransactionMQProducer(&amp;quot;transactionGroup&amp;quot;);
    // 设置 NameServer 地址
    producer.setNamesrvAddr(&amp;quot;127.0.0.1:9876&amp;quot;);

    // 添加事务监听器
    producer.setTransactionListener(new TransactionListener() {
        /**
         * 执行本地事务的方法
         */
        @Override
        public LocalTransactionState executeLocalTransaction(Message message, Object o) {
            // 执行本地事务
            doXXX();
            // 返回执行结果
            return LocalTransactionState.xxx;
        }

        /**
         * 消息回查执行的方法
         */
        @Override
        public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {
			// 回查事务状态
            findxxx();
            // 消息来回查的时候，进行提交事务
            return LocalTransactionState.xxx;
        }
    });

    // 启动producer
    producer.start();
}

// 发送消息
SendResult result = producer.sendMessageInTransaction(msg, null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和普通消息不同，在37行中使用&lt;code&gt;sendMessageIntransaction()&lt;/code&gt;方法发送事务方法，那么发送的逻辑肯定都在这个方法下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException {
    // 本地事务处理逻辑必须要先定义好
    if (null == this.transactionListener) {
        throw new MQClientException(&amp;quot;TransactionListener is null&amp;quot;, null);
    }

    // 对topic进行包装,附带延迟、重试标记
    msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));
    return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;sendMessageInTransaction()&lt;/code&gt;方法, 我们主要关注方法的前半部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter localTransactionExecuter, final Object arg) throws MQClientException {
    TransactionListener transactionListener = getCheckListener();
    if (null == localTransactionExecuter &amp;amp;&amp;amp; null == transactionListener) {
        throw new MQClientException(&amp;quot;tranExecutor is null&amp;quot;, null);
    }

    // ignore DelayTimeLevel parameter
    if (msg.getDelayTimeLevel() != 0) {
        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);
    }
    Validators.checkMessage(msg, this.defaultMQProducer);

    SendResult sendResult;
    // 给消息打上TRAN_MSG标记,标记为事务消息
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &amp;quot;true&amp;quot;);
    // 标记生产者组的目的是broker进行回查时需要
    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
    try {
        // 发送half消息
        sendResult = this.send(msg);
    } catch (Exception e) {
        throw new MQClientException(&amp;quot;send message Exception&amp;quot;, e);
    }
    
    // 略
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到代码里给消息添加了两个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PROPERTY_TRANSACTION_PREPARED : 标记为事务消息，broker可以根据msg是否有该字段来判断是否是事务消息。&lt;/li&gt;
&lt;li&gt;PROPERTY_PRODUCER_GROUP : 生产者组，这个在broker进行事务结果回查时候需要。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在对消息进行特殊包装变成事务消息后，调用的&lt;code&gt;send()&lt;/code&gt;方法就是通用的消息发送方法了，所有消息都是通过这个方法进行发送的。&lt;/p&gt;
&lt;h1 id=&#34;broker-处理-half-消息&#34;&gt;Broker 处理 Half 消息&lt;/h1&gt;
&lt;p&gt;在 broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java 类中，&lt;code&gt;asyncSendMessage()&lt;/code&gt;方法中有一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;...
// 获取事务属性字段
String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);
// 判断是否为空 &amp;amp;&amp;amp; 值为true
if (transFlag != null &amp;amp;&amp;amp; Boolean.parseBoolean(transFlag)) {
  if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {
    response.setCode(ResponseCode.NO_PERMISSION);
    response.setRemark(&amp;quot;the broker[&amp;quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &amp;quot;] sending transaction message is forbidden&amp;quot;);
    return CompletableFuture.completedFuture(response);
  }
  // 存储prepare消息
  putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);
} else {
  // 存储普通消息
  putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看看如果处理prepare消息的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public CompletableFuture&amp;lt;PutMessageResult&amp;gt; asyncPrepareMessage(MessageExtBrokerInner messageInner) {
    return transactionalMessageBridge.asyncPutHalfMessage(messageInner);  //1 调用asyncPutHalfMessage()方法
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;asyncPrepareMessage()&lt;/code&gt;调用&lt;code&gt;asyncPutHalfMessage()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public CompletableFuture&amp;lt;PutMessageResult&amp;gt; asyncPutHalfMessage(MessageExtBrokerInner messageInner) {
    return store.asyncPutMessage(parseHalfMessageInner(messageInner));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;store.asyncPutMessage()&lt;/code&gt;就是通用的方法，普通消息的存储也是使用这个方法，所以half消息的特殊处理在&lt;code&gt;parseHalfMessageInner()&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) {
    // 备份消息的原主题和原队列ID
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());
    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId()));
    msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));
    // 事务消息的topic和queueID是写死固定的
    msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());
    msgInner.setQueueId(0);
    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));
    return msgInner;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分为两部分逻辑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;备份原有的topic和queueId，将消息真正的topic放在&lt;code&gt;REAL_TOPIC&lt;/code&gt;属性中，queueId放在&lt;code&gt;REAL_QID&lt;/code&gt;属性中&lt;/li&gt;
&lt;li&gt;使用事务专用的topic和queueId覆盖旧值，topic = &lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;,queueId = 0。这样意味着所有的half消息都会存在同一个topic队列中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;疑问解答&#34;&gt;疑问解答&lt;/h1&gt;
&lt;p&gt;现在可以回答之前的疑惑了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;producer 如何发送 half 消息的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：RocketMQ对于事务消息，使用了专门的Producer对象&lt;code&gt;TransactionMQProducer&lt;/code&gt;，这个producer的发送消息的方法把消息包装成事务消息。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;broker 又是如何区分普通消息和事务消息的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：在消息发送的时候，在消息的 &lt;code&gt;property&lt;/code&gt;里添加&lt;code&gt;PROPERTY_TRANSACTION_PREPARED&lt;/code&gt;标记，broker根据和这个标记来区分普通消息和事务消息。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;half消息不会被Consumer消费，是如何实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：消息经过特殊处理，都被分配到特有的topic队列中，被隔离了。这样消费者就无法获取到这些消息了。&lt;/p&gt;
">RocketMQ4.9.1源码分析_(事务) Half半消息处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-_shi-wu-broker-ding-shi-hui-cha/"" data-c="
          &lt;h1 id=&#34;启动任务&#34;&gt;启动任务&lt;/h1&gt;
&lt;p&gt;broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void run() {
    log.info(&amp;quot;Start transaction check service thread!&amp;quot;);
    long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();  // 默认值为60000，即60s
    while (!this.isStopped()) {
        this.waitForRunning(checkInterval);
    }
    log.info(&amp;quot;End transaction check service thread!&amp;quot;);
}

@Override
protected void onWaitEnd() {
    long timeout = brokerController.getBrokerConfig().getTransactionTimeOut();
    int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();
    long begin = System.currentTimeMillis();
    log.info(&amp;quot;Begin to check prepare message, begin time:{}&amp;quot;, begin);
    // 调用chekc方法
    this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());
    log.info(&amp;quot;End to check prepare message, consumed time:{}&amp;quot;, System.currentTimeMillis() - begin);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里采用了模板设计模式，重写了&lt;code&gt;run()&lt;/code&gt;和&lt;code&gt;onWaitEnd()&lt;/code&gt;两个方法，其中可以看到&lt;code&gt;onWaitEnd()&lt;/code&gt;方法中调用了&lt;code&gt;check()&lt;/code&gt;方法，那么在哪里调用了这个onWaitEnd()方法呢？看下&lt;code&gt;waitForRunning()&lt;/code&gt;方法，在&lt;code&gt;src/main/java/org/apache/rocketmq/common/ServiceThread.java&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected void waitForRunning(long interval) {
    if (hasNotified.compareAndSet(true, false)) {
        // 调用子类重写的逻辑
        this.onWaitEnd();
        return;
    }

    //entry to wait
    waitPoint.reset();

    try {
        // 等待
        waitPoint.await(interval, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
        log.error(&amp;quot;Interrupted&amp;quot;, e);
    } finally {
        hasNotified.set(false);
        this.onWaitEnd();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结就是以默认60s的间隔执行一次check()方法，check()方法就是定时回查方法，下面看下。&lt;/p&gt;
&lt;h1 id=&#34;check-流程&#34;&gt;check 流程&lt;/h1&gt;
&lt;p&gt;broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中,先看下全部的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
    public void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) {
        try {
            // 定义topic为&amp;quot;RMQ_SYS_TRANS_HALF_TOPIC&amp;quot;
            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;
            // 获取half队列
            Set&amp;lt;MessageQueue&amp;gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);
            if (msgQueues == null || msgQueues.size() == 0) {
                log.warn(&amp;quot;The queue of topic is empty :&amp;quot; + topic);
                return;
            }
            log.debug(&amp;quot;Check topic={}, queues={}&amp;quot;, topic, msgQueues);
            for (MessageQueue messageQueue : msgQueues) {
                long startTime = System.currentTimeMillis();
                // 获取opQueue
                MessageQueue opQueue = getOpQueue(messageQueue);
                // 获取half队列的消费offset
                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);
                // 获取op队列的offset
                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);
                log.info(&amp;quot;Before check, the queue={} msgOffset={} opOffset={}&amp;quot;, messageQueue, halfOffset, opOffset);
                if (halfOffset &amp;lt; 0 || opOffset &amp;lt; 0) {
                    log.error(&amp;quot;MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue&amp;quot;, messageQueue, halfOffset, opOffset);
                    continue;
                }

                List&amp;lt;Long/*处理过得opQueue的offset*/&amp;gt; doneOpOffset = new ArrayList&amp;lt;&amp;gt;();
                HashMap&amp;lt;Long/*halfQueue offset*/, Long/*opQueue offset*/&amp;gt; removeMap = new HashMap&amp;lt;&amp;gt;();  //存储已经处理过,但还未添加到doneOpOffset中的消息
                // 将已处理但未更新的消息保存到removeMap中，后续进行判断时需要
                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);
                if (null == pullResult) {
                    log.error(&amp;quot;The queue={} check msgOffset={} with opOffset={} failed, pullResult is null&amp;quot;, messageQueue, halfOffset, opOffset);
                    continue;
                }
                int getMessageNullCount = 1;  //获取空消息的次数
                long newOffset = halfOffset;  //当前处理half队列的最新进度
                long i = halfOffset; //当前处理消息的half队列偏移量
                while (true) {
                    // 检查当前任务的时间片是否用完
                    if (System.currentTimeMillis() - startTime &amp;gt; MAX_PROCESS_TIME_LIMIT) {
                        log.info(&amp;quot;Queue={} process time reach max={}&amp;quot;, messageQueue, MAX_PROCESS_TIME_LIMIT);
                        break;
                    }
                    // 如果half消息已经被处理过,继续处理下一条消息
                    if (removeMap.containsKey(i)) {
                        log.debug(&amp;quot;Half offset {} has been committed/rolled back&amp;quot;, i);
                        Long removedOpOffset = removeMap.remove(i);
                        doneOpOffset.add(removedOpOffset);
                    } else {
                        // 根据half队列消费offset获取消息
                        GetResult getResult = getHalfMsg(messageQueue, i);
                        MessageExt msgExt = getResult.getMsg();
                        if (msgExt == null) {
                            // 是否最大重试次数
                            if (getMessageNullCount++ &amp;gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) {
                                break;
                            }
                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {
                                log.debug(&amp;quot;No new msg, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());
                                break;
                            } else {
                                log.info(&amp;quot;Illegal offset, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());
                                i = getResult.getPullResult().getNextBeginOffset();
                                newOffset = i;
                                continue;
                            }
                        }

                        // 如果超过存储时间(默认3天)或者超过回查时间(默认15次)
                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {
                            listener.resolveDiscardMsg(msgExt);
                            newOffset = i + 1;
                            i++;
                            continue;
                        }

                        // 如果存储时间大于开始时间，不处理
                        if (msgExt.getStoreTimestamp() &amp;gt;= startTime) {
                            log.debug(&amp;quot;Fresh stored. the miss offset={}, check it later, store={}&amp;quot;, i, new Date(msgExt.getStoreTimestamp()));
                            break;
                        }

                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();  //消息已存储时间
                        long checkImmunityTime = transactionTimeout; //立即检测事务消息的时间
                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS); //获取消息的最晚回查时间
                        if (null != checkImmunityTimeStr) {
                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);
                            // 如果未到回查时间，不处理
                            if (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime) {
                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {
                                    newOffset = i + 1;
                                    i++;
                                    continue;
                                }
                            }
                        } else {
                            if ((0 &amp;lt;= valueOfCurrentMinusBorn) &amp;amp;&amp;amp; (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime)) {
                                log.debug(&amp;quot;New arrived, the miss offset={}, check it later checkImmunity={}, born={}&amp;quot;, i, checkImmunityTime, new Date(msgExt.getBornTimestamp()));
                                break;
                            }
                        }

                        // 获取消息列表
                        List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();
                        // 判断是否需要进行回查
                        boolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime) || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout)) || (valueOfCurrentMinusBorn &amp;lt;= -1);
                        if (isNeedCheck) {
                            // 消息重新put到halfQueue中
                            if (!putBackHalfMsgQueue(msgExt, i)) {
                                continue;
                            }
                            // 执行回查
                            listener.resolveHalfMsg(msgExt);
                        } else {
                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
                            log.debug(&amp;quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&amp;quot;, i, messageQueue, pullResult);
                            continue;
                        }
                    }
                    newOffset = i + 1;
                    i++;
                }
                if (newOffset != halfOffset) {
                    // 更新halfQueue消费进度
                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);
                }
                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);
                if (newOpOffset != opOffset) {
                    // 更新opQueue消费进度
                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);
                }
            }
        } catch (Throwable e) {
            log.error(&amp;quot;Check error&amp;quot;, e);
        }

    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码太多了，一个个拆解分析：&lt;/p&gt;
&lt;h2 id=&#34;获取half队列&#34;&gt;获取half队列&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 定义topic为&amp;quot;RMQ_SYS_TRANS_HALF_TOPIC&amp;quot;
String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;
// 获取half队列
Set&amp;lt;MessageQueue&amp;gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);
if (msgQueues == null || msgQueues.size() == 0) {
    log.warn(&amp;quot;The queue of topic is empty :&amp;quot; + topic);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在rocketmq中，所有事务消息会保存在两个topic队列中，分别是&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;（简称halfQueue）和&lt;code&gt;RMQ_SYS_TRANS_OP _HALF _TOPIC&lt;/code&gt;（简称opQueue）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RMQ_SYS_TRANS _HALF _TOPIC : 保存 half 消息&lt;/li&gt;
&lt;li&gt;RMQ_SYS_TRANS_OP _HALF _TOPIC : 当 half消息收到 commit/rollback 后，会保存到opQueue中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;定义偏移量&#34;&gt;定义偏移量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 开始时间
long startTime = System.currentTimeMillis();
// 获取opQueue
MessageQueue opQueue = getOpQueue(messageQueue);
// 获取half队列的消费offset
long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);
// 获取op队列的offset
long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;startTime : 作用是记录当前时间，后续在判断任务的执行时间时需要&lt;/li&gt;
&lt;li&gt;opQueue : 即&lt;code&gt;RMQ_SYS_TRANS_OP_HALF_TOPIC&lt;/code&gt;队列，保存已处理过的消息。&lt;/li&gt;
&lt;li&gt;halfOffset ： halfQueue 中的消费记录位置，可以保证的halfOffset之后的消息才需要进行回查操作&lt;/li&gt;
&lt;li&gt;opOffset : opQueue中的消费记录，大于opOffset的消息就是距离上次定时回查任务结束后，这段时间新增的消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;标记已处理消息&#34;&gt;标记已处理消息&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;Long/*处理过得opQueue的offset*/&amp;gt; doneOpOffset = new ArrayList&amp;lt;&amp;gt;();
HashMap&amp;lt;Long/*halfQueue offset*/, Long/*opQueue offset*/&amp;gt; removeMap = new HashMap&amp;lt;&amp;gt;();  //存储已经处理过,但还未添加到doneOpOffset中的消息
// 将已处理但未更新的消息保存到removeMap中，后续进行判断时需要
PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;doneOpOffset: 保存opQueue中已经处理过得消息的offset，后续更新opQueue的offset时候要使用&lt;/li&gt;
&lt;li&gt;removeMap : 保存已经保存到opQueue中，但仍在halfQueue中的消息，后续判断消息是否需要回查时的依据之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;fillopremove&#34;&gt;fillOpRemove()&lt;/h3&gt;
&lt;p&gt;方法的目的就是填充已处理的消息到 removeMap&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private PullResult fillOpRemoveMap(HashMap&amp;lt;Long, Long&amp;gt; removeMap, MessageQueue opQueue, long pullOffsetOfOp, long miniOffset, List&amp;lt;Long&amp;gt; doneOpOffset) {
    // step1 : 获取op消息,拉取32条消息
    PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, 32);
    if (null == pullResult) {
        return null;
    }
    // step2 : 判断状态
    if (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) {
        log.warn(&amp;quot;The miss op offset={} in queue={} is illegal, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);
        transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());
        return pullResult;
    } else if (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) { //没有新消息
        log.warn(&amp;quot;The miss op offset={} in queue={} is NO_NEW_MSG, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);
        return pullResult;
    }
    List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();
    if (opMsg == null) {
        log.warn(&amp;quot;The miss op offset={} in queue={} is empty, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);
        return pullResult;
    }
    // step3 : 遍历所有消息
    for (MessageExt opMessageExt : opMsg) {
        // 获取opQueue的offset
        Long queueOffset = getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));
        log.debug(&amp;quot;Topic: {} tags: {}, OpOffset: {}, HalfOffset: {}&amp;quot;, opMessageExt.getTopic(), opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);
        if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) {
            if (queueOffset &amp;lt; miniOffset) {
                // 正常情况，opQueue里的消息在halfQueue中offset要小于当前halfQueue的offset
                doneOpOffset.add(opMessageExt.getQueueOffset());
            } else {
                // 消息已经存储到opQueue中，但是halfQueue中的offset还没有更新
                // 保存到removeMap中，防止后续重复进行回查操作
                removeMap.put(queueOffset, opMessageExt.getQueueOffset());
            }
        } else {
            log.error(&amp;quot;Found a illegal tag in opMessageExt= {} &amp;quot;, opMessageExt);
        }
    }
    log.debug(&amp;quot;Remove map: {}&amp;quot;, removeMap);
    log.debug(&amp;quot;Done op list: {}&amp;quot;, doneOpOffset);
    return pullResult;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义变量&#34;&gt;定义变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int getMessageNullCount = 1;  //获取空消息的次数
long newOffset = halfOffset;  //当前处理half队列的最新进度
long i = halfOffset; //当前处理消息的half队列偏移量
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;getMessageNullCount : rocketMQ允许进行重试，该字段是重试次数判断的依据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;判断是否满足回查条件&#34;&gt;判断是否满足回查条件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 检查当前任务的时间片是否用完
if (System.currentTimeMillis() - startTime &amp;gt; MAX_PROCESS_TIME_LIMIT) {
    log.info(&amp;quot;Queue={} process time reach max={}&amp;quot;, messageQueue, MAX_PROCESS_TIME_LIMIT);
    break;
}
// 如果half消息已经被处理过,继续处理下一条消息
if (removeMap.containsKey(i)) {
    log.debug(&amp;quot;Half offset {} has been committed/rolled back&amp;quot;, i);
    Long removedOpOffset = removeMap.remove(i);
    doneOpOffset.add(removedOpOffset);
} else {
    // 根据half队列消费offset获取消息
    GetResult getResult = getHalfMsg(messageQueue, i);
    MessageExt msgExt = getResult.getMsg();
    if (msgExt == null) {
        // 是否最大重试次数
        if (getMessageNullCount++ &amp;gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) {
            break;
        }
        if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {
            log.debug(&amp;quot;No new msg, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());
            break;
        } else {
            log.info(&amp;quot;Illegal offset, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());
            i = getResult.getPullResult().getNextBeginOffset();
            newOffset = i;
            continue;
        }
    }

    // 如果超过存储时间(默认3天)或者超过回查时间(默认15次)
    if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {
        listener.resolveDiscardMsg(msgExt);
        newOffset = i + 1;
        i++;
        continue;
    }

    // 如果存储时间大于开始时间，不处理
    if (msgExt.getStoreTimestamp() &amp;gt;= startTime) {
        log.debug(&amp;quot;Fresh stored. the miss offset={}, check it later, store={}&amp;quot;, i, new Date(msgExt.getStoreTimestamp()));
        break;
    }

    long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();  //消息已存储时间
    long checkImmunityTime = transactionTimeout; //立即检测事务消息的时间
    String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS); //获取消息的最晚回查时间
    if (null != checkImmunityTimeStr) {
        checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);
        // 如果未到回查时间，不处理
        if (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime) {
            if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {
                newOffset = i + 1;
                i++;
                continue;
            }
        }
    } else {
        if ((0 &amp;lt;= valueOfCurrentMinusBorn) &amp;amp;&amp;amp; (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime)) {
            log.debug(&amp;quot;New arrived, the miss offset={}, check it later checkImmunity={}, born={}&amp;quot;, i, checkImmunityTime, new Date(msgExt.getBornTimestamp()));
            break;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;任务时间片机制：在rocketmq中，有一种通用的设计方案就是给任务分配时间片， 如果时间片用完则直接退出。&lt;/p&gt;
&lt;h2 id=&#34;执行回查&#34;&gt;执行回查&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 获取消息列表
List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();
// 判断是否需要进行回查
boolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime) || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout)) || (valueOfCurrentMinusBorn &amp;lt;= -1);
if (isNeedCheck) {
    // 消息重新put到halfQueue中
    if (!putBackHalfMsgQueue(msgExt, i)) {
        continue;
    }
    // 执行回查
    listener.resolveHalfMsg(msgExt);
} else {
    pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
    log.debug(&amp;quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&amp;quot;, i, messageQueue, pullResult);
    continue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中比较重要的两个部分，&lt;code&gt;putBackHalfMsgQueue()&lt;/code&gt;和&lt;code&gt;resolveHalfMsg()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;putbackhalfmsgqueue&#34;&gt;putBackHalfMsgQueue()&lt;/h3&gt;
&lt;p&gt;这里消息会重写追加到commitlog中，设计巧妙之处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送回查的接口是异步的，将消息重写追加到队列中，下一次回查的时候还能获取到该消息。如果回查有结果，消息就会保存到opQueue中，这样也会在fillOpRemove()中被过滤掉，不影响。&lt;/li&gt;
&lt;li&gt;每次进行回查消息都要修改消息的回查次数属性，使用顺序写的性能要高于修改已存储消息的性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean putBackHalfMsgQueue(MessageExt msgExt, long offset) {
    // 再次将消息存储到commitlog中
    PutMessageResult putMessageResult = putBackToHalfQueueReturnResult(msgExt);
    // 存储成功修改消息的属性
    if (putMessageResult != null &amp;amp;&amp;amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
        // 设置新的消费队列逻辑offset
        msgExt.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());
        // 设置新的commitlog的offset
        msgExt.setCommitLogOffset(putMessageResult.getAppendMessageResult().getWroteOffset());
        // 设置新的msgId
        msgExt.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());
        log.debug(&amp;quot;Send check message, the offset={} restored in queueOffset={} &amp;quot; + &amp;quot;commitLogOffset={} &amp;quot; + &amp;quot;newMsgId={} realMsgId={} topic={}&amp;quot;, offset, msgExt.getQueueOffset(), msgExt.getCommitLogOffset(), msgExt.getMsgId(), msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX), msgExt.getTopic());
        return true;
    } else {
        log.error(&amp;quot;PutBackToHalfQueueReturnResult write failed, topic: {}, queueId: {}, &amp;quot; + &amp;quot;msgId: {}&amp;quot;, msgExt.getTopic(), msgExt.getQueueId(), msgExt.getMsgId());
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更新索引&#34;&gt;更新索引&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (newOffset != halfOffset) {
    // 更新halfQueue消费进度
    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);
}
// 根据doneOpOffset 列表获取opQueue的offset
long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);
if (newOpOffset != opOffset) {
    // 更新opQueue消费进度
    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;calculateOpOffset()&lt;/code&gt;方法简单说返回就是doneOffset列表中最后一个值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private long calculateOpOffset(List&amp;lt;Long&amp;gt; doneOffset, long oldOffset) {
    Collections.sort(doneOffset);
    long newOffset = oldOffset;
    for (int i = 0; i &amp;lt; doneOffset.size(); i++) {
        if (doneOffset.get(i) == newOffset) {
            newOffset++;
        } else {
            break;
        }
    }
    return newOffset;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c075a3fc1d8440d5abf8ad13e2622179~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">RocketMQ4.9.1源码分析_(事务)broker定时回查</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/shou-xie-shi-xian-java-stream/"" data-c="
          &lt;p&gt;项目地址：&lt;a href=&#34;https://github.com/zexho994/River&#34;&gt;https://github.com/zexho994/River&lt;/a&gt;&lt;br&gt;
实现目标：支持和JDK Stream一样的功能, 提供与Stream一样的API，后续会进行更多的API扩展。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;创建操作&lt;/td&gt;
&lt;td&gt;of(T...t)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;中间操作&lt;/td&gt;
&lt;td&gt;map()limit()sort()peek()skip()filter()distinct()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;终结操作&lt;/td&gt;
&lt;td&gt;toArray()reduce()collect()max()anyMatch()findFirst()等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;同时River还需要具备延迟处理（遇到终结操作才触发）的特性。&lt;/p&gt;
&lt;h2 id=&#34;顶层接口-river&#34;&gt;顶层接口-River&lt;/h2&gt;
&lt;p&gt;在river接口中定义好所有需要支持的方法api&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface River&amp;lt;E&amp;gt; {

    //===============================创建操作=====================================

    @SafeVarargs
    static &amp;lt;T&amp;gt; River&amp;lt;T&amp;gt; of(T... t) {
        return RiverGenerator.create(t);
    }

    static &amp;lt;T&amp;gt; River&amp;lt;T&amp;gt; of(Collection&amp;lt;T&amp;gt; collection) {
        return RiverGenerator.create(collection);
    }

    //===============================中间操作=====================================

    /**
     * 将流转换为并行流
     *
     * @return River
     */
    River&amp;lt;E&amp;gt; parallel();

    /**
     * 将流转换为串行流
     *
     * @return River
     */
    River&amp;lt;E&amp;gt; sequential();

    /**
     * 过滤操作
     *
     * @param predicate 过滤的表达式
     * @return 过滤后的River
     */
    River&amp;lt;E&amp;gt; filter(Predicate&amp;lt;E&amp;gt; predicate);

    /**
     * 元素去重操作
     *
     * @return 去重后的River
     */
    River&amp;lt;E&amp;gt; distinct();

    /**
     * 限制River的元素数量
     *
     * @param size 元素的最大数量
     * @return River
     */
    River&amp;lt;E&amp;gt; limit(int size);

    /**
     * 排序
     *
     * @param comparable 比较器
     * @return 添加排序后的River
     */
    River&amp;lt;E&amp;gt; sort(Comparator&amp;lt;E&amp;gt; comparable);

    /**
     * 对元素进行预操作
     *
     * @param consumer 执行的操作
     * @return 新River
     */
    River&amp;lt;E&amp;gt; peek(Consumer&amp;lt;E&amp;gt; consumer);

    /**
     * 跳过指定数量的元素
     *
     * @param size 要跳过的元素数
     * @return new River
     */
    River&amp;lt;E&amp;gt; skip(int size);

    /**
     * 元素转换映射
     *
     * @param function 映射执行逻辑
     * @return new River
     */
    &amp;lt;E_OUT&amp;gt; River&amp;lt;E_OUT&amp;gt; map(Function&amp;lt;? super E, ? extends E_OUT&amp;gt; function);

    //===============================终结操作=====================================

    /**
     * 遍历River所有元素
     *
     * @param consumer 表达式
     */
    void forEach(Consumer&amp;lt;E&amp;gt; consumer);

    /**
     * 输出一个数组
     *
     * @return E类型的数组
     */
    Object[] toArray();

    /**
     * 输出元素到参数数组中
     *
     * @param e 承载元素的数组
     */
    void toArray(E[] e);

    /**
     * 计算元素的数量
     *
     * @return River中元素的数量
     */
    long count();

    /**
     * 操作
     *
     * @param identity    初始值
     * @param accumulator 操作函数
     * @return reduce result
     */
    E reduce(E identity, BinaryOperator&amp;lt;E&amp;gt; accumulator);

    /**
     * 执行操作
     *
     * @param collector 执行操作的收集器
     * @param &amp;lt;R&amp;gt;       结果类型
     * @param &amp;lt;A&amp;gt;       中间累加类型
     * @return 执行结果
     */
    &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super E, A, R&amp;gt; collector);

    /**
     * 获取比较后，最小的元素
     *
     * @param comparator 比较器
     * @return 最小的元素
     */
    Optional&amp;lt;E&amp;gt; min(Comparator&amp;lt;? super E&amp;gt; comparator);

    /**
     * 获取比较后，最大的元素
     *
     * @param comparator 比较器
     * @return 最大的元素
     */
    Optional&amp;lt;E&amp;gt; max(Comparator&amp;lt;? super E&amp;gt; comparator);

    /**
     * 判断匹配，任意即可
     *
     * @param predicate
     * @return true:match success
     */
    boolean anyMatch(Predicate&amp;lt;? super E&amp;gt; predicate);

    /**
     * 判断匹配，所有都要匹配
     *
     * @param predicate
     * @return
     */
    boolean allMatch(Predicate&amp;lt;? super E&amp;gt; predicate);

    /**
     * 判断匹配，都不要匹配上
     *
     * @param predicate
     * @return
     */
    boolean noneMatch(Predicate&amp;lt;? super E&amp;gt; predicate);

    /**
     * 获取第一个元素
     *
     * @return
     */
    Optional&amp;lt;E&amp;gt; findFirst();

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;river实现类-abstractriverpipeline&#34;&gt;River实现类 - AbstractRiverPipeline&lt;/h2&gt;
&lt;p&gt;River接口的实现主要都在&lt;code&gt;AbstractRiverPipeline&lt;/code&gt;类中, 以&lt;code&gt;filter()&lt;/code&gt;为例，返回了一个新的River对象，典型的流式编程的实现方式。&lt;/p&gt;
&lt;p&gt;方法事情主要两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;new一个新的River的实现类。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;accept()&lt;/code&gt;方法中实现&lt;code&gt;wrapSink()&lt;/code&gt;,这个方法在后续构建&lt;code&gt;SinkChain&lt;/code&gt;时候需要调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AbstractRiverPipeline&amp;lt;I, O&amp;gt;
        extends Pipeline&amp;lt;I, O&amp;gt; implements River&amp;lt;O&amp;gt; {
    
    //存储元素的spliterator对象引用
    protected Spliterator sourceSpliterator;

    ...
        
    /**
     * 追加filter操作
     * 创建一个filter的{@link PipelineStage},然后将该stage追到到Pipeline的尾部
     *
     * @param predicate 过滤的表达式
     * @return 新增的filter对象
     */
    @Override
    public River&amp;lt;O&amp;gt; filter(Predicate&amp;lt;O&amp;gt; predicate) {
        return new PipelineStage&amp;lt;O, O&amp;gt;(this) {
            @Override
            public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {
                SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {
                    @Override
                    public void accept(O t) {
                        if (!predicate.test(t)) {
                            return;
                        }
                        getNext().accept(t);
                    }
                };
                sinkChain.setNext(sink);
                return sinkChain;
            }
        };
    }
    
    ...
        
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回的对象是&lt;code&gt;PipelineStage&lt;/code&gt;，是River的子类，扩展了一些于Sink相关的方法。&lt;/p&gt;
&lt;h2 id=&#34;阶段封装-pipelinestage&#34;&gt;阶段封装-PipelineStage&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;PipelineStage&lt;/code&gt;表示一个阶段，什么是阶段？调用filter()后，就相当整个链中添加了一个阶段，可以理解为链表中的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class PipelineStage&amp;lt;I, O&amp;gt; extends AbstractRiverPipeline&amp;lt;I, O&amp;gt; {

    public PipelineStage(Spliterator&amp;lt;I&amp;gt; spliterator) {
        this.setSourceSpliterator(spliterator);
        this.isParallel = false;
    }

    /**
     * @param river 上一个stage
     */
    public PipelineStage(AbstractRiverPipeline&amp;lt;?, I&amp;gt; river) {
        previous = river;
        isParallel = river.isParallel;
        sourceSpliterator = river.sourceSpliterator;
    }

    public Object[] getArray() {
        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);
    }

    public Object getState() {
        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);
    }

    public void setState(O s) {
    }

    @Override
    public PipelineStage&amp;lt;I, O&amp;gt; clone() {
        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过stage中基于前驱指针previous链接的，所以后续wrapSink时候也是，也是从尾到头的方式。&lt;/p&gt;
&lt;p&gt;假设我们的代码是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;River.of(1,2,3).filter().distinct()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;of()操作生成第一个stage，filter()操作生成第二个stage，distinct()操作生成第三个stage。整体看下来就是这样：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92d0302e7b640c9a65d8ad5b70fdaab~tplv-k3u1fbpfcp-watermark.image?&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;head阶段生成-rivergenerator&#34;&gt;Head阶段生成-RiverGenerator&lt;/h2&gt;
&lt;p&gt;head是指第一个River对象，也可以表示为stage0。River接口中默认实现了of()方法，调用的就是&lt;code&gt;RiverGenerator.create()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;E&amp;gt; River&amp;lt;E&amp;gt; create(E... e) {
    Spliterator&amp;lt;E&amp;gt; spliterator = Arrays.spliterator(e);
    PipelineStage&amp;lt;E, E&amp;gt; head = new PipelineStage&amp;lt;E, E&amp;gt;(spliterator) {
        @Override
        public SinkChain&amp;lt;E, E&amp;gt; wrapSink(SinkChain&amp;lt;E, ?&amp;gt; sink) {
            SinkChain&amp;lt;E, E&amp;gt; sinkChain = new SinkChain&amp;lt;E, E&amp;gt;() {
                @Override
                public void accept(E t) {
                    next.accept(t);
                }
            };
            sinkChain.setNext(sink);
            return sinkChain;
        }
    };
    head.setSourceSpliterator(spliterator);
    return head;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;流的处理链-sinkchain&#34;&gt;流的处理链-SinkChain&lt;/h2&gt;
&lt;p&gt;任何时候，在调用终结操作之前，一切操作都只是通过stage链连接在一起，并没有进行任何实际的处理操作，这就需要一个开关来启动流，这个开关放在了所有终结操作中,看下&lt;code&gt;AbstractRiverPipeline.forEach()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
    public void forEach(Consumer&amp;lt;O&amp;gt; consumer) {
        PipelineStage&amp;lt;O, O&amp;gt; stage = new PipelineStage&amp;lt;O, O&amp;gt;(this) {
            @Override
            public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {
                return new SinkChain&amp;lt;O, O&amp;gt;() {
                    @Override
                    public void accept(O t) {
                        consumer.accept(t);
                    }
                };
            }
        };
        // 启动流的开关
        evaluate(stage);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;evaluate()&lt;/code&gt;主要做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将所有stage包装成&lt;code&gt;SinkChain&lt;/code&gt;。（对相关名词概念不清楚的可以看之前的Stream源码解析文章）&lt;/li&gt;
&lt;li&gt;启动流，对所有元素进行处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void evaluate(PipelineStage&amp;lt;?, O&amp;gt; stage) {
    //构建处理链
    SinkChain&amp;lt;O, O&amp;gt; sinkHead = warpPipeline(stage);

    //开始处理
    sinkHead.begin(-1);
    //遍历元素
    sinkHead.getSourceSpliterator().forEachRemaining(sinkHead);
    sinkHead.end();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;包装-wrappipeline&#34;&gt;包装 - wrapPipeline&lt;/h3&gt;
&lt;p&gt;顺序是从尾到头进行的，返回的sink是第一个阶段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private SinkChain&amp;lt;O, O&amp;gt; warpPipeline(AbstractRiverPipeline river) {
    SinkChain&amp;lt;O, O&amp;gt; sink = null;
    for (; river != null; river = river.previous) {
        sink = river.wrapSink(sink);
    }
    return sink;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;wrapSink()&lt;/code&gt;的逻辑对应的就是&lt;code&gt;AbstractRiverPipeline&lt;/code&gt;中重写的逻辑&lt;/p&gt;
&lt;p&gt;这样返回的对象就是一条sink链了，并且链中每一个sink都有自己的&lt;code&gt;begin()&lt;/code&gt;、&lt;code&gt;accept()&lt;/code&gt;、&lt;code&gt;end()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&#34;流的运行流程&#34;&gt;流的运行流程&lt;/h3&gt;
&lt;p&gt;evaluate第二部分的工作是运行流&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先调用&lt;code&gt;begin()&lt;/code&gt;方法，从头到尾执行一遍所有对象的&lt;code&gt;begin()&lt;/code&gt;方法，主要作用是进行初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forEachRemaining&lt;/code&gt;的作用就是对数据源spliterator元素执行&lt;code&gt;accept()&lt;/code&gt;方法，可以从头倒尾一个个执行。&lt;/li&gt;
&lt;li&gt;最后调用&lt;code&gt;end()&lt;/code&gt;方法，从头到尾执行一遍，主要目的是数据的情况，字段设为null等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依然用上面的&lt;code&gt;filter()&lt;/code&gt;方法和&lt;code&gt;distinct()&lt;/code&gt;为例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public River&amp;lt;O&amp;gt; filter(Predicate&amp;lt;O&amp;gt; predicate) {
    return new PipelineStage&amp;lt;O, O&amp;gt;(this) {
        @Override
        public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {
            SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {
                @Override
                public void accept(O t) {
                    // 如果不符合要求，不再向后传递该元素，该元素的处理到此为止
                    if (!predicate.test(t)) {
                        return;
                    }
                    //如何要求则调用下一个sink的accept()方法
                    getNext().accept(t);
                }
            };
            sinkChain.setNext(sink);
            return sinkChain;
        }
    };
}

@Override
public River&amp;lt;O&amp;gt; distinct() {
    return new PipelineStage&amp;lt;O, O&amp;gt;(this) {
        @Override
        public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {
            SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {
                private HashSet&amp;lt;O&amp;gt; set;

                @Override
                public void begin(int n) {
                    //执行初始化工作
                    this.set = new HashSet&amp;lt;&amp;gt;(n &amp;gt; 0 ? n : 16);
                    //调用下一个sink的begin()方法
                    super.begin(n);
                }

                @Override
                public void end() {
                    this.set = null;
                    super.end();
                }

                @Override
                public void accept(O t) {
                    if (!set.add(t)) {
                        return;
                    }
                    getNext().accept(t);
                }
            };
            sinkChain.setNext(sink);
            return sinkChain;
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;文章只是列举了一些关键步骤的设计与实现，设计的思路大多数来源于JDK Stream的源码，如何实现一个Stream，主要的目的是可以更好的理解Stream一些地方为什么要那么设计，因为只有在自己开发的时候才能体会到设计的精妙。&lt;/p&gt;
&lt;p&gt;项目的源码在github，测试代码在test包下，目前只支持串行流，后续会添加并行流的支持，并且提供更多的API，让River可以进行更多更强大的操作。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&#34;https://github.com/zexho994/River&#34;&gt;https://github.com/zexho994/River&lt;/a&gt;&lt;/p&gt;
">手写实现 Java Stream</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-parallel-stream/"" data-c="
          &lt;h2 id=&#34;提出疑问&#34;&gt;提出疑问&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如何转换流类型，怎么实现的？&lt;/li&gt;
&lt;li&gt;如何切分任务的？&lt;/li&gt;
&lt;li&gt;如何合并任务结果的？&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;任务切分&#34;&gt;任务切分&lt;/h2&gt;
&lt;p&gt;并行流的底层执行是基于ForkJoin框架的，了解的都知道ForkJoin框架要执行的任务逻辑需要使用者重写，重写内容包括如果切分任务，所以去看ForkJoinTask的实现子类如何实现Compute()方法就可以知道如何进行任务切分的。&lt;br&gt;
在AbstractTask类中实现了核心方法。&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec498e18d90a4c11bb046b48ce762f02~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
其中最核心的方法是compute()方法，定义了计算算法的逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
    * 决定是否进一步拆分一个任务或直接计算它。
    * 如果直接计算,调用doLeaf并将结果传递给setRawResult。
    * 否则就拆分子任务，分叉一个，继续作为另一个。
	* 该方法的结构是为了在一系列的使用中节约资源。循环在分裂时继续进行其中一个子任务，
    * 以避免深度递归。为了应对可能系统性地偏向于左重或右重拆分的拆分器，我们在循环中交替使用哪个子任务被分叉或继续。
    **/
    @Override
    public void compute() {
        Spliterator&amp;lt;P_IN&amp;gt; rs = spliterator, ls; // right, left spliterators
        //估计rs的元素数量
        long sizeEstimate = rs.estimateSize();
        //获取大小阈值
        long sizeThreshold = getTargetSize(sizeEstimate);
        //
        boolean forkRight = false;
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;) K task = (K) this;
        // 判断条件
        // 1. 元素数量 &amp;gt; 阈值
        // 2. rs可以进行切割
        while (sizeEstimate &amp;gt; sizeThreshold &amp;amp;&amp;amp; (ls = rs.trySplit()) != null) {
            K leftChild, rightChild, taskToFork;
            // 使用ls,rs构造两个新的任务
            task.leftChild  = leftChild = task.makeChild(ls);
            task.rightChild = rightChild = task.makeChild(rs);
            //设置等待数量为1
            task.setPendingCount(1);
            
            // 轮流执行左/右两个任务
            if (forkRight) {
                forkRight = false;
                rs = ls;
                task = leftChild;
                taskToFork = rightChild;// rightChild.fork()
            }
            else { 
                forkRight = true;
                task = rightChild;
                taskToFork = leftChild;//leftChild.fork()
            }
            // 递归
            taskToFork.fork();
            sizeEstimate = rs.estimateSize();
        }
        task.setLocalResult(task.doLeaf());
        task.tryComplete();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本质上理解，就是将一个Spliterator进行切分成两部分，然后两部分再进行切分，直到while()条件无法再满足，然后对该部分进行运算，将运算结果保存在节点的LocalResult字段上。这部分就是分支的切分阶段。&lt;/p&gt;
&lt;h2 id=&#34;结果合并&#34;&gt;结果合并&lt;/h2&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;long count = Stream.of(1, 2, 3, 4, 5).parallel().reduce((x, y) -&amp;gt; x + y + 10).get();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AbstractPipeline.evaluate()&lt;/code&gt;方法是并行流与串行流的分叉点：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
        assert getOutputShape() == terminalOp.inputShape();
        if (linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        linkedOrConsumed = true;

        return isParallel()
               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))  //并行流执行点
               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ReduceOps.evaluateParallel()&lt;/code&gt;方法是其实现之一&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public &amp;lt;P_IN&amp;gt; R evaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,
                                 Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
    return new ReduceTask&amp;lt;&amp;gt;(this, helper, spliterator).invoke().get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要做了两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个ReduceTask任务&lt;/li&gt;
&lt;li&gt;任务调用invoke()执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建的逻辑没有额外的操作，就是将三个参数赋值到实例变量中。&lt;/p&gt;
&lt;p&gt;invoke()是ForkJoinTask的方法，方法这里主要关注&lt;code&gt;invoke()&lt;/code&gt;方法的逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Commences performing this task, awaits its completion if
* necessary, and returns its result, or throws an (unchecked)
* {@code RuntimeException} or {@code Error} if the underlying
* computation did so.
*
* @return the computed result
*/
public final V invoke() {
    int s;
    //执行任务
    if ((s = doInvoke() &amp;amp; DONE_MASK) != NORMAL)
        reportException(s);

    // 这里放回的是最终结果
    return getRawResult();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
* Implementation for invoke, quietlyInvoke.
*
* @return status upon completion
*/
private int doInvoke() {
    int s; Thread t; ForkJoinWorkerThread wt;
    return (s = doExec()) &amp;lt; 0 ? s :
    ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
        (wt = (ForkJoinWorkerThread)t).pool.
        awaitJoin(wt.workQueue, this, 0L) :
    externalAwaitDone();
}

==&amp;gt; JDK代码为了性能，牺牲了可读性，这里整理下：

private int doInvoke() {
    s = doExec();
    if (s &amp;lt; 0) return s;
    
	t = Thread.currentThread();
    if (t instanceof ForkJoinWorkerThread) {
    	ForkJoinWorkerThread wt = (ForkJoinWorkerThread)t.pool();
        return wt.awaitJoin(wt.workQueue,this,0L);
    }
    
    return externalAwaitDone();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    /**
     * If the pending count is nonzero, decrements the count;
     * otherwise invokes {@link #onCompletion(CountedCompleter)}
     * and then similarly tries to complete this task&#39;s completer,
     * if one exists, else marks this task as complete.
     */
    public final void tryComplte() {
        CountedCompleter&amp;lt;?&amp;gt; a = this, s = a;
        for (int c;;) {
            if ((c = a.pending) == 0) {
                a.onCompletion(s);
                if ((a = (s = a).completer) == null) {
                    s.quietlyComplete();
                    return;
                }
            }
            else if (U.compareAndSwapInt(a, PENDING, c, c - 1))
                return;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;ReduceOps.onCompletion()&lt;/code&gt;的重写方法中，如果是不是叶子节点，则合并两个子节点的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onCompletion(CountedCompleter&amp;lt;?&amp;gt; caller) {
    if (!isLeaf()) {
        //如果不是叶子节点，将左右两个子节点的结果合并。
        S leftResult = leftChild.getLocalResult();
        leftResult.combine(rightChild.getLocalResult());
        setLocalResult(leftResult);
    }
    // GC spliterator, left and right child
    super.onCompletion(caller);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关注里面3个方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isLeaf()&lt;/li&gt;
&lt;li&gt;combine()&lt;/li&gt;
&lt;li&gt;super.onCompletion()&lt;br&gt;
isLeaf()判断是不是叶子节点，只有非叶子节点才有两个子节点，然后才能进行合并任务：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected boolean isLeaf() {
    return leftChild == null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;节点在执行完后调用&lt;code&gt;super.onCompletionc(caller)&lt;/code&gt;方法, 字段设为null，为了gc&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void onCompletion(CountedCompleter&amp;lt;?&amp;gt; caller) {
    spliterator = null;
    leftChild = rightChild = null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;终点看下combine()方法，这个方法的作用是将结果组合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public void combine(ReducingSink other) {
    if (!other.empty)
        accept(other.state);
}

// 将本类的state和参数t进行一次运算，由于t是另一个部分运算的结果
// 这里的作用就是两部分进行运算求出结果
@Override
public void accept(T t) {
    if (empty) {
        empty = false;
        state = t;
    } else {
        state = operator.apply(state, t);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;apply(state,t)&lt;/code&gt;运算的逻辑是使用者定义的，对应我们的示例即 &lt;code&gt;.reduce((x, y) -&amp;gt; x + y + 10)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过这种方法，就可以对所有节点的结果进行两两组合，得出最终结果了。&lt;/p&gt;
&lt;h2 id=&#34;疑问解答&#34;&gt;疑问解答&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如何转换流类型，怎么实现的？
&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;sequential()&lt;/code&gt;或 &lt;code&gt;parallel()&lt;/code&gt;转换流的类型，源码中是对 &lt;code&gt;sourceStage.parallel = true;&lt;/code&gt;进行标记，最后在启动时候根据和这个标记决定串行or并行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何切分任务的？
&lt;ul&gt;
&lt;li&gt;底层利用ForkJoindPool框架实现对任务的切分和合并任务，重写&lt;code&gt;compute()&lt;/code&gt;，对Splitertor进行拆分，然后递归调用&lt;code&gt;compute()&lt;/code&gt;方法进行不断切分，直到Splitertor无法再切分，执行该部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何合并任务结果的？
&lt;ul&gt;
&lt;li&gt;重写&lt;code&gt;onCompletionc()&lt;/code&gt;，对每一个非叶子节点，都会将两个子节点的结果通过&lt;code&gt;combine()&lt;/code&gt;方法进行组合，然后一直向上仿佛，知道所有节点结果都组合，最后返回根节点的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">深入解析 Java Parallel Stream</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamxia-zhong-jie-cao-zuo/"" data-c="
          &lt;h3 id=&#34;几个疑问&#34;&gt;几个疑问&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;终结方法是如何进行操作的？&lt;/li&gt;
&lt;li&gt;如何实现由终结操作触发流的运作的？&lt;/li&gt;
&lt;li&gt;如何保证一个流一次只能执行一个终结方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;使用方式&#34;&gt;使用方式&lt;/h3&gt;
&lt;p&gt;列举四种终结操作，在Stream提供的API中，也是四类：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f302257d5bb44e519c5bb32da6fb5daa~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 计算流中元素数量，FindOP
long count = afterLimit.count();

// 遍历所有元素,ForEachOp
afterLimit.forEach(System.out::printl);

// 获取第一个元素,MatchOp
Optional&amp;lt;Integer&amp;gt; any = afterLimit.findFirst();

// 判断是否,ReduceOp
boolean flag = afterLimit.anyMatch(i -&amp;gt; i == 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;count&#34;&gt;count()&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;ReferencePipeline&lt;/code&gt;类中实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public final long count() {
 	// 调用mapToLong将所有元素变成1，然后计算sum
    return mapToLong(e -&amp;gt; 1L).sum();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;maotolong&#34;&gt;maoToLong()&lt;/h4&gt;
&lt;p&gt;mapToLong()方法，是一个中间操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
    public final LongStream mapToLong(ToLongFunction&amp;lt;? super P_OUT&amp;gt; mapper) {
        Objects.requireNonNull(mapper);
        return new LongPipeline.StatelessOp&amp;lt;P_OUT&amp;gt;(this, StreamShape.REFERENCE,
                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;Long&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;P_OUT, Long&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        //
                        downstream.accept(mapper.applyAsLong(u));
                    }
                };
            }
        };
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ToLongFunction是一个函数式接口类, accept()里的逻辑便是&lt;code&gt;e -&amp;gt; 1L&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@FunctionalInterface
public interface ToLongFunction&amp;lt;T&amp;gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    long applyAsLong(T value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看下Sum()方法,在LongPipeline类中，传入参数是一个Long::sum, sum的作用是相加两个值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public final long sum() {
    // use better algorithm to compensate for intermediate overflow?
    return reduce(0, Long::sum);
}

//public static long sum(long a, long b) {
//    return a + b;
//}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;reduce&#34;&gt;reduce()&lt;/h4&gt;
&lt;p&gt;reduce方法,将操作函数op封装成一个Sink，makeLong()的作用就是会生产一个Sink&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public final long reduce(long identity, LongBinaryOperator op) {
    return evaluate(ReduceOps.makeLong(identity, op));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code long} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&amp;lt;Long, Long&amp;gt;
    makeLong(long identity, LongBinaryOperator operator) {
        Objects.requireNonNull(operator);
        class ReducingSink
                implements AccumulatingSink&amp;lt;Long, Long, ReducingSink&amp;gt;, Sink.OfLong {
                
            //state是一个用作记录的值
            private long state;

            @Override
            public void begin(long size) {
                state = identity;
            }

			//参数传进来的就是sun(),所以这里的accept()的作用就是对state不断进行累加
            @Override
            public void accept(long t) {
                state = operator.applyAsLong(state, t);
            }

            @Override
            public Long get() {
                return state;
            }

            @Override
            public void combine(ReducingSink other) {
                accept(other.state);
            }
        }
        return new ReduceOp&amp;lt;Long, Long, ReducingSink&amp;gt;(StreamShape.LONG_VALUE) {
            @Override
            public ReducingSink makeSink() {
                return new ReducingSink();
            }
        };
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;evaluate&#34;&gt;evaluate()&lt;/h4&gt;
&lt;p&gt;看回evaluate()方法，这个方法用来执行终结操作的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
    assert getOutputShape() == terminalOp.inputShape();
    //判断流是否已被使用
    if (linkedOrConsumed)
        throw new IllegalStateException(MSG_STREAM_LINKED);
    //设置使用标记为true
    linkedOrConsumed = true;

    //根据流类型，执行相应的推断操作
    return isParallel()
        ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
        : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关注时序流的推断方法，可以看到这个方法的实现分为四种，对应上面提到的四类类型操作，count属于ReduceOp，进去看下。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140540bd57794266af310e7c016400f5~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Override
public &amp;lt;P_IN&amp;gt; R evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,
                                   Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
    //调用wrapAndCopyInto()方法
    return helper.wrapAndCopyInto(makeSink(), spliterator).get();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;wrapandcopyinto&#34;&gt;wrapAndCopyInto()&lt;/h4&gt;
&lt;p&gt;保证所有stage -&amp;gt; sink链表，然后执行copyInto()方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@Override
    final &amp;lt;P_IN, S extends Sink&amp;lt;E_OUT&amp;gt;&amp;gt; S wrapAndCopyInto(S sink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        return sink;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;warpsink&#34;&gt;warpSink()&lt;/h4&gt;
&lt;p&gt;就是在这里，从后向前，包装所有的stage阶段，形成一条sink链表。这样将之前一个个stage的链表结构包装成一个个Sink。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@Override
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {
        Objects.requireNonNull(sink);
		
        //从后向前遍历
        for ( @SuppressWarnings(&amp;quot;rawtypes&amp;quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {
            //执行每个opWrapSink()方法，这个方法在每个操作类中都进行了重写
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        //返回头sink
        return (Sink&amp;lt;P_IN&amp;gt;) sink;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;copyinto&#34;&gt;copyInto()&lt;/h4&gt;
&lt;p&gt;这个方法是整个流水线的启动开关，流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用第一个sink的begin()方法&lt;/li&gt;
&lt;li&gt;执行数据源的spliterator.forEachRemaining(wrappendSink)方法遍历调用accept()方法&lt;/li&gt;
&lt;li&gt;end() 通知结束&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	@Override
    final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        Objects.requireNonNull(wrappedSink);

        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            //通知第一个sink，做好准备接受流
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            //执行
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
        }
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;foreachremaining&#34;&gt;forEachRemaining()&lt;/h4&gt;
&lt;p&gt;在各个容器中都有实现forEachRemaining()这个方法，在ArrayList中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean tryAdvance(Consumer&amp;lt;? super E&amp;gt; action) {
    if (action == null)
        throw new NullPointerException();
    int hi = getFence(), i = index;
    if (i &amp;lt; hi) {
        index = i + 1;
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;) E e = (E)list.elementData[i];
        //执行accept()方法
        action.accept(e);
        if (list.modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他终结操作&#34;&gt;其他终结操作&lt;/h3&gt;
&lt;h4 id=&#34;foreach&#34;&gt;forEach()&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;ReferencePipeline&lt;/code&gt;类中，实现了forEach()方法，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// from ReferencePipeline.class

@Override
public void forEach(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
    // ForEachOps..
    evaluate(ForEachOps.makeRef(action, false));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;evaluate后面的逻辑与count后面的一样了，略。&lt;/p&gt;
&lt;h4 id=&#34;findfirst-anymatch&#34;&gt;findFirst() anyMatch()&lt;/h4&gt;
&lt;p&gt;findFirst()和anyMatch()的逻辑也不再多说了，一个套路，看下实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public final Optional&amp;lt;P_OUT&amp;gt; findFirst() {
    return evaluate(FindOps.makeRef(true));
}

@Override
public final boolean anyMatch(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
    return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;疑问解答&#34;&gt;疑问解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;终结方法是如何进行操作的？
&lt;ul&gt;
&lt;li&gt;终结操作的实现里面都有调用evaluate()方法，这个方法最后会warp所有操作变成一串sink，然后从头开始执行begin(),accept(),end()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何实现由终结操作触发流的运作的？
&lt;ul&gt;
&lt;li&gt;触发的开关是wrapAndCopyInto(),这个方法只有在终结操作中才有被调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何保证一个流一次只能执行一个终结方法？
&lt;ul&gt;
&lt;li&gt;evaluate()方法中执行一次后&lt;code&gt;linkedOrConsumed&lt;/code&gt;设为true，后续再出发evaluate()方法就会异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://colobu.com/2014/11/18/Java-8-Stream/&#34;&gt;Java 8 Stream探秘 (colobu.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">深入解析Java Stream（下）：终结操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamzhong-op-cao-zuo-liu/"" data-c="
          &lt;h3 id=&#34;几个疑问&#34;&gt;几个疑问&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;各个中间操作是如何进行关联的？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何执行完一个中间操作，然后执行下一个？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有状态的中间操作是怎么保存状态的？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;懒加载如何实现的&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;使用方式&#34;&gt;使用方式&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; st = headStream.filter(e-&amp;gt; e=1).distinct().sort();
//等同于
Stream&amp;lt;Integer&amp;gt; afterFilter = headStream.filter(e -&amp;gt; e != 2);
Stream&amp;lt;Integer&amp;gt; afterDistinct = afterFilter.distinct();
Stream&amp;lt;Integer&amp;gt; afterSort = afterDistinct.sort();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;filter&#34;&gt;Filter&lt;/h3&gt;
&lt;p&gt;执行filter(op)会发生什么？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; afterFilter = head.filter(e -&amp;gt; e = 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;filter()方法定义在&lt;code&gt;Stream&lt;/code&gt;类，实现在&lt;code&gt;ReferencePipeline&lt;/code&gt;类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//ReferencePipeline.class

@Override
public final Stream&amp;lt;P_OUT&amp;gt; filter(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {
    Objects.requireNonNull(predicate);

    // 返回一个StatelessOp类
    // 构造函数参数为(this,)
    return new StatelessOp&amp;lt;P_OUT, P_OUT&amp;gt;(this, StreamShape.REFERENCE,
                                         StreamOpFlag.NOT_SIZED) {
        @Override
        Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;P_OUT&amp;gt; sink) {
            return new Sink.ChainedReference&amp;lt;P_OUT, P_OUT&amp;gt;(sink) {
                @Override
                public void begin(long size) {
                    downstream.begin(-1);
                }

                @Override
                public void accept(P_OUT u) {
                    if (predicate.test(u))
                        downstream.accept(u);
                }
            };
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回一个&lt;code&gt;StatelessOp&lt;/code&gt;类(因为filter是一个无状态操作)，看下&lt;code&gt;StatelessOp&lt;/code&gt;类,是一个静态抽象内部类，继承了&lt;code&gt;ReferencePipeline&lt;/code&gt;类。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//ReferencePipeline.class

    /**
     * Base class for a stateless intermediate stage of a Stream.
     *
     * @param &amp;lt;E_IN&amp;gt; type of elements in the upstream source
     * @param &amp;lt;E_OUT&amp;gt; type of elements in produced by this stage
     * @since 1.8
     */
    abstract static class StatelessOp&amp;lt;E_IN, E_OUT&amp;gt;
            extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
        /**
         * Construct a new Stream by appending a stateless intermediate
         * operation to an existing stream.
         *
         * @param upstream The upstream pipeline stage
         * @param inputShape The stream shape for the upstream pipeline stage
         * @param opFlags Operation flags for the new stage
         */
        StatelessOp(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; upstream,
                    StreamShape inputShape,
                    int opFlags) {
            super(upstream, opFlags);
            assert upstream.getOutputShape() == inputShape;
        }

        @Override
        final boolean opIsStateful() {
            return false;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;中间super()会执行&lt;code&gt;AbstractPipeline&lt;/code&gt;类的构造方法, 连接stage之间的关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//AbstractPipeline.class

    /**
     * Constructor for appending an intermediate operation stage onto an
     * existing pipeline.
     *
     * @param previousStage the upstream pipeline stage
     * @param opFlags the operation flags for the new stage, described in
     * {@link StreamOpFlag}
     */
    AbstractPipeline(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; previousStage, int opFlags) {
        if (previousStage.linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        previousStage.linkedOrConsumed = true;
        previousStage.nextStage = this;

        this.previousStage = previousStage;
        this.sourceOrOpFlags = opFlags &amp;amp; StreamOpFlag.OP_MASK;
        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);
        this.sourceStage = previousStage.sourceStage;
        if (opIsStateful())
            sourceStage.sourceAnyStateful = true;
        this.depth = previousStage.depth + 1;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83eb7d9726541b5826f8d5bcfef7538~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;distinct&#34;&gt;Distinct&lt;/h3&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Stream&amp;lt;Integer&amp;gt; afterDistinct = afterFilter.distinct();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;distinct的方法实现在&lt;code&gt;ReferencePipeline&lt;/code&gt;类下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public final Stream&amp;lt;P_OUT&amp;gt; distinct() {
    return DistinctOps.makeRef(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用DistinctOps类的makeRef()方法，返回一个StatefulOp类，并重写了4个方法，实现逻辑在opWrapSink()中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Appends a &amp;quot;distinct&amp;quot; operation to the provided stream, and returns the
     * new stream.
     *
     * @param &amp;lt;T&amp;gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     * @return the new stream
     */
    static &amp;lt;T&amp;gt; ReferencePipeline&amp;lt;T, T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {
        // 返回一个StatefulOp类
        return new ReferencePipeline.StatefulOp&amp;lt;T, T&amp;gt;(upstream, StreamShape.REFERENCE,
                                                      StreamOpFlag.IS_DISTINCT | StreamOpFlag.NOT_SIZED) {

            // 重写了以下几个方法，内容省略...
            &amp;lt;P_IN&amp;gt; Node&amp;lt;T&amp;gt; reduce(PipelineHelper&amp;lt;T&amp;gt; helper, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {...}

            @Override
            &amp;lt;P_IN&amp;gt; Node&amp;lt;T&amp;gt; opEvaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,
                                              Spliterator&amp;lt;P_IN&amp;gt; spliterator,
                                              IntFunction&amp;lt;T[]&amp;gt; generator) {...}

            @Override
            &amp;lt;P_IN&amp;gt; Spliterator&amp;lt;T&amp;gt; opEvaluateParallelLazy(PipelineHelper&amp;lt;T&amp;gt; helper, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {...}

            @Override
            Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {
                Objects.requireNonNull(sink);

                if (StreamOpFlag.DISTINCT.isKnown(flags)) {
                    ...
                } else if (StreamOpFlag.SORTED.isKnown(flags)) {
                    ...
                } else {
                    // 返回一个SinkChainedReference类
                    return new Sink.ChainedReference&amp;lt;T, T&amp;gt;(sink) {
                        //使用一个Set缓存数据，进行去重
                        Set&amp;lt;T&amp;gt; seen;

                        //当上游通知begin的时候，初始化Set
                        @Override
                        public void begin(long size) {
                            seen = new HashSet&amp;lt;&amp;gt;();
                            downstream.begin(-1);
                        }

                        //略
                        @Override
                        public void end() {
                            seen = null;
                            downstream.end();
                        }

                        //如果已经存在，之间抛弃
                        @Override
                        public void accept(T t) {
                            if (!seen.contains(t)) {
                                seen.add(t);
                                downstream.accept(t);
                            }
                        }
                    };
                }
            }
        };
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;StatefulOp类与StatelessOp类相似,都是继承了&lt;code&gt;ReferencePipeline&lt;/code&gt;类，然后中间super()页会执行&lt;code&gt;AbstractPipeline&lt;/code&gt;类的构造方法, 连接stage之间的关系&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * Base class for a stateful intermediate stage of a Stream.
     *
     * @param &amp;lt;E_IN&amp;gt; type of elements in the upstream source
     * @param &amp;lt;E_OUT&amp;gt; type of elements in produced by this stage
     * @since 1.8
     */
    abstract static class StatefulOp&amp;lt;E_IN, E_OUT&amp;gt; extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
 		//省略
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1bb602651a41efb5b38673063b1523~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;至于其他的中间操作，套路都是类似的，操作逻辑封装在&lt;code&gt;opWrapSink()&lt;/code&gt;方法里, 可以慢慢的看。&lt;/p&gt;
&lt;h3 id=&#34;疑问解答&#34;&gt;疑问解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;各个中间操作是如何进行关联的？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;一个个的操作封装成了一个个的&lt;code&gt;statelessOp&lt;/code&gt;或&lt;code&gt;stateFulOp&lt;/code&gt;对象，以双向链表的方法串起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如何执行完一个中间操作，然后执行下一个？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Sink类负责流水线操作的承接上下游和执行操作的任务，核心方法为begain()、accept()、end()。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有状态的中间操作是怎么保存状态的？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;有状态的中间操作封装成&lt;code&gt;stateFulOp&lt;/code&gt;对象，各自都有独立的逻辑，具体的参考&lt;code&gt;sort()&lt;/code&gt;的实现逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;懒加载如何实现的&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每个中间操作调用后，只是append在流程的尾部，保存了关联关系而已。&lt;/li&gt;
&lt;li&gt;流水线操作的启动，要交给wrapAndCopyInto()方法调用Head的Sink()操作，而wrapAndCopyInto()方法都需要由终结操作进行触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">深入解析Java Stream（中）：OP操作流</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/1V4Hrg06J/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;了解Stream中Sink和Pipline的概念，以及剖析Stream是如何创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;类图&#34;&gt;类图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fccb594381b4b488f58abd47d935f06~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;概念解释&#34;&gt;概念解释&lt;/h2&gt;
&lt;h3 id=&#34;pipline和stage&#34;&gt;Pipline和Stage&lt;/h3&gt;
&lt;p&gt;Pipline是流水线，表示一整个流程。Stage表示流水线的其中一个阶段。是一个比较抽象层面的描述，因为stage主要表示一种逻辑上的顺序关系，而具体每一个阶段要干嘛、怎么干，使用Sink来进行描述。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new stream          //stage 0
    .filter()       //stage 1
    .sort()         //stage 2
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37dd9b847b014b8c9ae5710c0be1907c~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;sink&#34;&gt;Sink&lt;/h3&gt;
&lt;p&gt;直译为水槽，生活中水槽的作用无非&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开水龙头，知道有水要来&lt;/li&gt;
&lt;li&gt;水在水槽里, 可以进行一些操作&lt;/li&gt;
&lt;li&gt;打开水闸，放水&lt;br&gt;
Java中的Sink核心功能为：&lt;/li&gt;
&lt;li&gt;begin(): 告诉该水槽水流要来了，可以进行一些初始化操作&lt;/li&gt;
&lt;li&gt;accept()：接受水流，然后进行操作&lt;/li&gt;
&lt;li&gt;end()：水流全部处理完了。&lt;br&gt;
看一个sort()的示例,sort这个stage的目的就是对所有水流进行排序，然后再流到下游。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final class SizedRefSortingSink&amp;lt;T&amp;gt; extends AbstractRefSortingSink&amp;lt;T&amp;gt; {
        private T[] array;  //要进行排序，需要一个数组进行缓存
        private int offset; 

        SizedRefSortingSink(Sink&amp;lt;? super T&amp;gt; sink, Comparator&amp;lt;? super T&amp;gt; comparator) {
            super(sink, comparator);
        }

        @Override
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
        public void begin(long size) {
            if (size &amp;gt;= Nodes.MAX_ARRAY_SIZE)
                throw new IllegalArgumentException(Nodes.BAD_SIZE);
            //上游调用begin(),通知sort进行初始化操作，生产一个数组
            array = (T[]) new Object[(int) size];
        }

    	//上游调用end()方法，告诉sort水已经全部流过来了。sort开始执行操作
        @Override
        public void end() {
            //操作
            Arrays.sort(array, 0, offset, comparator);
            //告诉sort的下游准备接受水流
            downstream.begin(offset);
            //一个个元素的传递给下游
            if (!cancellationWasRequested) {
                for (int i = 0; i &amp;lt; offset; i++)
                    downstream.accept(array[i]);
            }
            else {
                for (int i = 0; i &amp;lt; offset &amp;amp;&amp;amp; !downstream.cancellationRequested(); i++)
                    downstream.accept(array[i]);
            }
            //告诉下游水流传递结束
            downstream.end();
            //缓存清空
            array = null;
        }

    	//上游调用accept()方法，将水流存储到到sort的缓存数组中
        @Override
        public void accept(T t) {
            array[offset++] = t;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;创建head&#34;&gt;创建Head&lt;/h2&gt;
&lt;h3 id=&#34;疑问&#34;&gt;疑问&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;官方说Stream不存储数据，那么数据保存在那里呢？&lt;br&gt;
解答在后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用方式&#34;&gt;使用方式&lt;/h3&gt;
&lt;p&gt;可以使用Stream.of()创建一个流，例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//创建方式 of()
Stream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;源码分析&#34;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;of()方法调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;StreamSupport.stream(Arrays.spliterator(arr, 0, arr.length), false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stream()方法逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(Spliterator&amp;lt;T&amp;gt; spliterator, boolean parallel) {
    Objects.requireNonNull(spliterator);
    return new ReferencePipeline.Head&amp;lt;&amp;gt;(spliterator,
                                        StreamOpFlag.fromCharacteristics(spliterator),
                                        parallel);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用了&lt;code&gt;ReferencePipeline.Head&amp;lt;&amp;gt;&lt;/code&gt;，返回一个Head对象。Head是ReferencePipeline的子类。可以理解为Head是流水线的第一个stage。&lt;br&gt;
构造方法的主要了逻辑要一直super()到&lt;code&gt;AbstractPipeline&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * The source spliterator. Only valid for the head pipeline.
     * Before the pipeline is consumed if non-null then {@code sourceSupplier}
     * must be null. After the pipeline is consumed if non-null then is set to
     * null.
     */
    private Spliterator&amp;lt;?&amp;gt; sourceSpliterator;

    /**
     * Constructor for the head of a stream pipeline.
     *
     * @param source {@code Spliterator} describing the stream source
     * @param sourceFlags the source flags for the stream source, described in
     * {@link StreamOpFlag}
     * @param parallel {@code true} if the pipeline is parallel
     */
    AbstractPipeline(Spliterator&amp;lt;?&amp;gt; source,
                     int sourceFlags, boolean parallel) {
        this.previousStage = null;
        //使用一个字段指向数据集合的Spliterator,后续终结操作的时候，引用的方式操作数据
        this.sourceSpliterator = source;
        this.sourceStage = this;
        this.sourceOrOpFlags = sourceFlags &amp;amp; StreamOpFlag.STREAM_MASK;
        // The following is an optimization of:
        // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);
        this.combinedFlags = (~(sourceOrOpFlags &amp;lt;&amp;lt; 1)) &amp;amp; StreamOpFlag.INITIAL_OPS_VALUE;
        this.depth = 0;
        this.parallel = parallel;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6bb4ba6d9042e3a1f6b4547b68edec~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;疑问解答&#34;&gt;疑问解答&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;官方说Stream不存储数据，那么数据保存在那里呢？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Head中保存数据源的Spliterator对象，后续操作Spliterator的方式操作数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考引用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://colobu.com/2014/11/18/Java-8-Stream/&#34;&gt;Java 8 Stream探秘 (colobu.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">深入解析Java Stream源码（上）：初始化 Sink</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/nL7teffDj/"" data-c="
          &lt;p&gt;Java里泛型，与c#比起来，更算是一种语法糖。关于语法糖，是编译时的一种“小把戏”，目的是让使用者可以有更多的手段是编写代码。&lt;br&gt;
好处是效率，了解Rust的可以感受到，编写Rust的代码极其高效的，代价就是学习成本非常高，原因之一就是大量的语法糖。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在java 中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void foo(Person&amp;lt;String&amp;gt; p){}

public void foo(Person&amp;lt;Long&amp;gt; p){}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b95e4b789e245b581f3159d90c25eec~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;泛型擦除-字节码分析&#34;&gt;泛型擦除-字节码分析&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void foo(Person&amp;lt;String&amp;gt; p){}  ==&amp;gt; public void foo(Person&amp;lt;Object&amp;gt; p){}

public void foo(Person&amp;lt;Long&amp;gt; p){} ==&amp;gt; public void foo(Person&amp;lt;Object&amp;gt; p){}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面这个类&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person&amp;lt;T&amp;gt;{

    T name;

    public static void main(String[] args) {
        Person&amp;lt;String&amp;gt; p = new Person&amp;lt;String&amp;gt;();
        p.name = &amp;quot;张三&amp;quot;;
        GvmOut.to(p.name);
    }

    public void foo(T t){}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/356e67eb94044e85bc0270e8dbd05805~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498461b0cf404349baaf98ca47e5f2c7~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;字段的签名和方法的签名都是Object对象，那为什么还需要范型，直接用Object声明不就好了吗。答案是约束，使用泛型可以保证类型符合要求。&lt;/p&gt;
&lt;p&gt;在字节码指令中，会添加checkcast命令去检查类型是否匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2ceac67b4b4b8e98e3725639bbca97~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d997841902ca4fb9b4c1473a45265c7b~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;泛型上下边界-字节码分析&#34;&gt;泛型上下边界-字节码分析&lt;/h3&gt;
&lt;p&gt;泛型常见的场景之一是使用extends，可以约束参数的范围。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Son&amp;lt;T extends Person&amp;gt;{

    T father;

    public static void main(String[] args) {
        Son&amp;lt;Person&amp;gt; son = new Son&amp;lt;&amp;gt;();
        son.father = new Person();
    }

    public T name(T t){
        return t;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6005fb3ea7494860b1a9669d34bda1c5~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1e578969da44529d65f459c4baf301~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h2&gt;
&lt;p&gt;本质上，编译后，泛型依然被擦除了，但是不再是Object类，而是Person类。&lt;/p&gt;
&lt;h3 id=&#34;为什么选择这种方式实现范型&#34;&gt;为什么选择这种方式实现范型&lt;/h3&gt;
&lt;p&gt;向下兼容。向下兼容。向下兼容。&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;p&gt;-《虚拟机规范(SE8)》&lt;br&gt;
-《自己动手些虚拟机》&lt;/p&gt;
">从字节码剖析泛型</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/l7YU2lRvP/"" data-c="
          &lt;p&gt;在jvm中，定义了有205条指令，从0x00 -&amp;gt; 0xCA , 0xFE -&amp;gt; 0xFF。我们在方法中写的所有逻辑，最终都会转换成这些指令，而虚拟机的最重要的一个任务就是解释执行这些指令。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;jvm指令集&#34;&gt;JVM指令集&lt;/h1&gt;
&lt;p&gt;指令类型种类很多&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ebfd1be8ab947b1b8452e46405b1839~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比较常见的类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;load ： 数据从局部变量表 -&amp;gt; 操作数栈中&lt;/li&gt;
&lt;li&gt;store ： 数据从操作数栈 -&amp;gt; 局部变量表中&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;references : 方法调用、类型强转、monitor锁等&lt;/li&gt;
&lt;li&gt;math ：运算操作相关&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;comparisons : 逻辑操作，if，while，for，goto等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令格式&#34;&gt;指令格式&lt;/h3&gt;
&lt;p&gt;指令都是由两部分组成，&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;操作数。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作码：&lt;/strong&gt; 用于表示是什么指令. 0x1a , 0x45 ,0x57 是操作码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作数：&lt;/strong&gt; 有些指令需要操作局部变量表和操作数栈，需要知道索引的位置.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//匹配指令
switch opcode {
    ...
    case 0x1a:
		return iload_0
    ...
	case 0x45:
		return fstore_2
    ...
    case 0x57:
		return pop
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;超级指令&#34;&gt;超级指令&lt;/h3&gt;
&lt;p&gt;解释的速度通常比较慢，原因之一是解释器在判断指令类型的时候涉及到分支，cpu层面分支预测失败和指令缓存未命中的开销都很大。&lt;/p&gt;
&lt;p&gt;解决办法很容易想到，把两个或者多个代码合并成一个代码，在一趟处理中可以直接获取然后执行指令，这样就减少了分支的次数，这些指令便称为超级指令、快速指令、虚拟指令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
case 0x59:
	return dup
...
case 0x60:
	return iadd
...
case 0x84:
	return iinc
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dup: 指令表示将操作数栈顶的元素复制一份。&lt;/li&gt;
&lt;li&gt;iinc: 表示局部变量表+1，省略了经过操作数栈+1，然后再保存的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指令流获取&#34;&gt;指令流获取&lt;/h3&gt;
&lt;p&gt;在类加载过程-加载步骤。在字节码文件中，指令的数据保存在在methods的的属性表的code字段中。在类加载阶段，读取字节码文件时候会生成一份等价的对象，对象的构建就是从头到尾的把所有数据都进行读取，然后解析。每个不同组件都有不同的方法读取。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5bde907abd949a4a154053757390bf2~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 读取length长度的数据
func parseMethod(count uint16, reader *loader.ClassReader, pool *constant_pool.ConstantPool, k *Klass) Methods {
	methods := make([]*MethodKlass, count)
	for i := range methods {
		method := &amp;amp;MethodKlass{}
		//设置常量池
		method.ConstantPool = pool
		//设置访问标记
		method.accessFlag = reader.ReadUint16()
		//name常量池索引
		method.nameIdx = reader.ReadUint16()
		//描述符常量池索引
		method.descriptorIdx = reader.ReadUint16()
		//属性表数量
		method.attrCount = reader.ReadUint16()
		// 解析方法表中的属性表字段
		method.AttributesInfo = attribute.ParseAttributes(method.attrCount, reader, pool)
		// 绑定klass&amp;amp;method
		method.Klass = k
		// 本地方法注入字节码
		method.InjectCodeAttrIfNative()
	}
	return methods
}

func (c *AttrCode) parse(reader *loader.ClassReader) {
	c.MaxStack = reader.ReadUint16()
	c.MaxLocals = reader.ReadUint16()
	//code长度
	c.codeLen = reader.ReadUint32()
	//读取len长度的字节
	c.code = reader.ReadBytes(c.codeLen)
	c.ExceptionTable = parseExceptionTable(reader)
	c.attrCount = reader.ReadUint16()
	c.AttributesInfo = ParseAttributes(c.attrCount, reader, c.ConstantPool)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指令的解释过程&#34;&gt;指令的解释过程&lt;/h3&gt;
&lt;p&gt;指令的执行是由解释器负责的，解析器的流程简单说就是:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0e47eze27j211s03cq3e.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;指令解释就是将这三步重复循环，其中要注意的点是栈帧中的pc和整体pc寄存器的值要保持一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//循环解释
func loop(thread *runtime.Thread) {
    methodReader := &amp;amp;base.MethodCodeReader{}
        for {
        // 更新pc寄存器
        updatePC(thread)
        // 更新方法code
        updateCodeArrt(thread, methodReader)
        //执行指令
        execInst(thread, methodReader)
        if finished(thread) {
                break
        }
    }
}

//执行
func execInst(thread *runtime.Thread, reader *base.MethodCodeReader) {
    curFrame := thread.PeekFrame()
    //获取操作码
    opcode := reader.ReadOpenCdoe()
    //创建指令
    inst := instructions.NewInstruction(opcode)
    //获取操作数
    inst.FetchOperands(reader)
    curFrame.SetFramePC(reader.MethodReaderPC())
    //执行指令
    inst.Execute(curFrame)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;指令解释执行&#34;&gt;指令解释执行&lt;/h3&gt;
&lt;p&gt;获取到指令后，&lt;code&gt;inst.Execute(curFrame)&lt;/code&gt; 执行指令。每条指令都有各自的执行逻辑&lt;/p&gt;
&lt;p&gt;每条指令都有不同的执行逻辑。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func iload_0(frame *runtime.Frame) {
	val := frame.LocalVars().GetInt(0)
	frame.OperandStack().PushInt(val)
}

func iload_1(frame *runtime.Frame) {
	val := frame.LocalVars().GetInt(1)
	frame.OperandStack().PushInt(val)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;i-i&#34;&gt;i++ &amp;amp; ++i&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int i = 1;
print(i++);  
print(++i);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编译后字节码两者是不同的，原因与java编译器的遍历AST（javac采用逆波兰表达算法）有关。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/268c4ab96e09427194ff1d0ac6ff94d3~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i *IINC) Execute(frame *runtime.Frame) {
	idx := i.Index &amp;gt;&amp;gt; 8         //局部变量表下标
	toAdd := i.Index &amp;amp; 0x0011   //值
	old := frame.LocalVars().GetInt(uint(idx)) 
	frame.LocalVars().SetInt(uint(idx), int32(toAdd)+old) //设置新的值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;i++ ：先把i保存到了操作数栈，然后再对局部变量表的i+1。&lt;/p&gt;
&lt;p&gt;++i ：先对局部变量表的i+1，然后再把i保存到了操作数栈。&lt;/p&gt;
&lt;h4 id=&#34;ifelse关键字&#34;&gt;if..else..关键字&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;public static void if_test() {
    int n = 10;
    GvmOut.to(&amp;quot;testing if&amp;quot;);
    GvmOut.to(&amp;quot;10 &amp;gt; 9 ?&amp;quot;);
    if (n &amp;gt; 9) {
        GvmOut.to(&amp;quot;yes&amp;quot;);
    } else {
        GvmOut.to(&amp;quot;no&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5de568db80345d2ba675a334dc78683~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;for关键字&#34;&gt;for..关键字&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;public static void for_test() {
    GvmOut.to(&amp;quot;testing for&amp;quot;);
    for (int i = 0; i &amp;lt; 5; i++) {
        GvmOut.to(i);
	}
}
    
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b03ddacdcc42b2ac9061589646298b~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Execute to branch if and only if val1 great or equals val2
func (icmp *IfIcmpge) Execute(frame *runtime.Frame) {
	val2 := frame.PopInt()      //弹出栈顶的int
	val1 := frame.PopInt()      //弹出栈顶的int
	goNext := icmp.Index        //获取挑战地址
	if val1 &amp;gt;= val2 {           //比较
		base.Branch(frame, int(goNext))  
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;while&#34;&gt;while&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void while_test() {
    GvmOut.to(&amp;quot;testing while&amp;quot;);
    int x = 100;
    while (x &amp;lt; 105) {
        x++;
        GvmOut.to(x);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd42f104f9fd43079416b393a2624003~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">JVM 指令运行 解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/65lQ_SxQ1/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;项目代码：&lt;a href=&#34;https://github.com/zexho994/gvm&#34;&gt;https://github.com/zexho994/gvm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;虚拟机整体的流程&#34;&gt;虚拟机整体的流程&lt;/h2&gt;
&lt;h2 id=&#34;不同类型的虚拟机&#34;&gt;不同类型的虚拟机&lt;/h2&gt;
&lt;p&gt;从解释器的实现方式上来看，有两种类型的虚拟机执行架构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于栈结构&lt;/li&gt;
&lt;li&gt;基于寄存器&lt;br&gt;
jvm家族的虚拟机基本都是基于栈的，基于栈的实现稍微简单，移植性高。基于寄存器的虚拟机和cpu的执行方式类似，性能更快，例如v8。Lua虚拟机从5.0之前是栈虚拟机，5.0时转变为寄存器虚拟机&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Lars Bak 是v8的作者，也是hotspot的作者之一，还是Dart语言的作者。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;栈虚拟机&#34;&gt;栈虚拟机&lt;/h3&gt;
&lt;p&gt;一段java代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void foo(){
	int a = 1;  
    int b = 2;  
    int c = a*b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在不同类型的虚拟机中，要执行这段代码，首先编译的方式也会有不同,在基于栈的虚拟机中，编译后的指令为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void fooj();
    Code:
       0: iconst_1   //常量1存入到操作数栈
       1: istore_1   //操作数栈顶pop到局部变量表1
       2: iconst_2   
       3: istore_2
       4: iload_1    //局部变量表索引1数push到操作数栈
       5: iload_2    
       6: iadd       //操作数栈顶两个数相加
       7: iconst_5
       8: imul       //操作数栈顶两个数相乘
       9: istore_3
      10: return  
          
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dffe4e0c06c44ec1a3d74146ab023cd1~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;寄存器虚拟机&#34;&gt;寄存器虚拟机&lt;/h3&gt;
&lt;p&gt;和汇编的风格类似，因为cpu本质上也是一个基于寄存器的解释器。寄存器虚拟机最大的优点就是性能好，支持随机访问，相比起来栈虚拟机的指令执行就显得十分麻烦的。&lt;/p&gt;
&lt;p&gt;在基于寄存器的虚拟机中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add ax bx	//其中AX寄存器的值为1,BX寄存器的值为2，将结果放入AX
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c9bd9e740241a3b9e8154f39a15106~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;虚拟机类型的抉择&#34;&gt;虚拟机类型的抉择&lt;/h3&gt;
&lt;p&gt;为什么JVM选择了使用栈虚拟机的方式? 原因有很多，从历史的角度上看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈虚拟机中，指令的平台无关性好。&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;栈虚拟机的优点之一是指令更短，只用1字节，而基于寄存器的需要额外保存地址，一般为2字节。在当时，内存是比较重要的。&lt;/li&gt;
&lt;li&gt;James Gosling 对这种方式的实现比较熟悉（之前他实现了PostScript虚拟机）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对java的影响&#34;&gt;对Java的影响&lt;/h3&gt;
&lt;p&gt;指令重排序之一的编译器重排序，是IR优化阶段的一种手段，叫表达式提升、表达式下沉。&lt;/p&gt;
&lt;p&gt;优化的原因之一就是考虑栈的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a=1;         b=2;
b=2;         a=1;
c=a+1;  ==&amp;gt;  c=a+1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法执行&#34;&gt;方法执行&lt;/h2&gt;
&lt;h3 id=&#34;栈帧&#34;&gt;栈帧&lt;/h3&gt;
&lt;p&gt;栈帧是方法的执行单位，一个方法对应一个栈帧。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//栈帧
type Frame struct {
	framePC   uint
	nextFrame *Frame
	*LocalVars
	*OperandStack
	*klass.MethodKlass
	*Thread
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1478dbbbd6704bbe98da7eea1d55b726~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h3&gt;
&lt;h3 id=&#34;虚拟机栈&#34;&gt;虚拟机栈&lt;/h3&gt;
&lt;p&gt;虚拟机栈是线程私有的，用于存放栈帧。当一个方法准备执行时候，栈帧push进行，完成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//线程模型
type Thread struct {
    ...
	*Stack  //虚拟机栈,存放栈帧
    ...
}
//虚拟机栈
type Stack struct {
    ...
	// 栈最大大小
	maxSize uint
	// 当前栈的大小
	size uint
	// 顶层帧
	top *Frame
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-2&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edf832f25aed447c87e2fc26fd868add~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/h3&gt;
&lt;h3 id=&#34;局部变量表和操作数栈size&#34;&gt;局部变量表和操作数栈size&lt;/h3&gt;
&lt;p&gt;局部变量表和操作数栈的大小如何确定？在code属性表中，MaxStack表示栈的最大深度，MaxLocals表示局部变量表的最大深度。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc1b27cd5c64897ba2677d8cdaffe6f~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Attr_Code struct {
	NameIdx uint16
	name    string
	AttrLen uint32
	cp      constant_pool.ConstantPool
	// 方法的操作数栈在任何时间点的最大深度，在编译期就可以确定
	MaxStack uint16
	// 局部变量表大小，包括方法的参数
	MaxLocals uint16
	codeLen   uint32
	code      []byte
	// 异常表
	ExceptionTable []*ExceptionTable
	// 属性表
	attrCount uint16
	attrInfo  AttributesInfo
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个值的大小已经在编译期间确定，在字节码中保存，最后在类加载过程中，获取这两个字段。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (c *Attr_Code) parse(reader *classfile.ClassReader) {
	c.MaxStack = reader.ReadUint16()
	c.MaxLocals = reader.ReadUint16()
	c.codeLen = reader.ReadUint32()
	c.code = reader.ReadBytes(c.codeLen)
	c.ExceptionTable = parseExceptionTable(reader)
	c.attrCount = reader.ReadUint16()
	c.attrInfo = ParseAttributes(c.attrCount, reader, c.cp)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方法调用&#34;&gt;方法调用&lt;/h2&gt;
&lt;h3 id=&#34;invoke-指令簇&#34;&gt;Invoke 指令簇&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;invokeinterface : 调用接口方法&lt;/li&gt;
&lt;li&gt;invokespecial : 调用实例方法，（父类方法、私有方法、实例初始化方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;invokevirtual : 调用虚方法，会根据实例的类型进行分派&lt;/li&gt;
&lt;li&gt;invokestatic : 调用静态方法&lt;/li&gt;
&lt;/ul&gt;
&lt;!----&gt;
&lt;ul&gt;
&lt;li&gt;invokedynamic : 调用动态方法(java7新增，支持动态语言的方法调用)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用执行逻辑&#34;&gt;调用执行逻辑&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Invokevirtual {
    
    public static void main(String[] args) {
        Invokevirtual invokevirtual = new Invokevirtual();
        int res = invokevirtual.additive(1, 2);
        GvmOut.to(res);
    }

    public int additive(int x, int y) {
        int r = x + y;
        return r;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;java中函数调用如何实现？&lt;br&gt;
main方法的code指令流：&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9610b89aa564ef08ab23c577af54559~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;additive方法的code指令流：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c31c3e99e2c04fd2b774172edde8fd13~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91cbecea94264be485a5a7dc87f010df~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;静态绑定与动态绑定&#34;&gt;静态绑定与动态绑定&lt;/h2&gt;
&lt;p&gt;网上很多文章对于这两者的解释为重载是静态绑定（编译时多态），重写是动态绑定。其实不完全正确，重载也可能被子类重写的情况，一样需要在运行期间判断。&lt;/p&gt;
&lt;p&gt;准确地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。概括就是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;只在编译期间就可以知道具体要调用的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;指要到运行期间才能知道要调用的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在invoke命令中，invokestatic对应的为静态绑定（使用static修饰），invokevirtual、invokeinterface为动态绑定的。&lt;/p&gt;
&lt;p&gt;用代码进行说明就是&lt;/p&gt;
&lt;h4 id=&#34;invokestatic的逻辑&#34;&gt;invokestatic的逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i *INVOKE_STATIC) Execute(frame *runtime.Frame) {
	cp := frame.Method().CP()
	contantMethod := cp.GetConstantInfo(i.Index).(*constant_pool.ConstantMethod)
	className := contantMethod.ClassName()
	perm := jclass.GetPerm()
	class := perm.Space[className]
	if class == nil {
		class = jclass.ParseInstanceByClassName(className)
	}
	name, _type := contantMethod.NameAndDescriptor()
	methodInfo, err := class.FindStaticMethod(name, _type)        //获取目标方法
	if err != nil {
		panic(&amp;quot;[gvm]&amp;quot; + err.Error())
	}
	if !jclass.IsStatic(methodInfo.AccessFlag()) {
		panic(&amp;quot;[gvm] invoke static error&amp;quot;)
	}
	methodInfo.SetJClass(class)
	base.InvokeMethod(frame, methodInfo, true)
}

func (j JClass_Instance) FindStaticMethod(name, descriptor string) (*MethodInfo, error) {       // 在本类中获取
	for i := range j.Methods {
		methodInfo := j.Methods[i]
		if !IsStatic(methodInfo.accessFlag) {
			continue
		}
		mName := j.ConstantPool.GetUtf8(methodInfo.nameIdx)
		mDesc := j.ConstantPool.GetUtf8(methodInfo.descriptorIdx)
		if name != mName || mDesc != descriptor {
			continue
		}
		return j.Methods[i], nil
	}
	return nil, exception.GvmError{Msg: &amp;quot;not find static method it name &amp;quot; + name}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;invokevirtual的逻辑&#34;&gt;invokevirtual的逻辑&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i *INVOKE_VIRTUAL) Execute(frame *runtime.Frame) {
	constantMethod := frame.Method().CP().GetConstantInfo(i.Index).(*constant_pool.ConstantMethod)
	methodNameStr, methodDescStr := constantMethod.NameAndDescriptor()
	exception.AssertTrue(methodNameStr != &amp;quot;&amp;lt;init&amp;gt;&amp;quot; &amp;amp;&amp;amp; methodNameStr != &amp;quot;&amp;lt;clinit&amp;gt;&amp;quot;, &amp;quot;IncompatibleClassChangeError&amp;quot;)

	classNameStr := constantMethod.ClassName()
	permSpace := jclass.GetPerm().Space
	jc := permSpace[classNameStr]
	if jc == nil {
		jc = jclass.ParseInstanceByClassName(classNameStr)
	}
	exception.AssertTrue(jc != nil, &amp;quot;NullPointerException&amp;quot;)
    
    //*****查找目标实例方法*****
	methodInfo, err, _ := jc.FindMethod(methodNameStr, methodDescStr)     
	exception.AssertTrue(err == nil, &amp;quot;no find the method of &amp;quot;+methodNameStr)
	exception.AssertFalse(jclass.IsStatic(methodInfo.AccessFlag()), &amp;quot;IncompatibleClassChangeError&amp;quot;)

	if jclass.IsProteced(methodInfo.AccessFlag()) {
		// todo if is proteced , need to judge the relation between caller and called
	}

	base.InvokeMethod(frame, methodInfo, false)
}


func (j *JClass_Instance) FindMethod(name, descriptor string) (*MethodInfo, error, *JClass_Instance) {
	for i := range j.Methods {
		methodInfo := j.Methods[i]
		if IsStatic(methodInfo.accessFlag) {
			continue
		}
		mName := j.ConstantPool.GetUtf8(methodInfo.nameIdx)
		mDesc := j.ConstantPool.GetUtf8(methodInfo.descriptorIdx)
		if mName == name &amp;amp;&amp;amp; mDesc == descriptor {
			return j.Methods[i], nil, j
		}
	}
	// 在父类中遍历查找
	m, err, jc := j.SuperClass.FindMethod(name, descriptor)
	if err == nil {
		return m, nil, jc
	}
	// 在接口中遍历查找
	for i := range j.Interfaces {
		m, err, jc := j.Interfaces[i].FindMethod(name, descriptor)
		if err == nil {
			return m, nil, jc
		}
	}
	return nil, exception.GvmError{Msg: &amp;quot;not find method it name &amp;quot; + name}, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jni方法简述&#34;&gt;JNI方法简述&lt;/h2&gt;
&lt;p&gt;有一些场景中，java本身没有能力去完成，最常见的就是当要系统调用时候,就要使用JNI（Java Native Interface）这种方式。&lt;/p&gt;
&lt;p&gt;例如nio中的Selector&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private native int poll0(long var1, int var3, long var4);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;unsafe.cas&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式本质上也是调用另一个地方的函数，链接的工作由虚拟机完成。GvmOut是invoke调用时基于Go的Print方法实现，使用native方法可以进行非常多的扩展操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GvmOut{
    public native static void to(int i);
    public native static void to(float i);
    public native static void to(double i);
    public native static void to(boolean i);
    public native static void to(long i);
    public native static void to(String i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/35777031&#34;&gt;栈式虚拟机和寄存器式虚拟机？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.iteye.com/blog/rednaxelafx-492667&#34;&gt;虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 - Script Ahead, Code Behind - ITeye博客&lt;/a&gt;&lt;br&gt;
-《虚拟机规范(SE8)》&lt;br&gt;
-《自己动手些虚拟机》&lt;/li&gt;
&lt;/ul&gt;
">JVM 方法调用与执行</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/ioc_2/"" data-c="
          &lt;p&gt;github地址：https://github.com/zexho994/IOC-AOP&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;核心实现&#34;&gt;核心实现&lt;/h1&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba70855125c48d280678e5d1538979d~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;bean的声明&#34;&gt;Bean的声明&lt;/h3&gt;
&lt;p&gt;以注解的方式为例，在类上添加@Bean注解即表示该Class为一个Bean，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public class BeanTest1 implements BeanTest {

    @Override
    public void print() {
        System.out.println(&amp;quot;BeanTest1&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在项目启动的时候会扫描目录下所有的Class，流程如下:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/585f5fd3ead84ba491753ffa4276d292~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; findAllBean() {
    ClassLoader contextClassLoader = getDefaultClassLoader();  //获取默认类加载器
    List&amp;lt;String&amp;gt; classes = scanClasses(contextClassLoader);    //扫描所有Class类
    return filtersAndLoadBeans(classes, contextClassLoader);   //过滤，获取所有Bean
}

public void loadBean() {
    BeanScanner
        .findAllBean()
        .forEach(bean -&amp;gt; AnnotationDefinitionLoaderRegistry.
                 this.register(bean.getSimpleName(), bean));  //注册所有的bean
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的的代码细节不详细展开，需要的可以看源码。&lt;/p&gt;
&lt;p&gt;到此，所有的Bean都已经保存到了map结构中，当需要使用Bean的时候根据bean name进行获取就好了。&lt;/p&gt;
&lt;h3 id=&#34;autowired实现&#34;&gt;@Autowired实现&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d52d41f1d9d4b7fa7da3e63563931e7~tplv-k3u1fbpfcp-watermark.image&#34; alt=&#34;image.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public class AutowiredTest {

    @Autowired
    public BeanTest1 beanTest1;
    @Autowired
    public BeanTest2 beanTest2;

    public void print1() {
        beanTest1.print();
    }

    public void print2() {
        beanTest2.print();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 初始化bean
private void initBean(BeanDefinition beanDefinition) throws IllegalAccessException {
    Object instance = beanDefinition.getInstance();

    // 初始化Autowired
    this.initAutowire(instance);

    beanDefinition.setStatusInitialized();
}

/** 
* 设置bean里面的注入字段
*/
private void initAutowire(Object instance) throws IllegalAccessException {
    // 获取所有字段，如果有Autowired注解，获取该bean，然后赋值给字段
    for (Field field : instance.getClass().getFields()) {
        if (field.getDeclaredAnnotationsByType(Autowired.class).length == 0) {
            continue;
        }
        Class&amp;lt;?&amp;gt; fieldType = field.getType();
        Object bean = this.getBean(fieldType.getSimpleName());
        field.set(instance, bean);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;解决循环依赖&#34;&gt;解决循环依赖&lt;/h1&gt;
&lt;p&gt;在spring中使用“3级缓存”来解决循环依赖问题，不要纠结spring为何要使用3个map来实现，抛开实现的细节，从问题原因着手，这个问题其实使用很好理解。&lt;/p&gt;
&lt;h2 id=&#34;何为循环依赖&#34;&gt;何为循环依赖？&lt;/h2&gt;
&lt;p&gt;下面的A和B就互相依赖彼此，这样就会有一个问题，在创建A的时候需要创建B，但是创建B的时候又需要创建A，看起来像是一个先有鸡还是蛋的问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Bean
public class ClassA {
    @Autowired
    public ClassB ib;

}

@Bean
public class ClassB {
    @Autowired
    public ClassA ia;
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是要知道Bean的创建其实是分为多个步骤的，就好理解了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-mermaid&#34;&gt;graph LR
n0(start) --&amp;gt; n1(创建instance) --&amp;gt; n2(填充需要注入的fields字段) --&amp;gt; n3(end)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在创建完instance后，里面的字段其实都还是null的,例如已经创建ClassA实例a，和ClassB实例b，此时&lt;code&gt;a.ib = null&lt;/code&gt;和&lt;code&gt;b.ia = null&lt;/code&gt;. 然后赋值 &lt;code&gt;a.ib = b&lt;/code&gt; 和 &lt;code&gt;b.ia = a&lt;/code&gt;，这之后，a和b中的字段都赋值完了，且都是完整可用的对象了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Object getBean(String beanName) {
    BeanDefinition bean = this.getBeanInstance(beanName);
    if (!bean.isInit()) {
        try {
            this.initBean(bean);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    return bean.getInstance();
}

// 初始化bean
private void initBean(BeanDefinition beanDefinition) throws IllegalAccessException {
    Object instance = beanDefinition.getInstance(); // 获取bean的isntance
    beanDefinition.setStatusInitialized();  //设置为已初始化
    this.initAutowire(instance);
}

// 遍历所有字段，为有@Authwired注解的实现注入
private void initAutowire(Object instance) throws IllegalAccessException {
    Field[] fields = instance.getClass().getFields();
    for (Field field : fields) {
        if (field.getDeclaredAnnotationsByType(Autowired.class).length == 0) {
            continue;
        }
        Class&amp;lt;?&amp;gt; fieldType = field.getType();
        Object bean = this.getBean(fieldType.getSimpleName());
        field.set(instance, bean);  //field赋值
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一个比较好的类比，leetcode的一道算法题two sum &lt;a href=&#34;https://leetcode-cn.com/problems/two-sum/&#34;&gt;https://leetcode-cn.com/problems/two-sum/&lt;/a&gt;，其中一种题解就是遍历一边，存储所有值和索引到map中，然后遍历一次map，每次判断是否有要的数。&lt;/p&gt;
&lt;p&gt;这个也是，先讲instance存到map中，然后把map中instance的fields都进行填充，就可以了。&lt;/p&gt;
">参考Spring实现 IOC（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/ioc_1/"" data-c="
          &lt;h1 id=&#34;基本概念&#34;&gt;基本概念&lt;/h1&gt;
&lt;h3 id=&#34;控制反转和依赖注入&#34;&gt;控制反转和依赖注入&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;控制反转（IOC），依赖注入（DI）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是控制反转？简单的说，控制反转就是一种思想，目的是将对象的创建由主动变成被动。&lt;br&gt;
下面的实例就是主动new了一个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Service{
    public DependObject object1 = new DenpendObject();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如何做到不使用new呢？依赖注入便是其中一种实现方式。&lt;/p&gt;
&lt;p&gt;依赖注入的方式有三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造器注入&lt;/li&gt;
&lt;li&gt;setter注入&lt;/li&gt;
&lt;li&gt;接口注入&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Service{
    public DependObject object;

    // 构造器注入
    public Service (DependObject obj){
        this.object = obj;
    }

    // setter注入
    public void setDependObject(DependObject obj){
        this.object = obj;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，对象的生命周期不再由Service类中主动创建，而是通过注入的方式赋值。&lt;br&gt;
顺便比较一下3中方式的优劣：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接口注入：&lt;/strong&gt; 从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退 役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter 方法注入则不需要如此。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;构造方法注入：&lt;/strong&gt; 这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以 马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且 在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多 个构造方法，而参数数量的变动可能造成维护上的不便。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setter方法注入：&lt;/strong&gt; 因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外， setter方法可以被继承， 允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无 法在构造完成后马上进入就绪状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ioc容器&#34;&gt;IOC容器&lt;/h3&gt;
&lt;p&gt;为了所有对象的统一管理，需要有一个角色负责将这些相互依赖的对象绑定到一起，IOC容器就是这样一个角色。它的主要职责可以分为两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务对象的构建管理：例如如何加载类，管理类的生命周期等。&lt;/li&gt;
&lt;li&gt;业务对象间的依赖绑定：提供构建好的对象给业务方使用。&lt;br&gt;
总结就是创建和绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;IOC容器如何知道管理哪些对象呢？本系列将实现两种方式：1.使用编码申明，2. 使用注解@Bean声明，熟悉Spring的知道常用的还有XML的方式，这个可以自行实现。&lt;/p&gt;
&lt;p&gt;在Spring中，使用Bean的概念表示IOC管理的对象，在这里依然采用这种定义方式，下篇文章介绍IOC模块的结构设计。&lt;/p&gt;
&lt;h3 id=&#34;拓展阅读&#34;&gt;拓展阅读&lt;/h3&gt;
&lt;p&gt;对IOC的基本概念不熟悉的可以阅读：&lt;br&gt;
《spring揭密》2.1 IOC基本概念&lt;/p&gt;
&lt;h1 id=&#34;预期实现效果&#34;&gt;预期实现效果&lt;/h1&gt;
&lt;h2 id=&#34;bean的声明方式&#34;&gt;Bean的声明方式&lt;/h2&gt;
&lt;h3 id=&#34;通过编码方式进行声明&#34;&gt;通过编码方式进行声明&lt;/h3&gt;
&lt;p&gt;继承CodeDefinitionLoderRegistry类，重写loadBean()方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyCodeBeanDefinition extends CodeDefinitionLoaderRegistry {

    @Override
    public void loadBean() {
        this.register(&amp;quot;BeanTest1&amp;quot;, BeanTest1.class);
        this.register(&amp;quot;BeanTest2&amp;quot;, BeanTest2.class);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后编码使用register(bean的名称，bean所对应类)进行注册，和XML的声明方式是类似的。&lt;/p&gt;
&lt;h3 id=&#34;通过注解bean的方式声明&#34;&gt;通过注解@Bean的方式声明&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public class BeanTest1 implements BeanTest {

    @Override
    public void print() {
        System.out.println(&amp;quot;BeanTest1&amp;quot;);
    }

}

@Bean
public class BeanTest2 implements BeanTest {

    @Override
    public void print() {
        System.out.println(&amp;quot;BeanTest2&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;获取bean&#34;&gt;获取Bean&lt;/h2&gt;
&lt;h3 id=&#34;从工厂中获取bean&#34;&gt;从工厂中获取Bean&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void foo() {

    // 第一步：c根据声明的方式选择 1 or 2
    // 方式一： 创建注册类,注册类中使用编码实现注册逻辑
    AbstractDefinitionLoaderRegistry registry = new MyCodeBeanDefinition();
    // 方式二： 创建注册类,Bean通过注解的方式自动注入
    AbstractDefinitionLoaderRegistry registry = new AnnotationDefinitionLoaderRegistry();
    
    // 第二步：注册类添加到工厂中
    ApplicationContext factory = new ApplicationContext(registry);

    // 第三步：获取Bean
    BeanTest obj1 = factory.getBeanInstance(&amp;quot;BeanTest1&amp;quot;, BeanTest1.class);
    BeanTest obj2 = factory.getBeanInstance(&amp;quot;BeanTest2&amp;quot;, BeanTest2.class);
    
    obj1.print();
    obj2.print();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;通过注解自动注入bean&#34;&gt;通过注解自动注入Bean&lt;/h3&gt;
&lt;p&gt;使用@Autowired自动注入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public class AutowiredTest {

    @Autowired
    public BeanTest1 beanTest1;
    @Autowired
    public BeanTest2 beanTest2;

    public void print1() {
        beanTest1.print();
    }

    public void print2() {
        beanTest2.print();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;项目组织结构&#34;&gt;项目组织结构&lt;/h1&gt;
&lt;h2 id=&#34;spring中的ioc设计&#34;&gt;Spring中的IOC设计&lt;/h2&gt;
&lt;p&gt;spring中ioc模块可以分为3中角色，分别对应3个最顶层接口：&lt;br&gt;
&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c03834b5a348a18794a7ee8aed7546~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;通俗的理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeanDefinition: 就是我们常说的Bean，理解为图书。&lt;/li&gt;
&lt;li&gt;BeanDefinitionRegistry: 书架，存放书的地方。&lt;/li&gt;
&lt;li&gt;BeanFactory: 图书馆，借书的地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我们的实现中，同样使用了这3个概念，看下3个接口都有哪些方法：&lt;/p&gt;
&lt;h3 id=&#34;beandefinition&#34;&gt;BeanDefinition&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanDefinition {
    // 0表示未初始化
    int STATUS_UNINITIALIZED = 0;
    // 1表示已初始化
    int STATUS_INITIALIZED = 1;

    /**
     * Sets name.
     *
     * @param beanClassName the bean class name
     */
    void setName(String beanClassName);

    /**
     * Gets name.
     *
     * @return the name
     */
    String getName();

    /**
     * Sets instance.
     *
     * @param instance the instance
     */
    void setInstance(Object instance);

    /**
     * Gets instance.
     *
     * @return the instance
     */
    Object getInstance();

    /**
     * Gets bean class.
     *
     * @return bean class
     */
    Class&amp;lt;?&amp;gt; getBeanClass();

    /**
     * 判断bean是否有初始化
     *
     * @return status == {@link #STATUS_INITIALIZED} ?
     */
    Boolean isInit();

    /**
     * set status to {@link #STATUS_INITIALIZED}
     */
    void setStatusInitialized();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;beandefinitionregistry&#34;&gt;BeanDefinitionRegistry&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanDefinitionRegistry {

    /**
     * 注册一个新的Bean
     *
     * @param beanName       bean的注册使用名称
     * @param beanDefinition bean的类型
     */
    void registerBean(String beanName, BeanDefinition beanDefinition);

    /**
     * 移除一个Bean
     *
     * @param beanName 要移除的Bean的名称
     */
    void removeBean(String beanName);

    /**
     * 根据名称获取Bean
     *
     * @param beanName bean名称
     * @return 已注册的 {@link BeanDefinition} 对象
     */
    BeanDefinition getBean(String beanName);

    /**
     * 获取Bean
     * {@link BeanDefinition}
     *
     * @param beanName     bean名称
     * @param requiredType bean类型，会进行校验
     * @return 已注册的 {@link BeanDefinition} 对象
     */
    &amp;lt;T&amp;gt; BeanDefinition getBean(String beanName, Class&amp;lt;T&amp;gt; requiredType);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;beanfactory&#34;&gt;BeanFactory&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BeanFactory {

    /**
     * 根据名称获取bean
     *
     * @param beanName bean名称
     * @return bean名称对应的Bean
     */
    BeanDefinition getBeanInstance(String beanName);

    /**
     * 根据名称获取一个bean
     *
     * @param beanName     bean的名称
     * @param requiredType bean类型
     * @return bean名称对应的Bean
     */
    &amp;lt;T&amp;gt; T getBeanInstance(String beanName, Class&amp;lt;T&amp;gt; requiredType);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;我们的ioc类图&#34;&gt;我们的IOC类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a49e7bfb13849aeb2e2c96eccd438cb~tplv-k3u1fbpfcp-zoom-1.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
对3个顶层接口都添加了默认实现类，其中比较重要的几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeanDefinitionRegistry 使用Map进行Bean的存储，Key为Bean的名称，Val为BeanDefinition&lt;/li&gt;
&lt;li&gt;BeanDefinition中有3个字段&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String beanName;  //bean名称
private T beanInstance = null; // bean的实例
private final Class&amp;lt;T&amp;gt; beanClass; //bean对应的class
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;BeanFactory中存储BeanDefinitionRegistry类，封装获取bean的接口，工厂对外提供&lt;/li&gt;
&lt;/ul&gt;
">参考Spring实现 IOC（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/u5bZtrIU8/"" data-c="
          &lt;ol&gt;
&lt;li&gt;找到License.class&lt;br&gt;
在words的jar包中找到License类.验证方法入口在这里&lt;br&gt;
虽然有两个setLicense（）方法，细心点看，最后调用的都是zzV方法，只是不同的重载。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class License {
    private zz2B zzYIM = zz2B.zzoF();

    public License() {
    }

    public void setLicense(String licenseName) throws Exception {
        if (licenseName == null) {
            throw new NullPointerException(this.zzYIM.zzZu(new byte[]{108, 105, 99, 101, 110, 115, 101, 78, 97, 109, 101}));
        } else {
            (new zzZJ5()).zzV(licenseName, zzZY2.zzkc());
        }
    }

    public void setLicense(InputStream stream) throws Exception {
        if (stream == null) {
            throw new NullPointerException(this.zzYIM.zzZu(new byte[]{115, 116, 114, 101, 97, 109}));
        } else {
            (new zzZJ5()).zzV(stream);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入zzV()方法&lt;br&gt;
在zzV()方法下面有两个方法，类似于下面这样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zzZaQ就是要修改的方法。让他始终返回1就好了&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static int zzZaQ() {
        boolean var0 = zzYIF == null || zzYIF.zzYIH == 0 || (new Date()).after(zzYIF.zzYII) || zzYNP.zzYlS() == 4096;
        boolean var1 = zzZE1.zzYZQ() == 0;
        int var2 = var0 &amp;amp;&amp;amp; var1 ? 0 : 1;
        return var2; // update , return 1
    }

    static int zzZaP() {
        boolean var0 = zzYIF == null || zzYIF.zzYIH == 0 || (new Date()).after(zzYIF.zzYII) || zzYNP.zzYlS() == 4096;
        boolean var1 = zzZE1.zzYZQ() == 0;
        int var2 = var0 &amp;amp;&amp;amp; var1 ? 0 : 1;
        return var2;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-利用javassist修改字节码&#34;&gt;2. 利用Javassist修改字节码&lt;/h2&gt;
&lt;h3 id=&#34;maven添加依赖&#34;&gt;Maven添加依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${javaassist.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
 
&amp;lt;properties&amp;gt;
    &amp;lt;javaassist.version&amp;gt;3.21.0-GA&amp;lt;/javaassist.version&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编写方法&#34;&gt;编写方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void removeWatermark() throws NotFoundException, CannotCompileException, IOException {
        ClassPool.getDefault().insertClassPath(&amp;quot;xxxx&amp;quot;); // jar包的绝对路径
        CtClass targetClass = ClassPool.getDefault().getCtClass(&amp;quot;com.aspose.words.zzZJ5&amp;quot;); //类路径
        CtMethod targetMethod = targetClass.getDeclaredMethod(&amp;quot;zzZaQ&amp;quot;); //方法路径
        targetMethod.setBody(&amp;quot;{return 1;}&amp;quot;); //修改方法体，始终返回1
        targetClass.writeFile(&amp;quot;/Users/zexho/Documents/&amp;quot;); //保存修改，内容为保存的路径。
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-更新jar包&#34;&gt;3. 更新Jar包&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将.jar包名后缀改为其他压缩格式。mac的改为tar，win可以改为zip&lt;/li&gt;
&lt;li&gt;解压tar,将新生成class文件替换旧的&lt;/li&gt;
&lt;li&gt;删除META-INF文件中的RSA和SF文件&lt;/li&gt;
&lt;li&gt;确保当前位置在一级目录中，看到这两个文件的位置。&lt;br&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlgy1gi3x36zscbj306403zdfo.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;重新打包Jar &lt;code&gt;jar cvf [新文件的名字.jar] .&lt;/code&gt;例如&lt;code&gt;jar cvf aspose-slides-20.5-jdk16.jar .&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-maven重新导入jar包&#34;&gt;4. Maven重新导入Jar包&lt;/h2&gt;
&lt;p&gt;在maven中导入该jar包。然后刷新就可以用了。&lt;br&gt;
&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlgy1gi3x5s3oxsj307n04bjre.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只能个人使用，不可商用&lt;/p&gt;
&lt;/blockquote&gt;
">反编译+字节码注入破解 Aspose Words 20.6</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/g8YKXeC-j/"" data-c="
          &lt;h2 id=&#34;java负数的计算过程&#34;&gt;Java负数的计算过程&lt;/h2&gt;
&lt;p&gt;java中最高位表示符号位,0表示正数，1表示负数&lt;/p&gt;
&lt;h3 id=&#34;根据十进制推算二进制&#34;&gt;根据十进制推算二进制&lt;/h3&gt;
&lt;p&gt;以-5为例子&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-5的原码：&lt;code&gt;1000 0101&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;求反码 : &lt;code&gt;1111 1010&lt;/code&gt; ，符号位不进行取反&lt;/li&gt;
&lt;li&gt;求补码（+1）：&lt;code&gt;1111 1011&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以-5用二进制表示为&lt;code&gt;1111 1011&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;根据二进制逆推十进制&#34;&gt;根据二进制逆推十进制&lt;/h3&gt;
&lt;p&gt;以&lt;code&gt;10001010&lt;/code&gt;为例子&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取补码,（-1操作）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10001010 - 1 = 10001001&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取反码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10001001&lt;/code&gt; 的反码 &lt;code&gt;11110110&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不看符号位，算出大小&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1110110&lt;/code&gt;  对应的值为 &lt;code&gt;118&lt;/code&gt;，所以10001010的值就是-118&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看出来，对于负数而言，因为&lt;code&gt;1000 0000&lt;/code&gt; 后七位因为要取反，所以后七位越大反而绝对值越小，例如&lt;code&gt;1111 1111&lt;/code&gt; 等于-1，而&lt;code&gt;1111 1110&lt;/code&gt; 等于-2&lt;/p&gt;
&lt;p&gt;那么对于负数而言 &lt;code&gt;1000 0000&lt;/code&gt; 就是绝对值最大，相对值最小的了，等于-128&lt;/p&gt;
&lt;h2 id=&#34;为什么要这样设计&#34;&gt;为什么要这样设计&lt;/h2&gt;
&lt;p&gt;首先在计算机中减法实际上是加法，2-1 == 2 + (-1)，那么进行推理一下&lt;/p&gt;
&lt;h3 id=&#34;如果都用原码&#34;&gt;如果都用原码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 的原码：&lt;code&gt;0000 0010&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-1&lt;/code&gt; 的原码: &lt;code&gt;1000 0001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2 + (-1)&lt;/code&gt;= &lt;code&gt;10000 0011&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;答案是是 -3，答案错误&lt;/p&gt;
&lt;h3 id=&#34;如果正数用原码负数用补码&#34;&gt;如果正数用原码，负数用补码&lt;/h3&gt;
&lt;p&gt;事例1&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2&lt;/code&gt;原码:&lt;code&gt;0000 0010&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-1&lt;/code&gt;补码: &lt;code&gt;1111 1111&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相加 =&lt;code&gt;0000 0001&lt;/code&gt; ，就等于1&lt;/p&gt;
&lt;p&gt;事例2&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10&lt;/code&gt;原码:&lt;code&gt;0000 1010&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-20&lt;/code&gt;补码: &lt;code&gt;1110 1100&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10 + (-20)&lt;/code&gt; =  &lt;code&gt;1111 0110&lt;/code&gt; 等于-10&lt;/p&gt;
&lt;h3 id=&#34;为什么要用补码表示负数而不是反码&#34;&gt;为什么要用补码表示负数，而不是反码&lt;/h3&gt;
&lt;p&gt;或者换个说法，为什么要进行+1操作&lt;/p&gt;
&lt;p&gt;如果不用补码,而用反码&lt;/p&gt;
&lt;p&gt;1的原码: &lt;code&gt;0000 0001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-1的反码:&lt;code&gt;1111 1110&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1 + (-1) = &lt;code&gt;1111 1111&lt;/code&gt; = -128&lt;/p&gt;
&lt;p&gt;很明显答案错误&lt;/p&gt;
&lt;p&gt;那么为什么要进行+1操作，如果你对&lt;code&gt;1111 11111&lt;/code&gt; +1可以发现 = &lt;code&gt;0001 0000 0000&lt;/code&gt;，而因为byte的大小只有8位，第9位要舍弃也就是&lt;code&gt;0000 0000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为负数最高位存在一个1，也就是说负数天然要比正数多一个1，对于正数而言，你就得额外+1才能保证正数和负数是一样大的。&lt;/p&gt;
&lt;h2 id=&#34;关于byte取值范围&#34;&gt;关于byte取值范围&lt;/h2&gt;
&lt;p&gt;byte的取值范围为&lt;code&gt;-128 ~ 127&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为什么负值要大于正值？&lt;/p&gt;
&lt;p&gt;对于最大值很容易得出：&lt;code&gt;0111 1111&lt;/code&gt; 就等于127&lt;/p&gt;
&lt;p&gt;但是负数不同，在&lt;code&gt;1000 0000&lt;/code&gt;这个特殊情况下符号位是参与运算的，也就是说，&lt;code&gt;1000 0000&lt;/code&gt; 是最小值，转化成十进制就是-128了&lt;/p&gt;
&lt;h2 id=&#34;java代码测试&#34;&gt;Java代码测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) {
        byte x1 = (byte)0b00000010;
        byte x2 = (byte)0b11111111;

        System.out.println(&amp;quot;x1 = &amp;quot; + x1);
        System.out.println(&amp;quot;x2 = &amp;quot; + x2);
        System.out.println(&amp;quot;x1 + x2 = &amp;quot; +  (x1 + x2));

        byte x3 = (byte)0b11111110;
        System.out.println(&amp;quot;x3 = &amp;quot; + x3);

        byte negative20 = (byte)0b11101100;
        System.out.println(&amp;quot;negative20 : &amp;quot; + negative20);

        byte negative10 = (byte)0b11110110;
        System.out.println(&amp;quot;negative10:&amp;quot;+negative10);

    }
&lt;/code&gt;&lt;/pre&gt;
">Java中二进制的补码，反码，正负数</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/docker_1/"" data-c="
          &lt;h2 id=&#34;1-在-docker-hub-下查看-neo4j-镜像&#34;&gt;1. 在 docker hub 下查看 neo4j 镜像&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker search neo4j
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf6017aa71~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200215164627841&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-拉取-neo4j-镜像&#34;&gt;2. 拉取 neo4j 镜像&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull neo4j
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拉取完成后输入命令可以看到镜像已经存在&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf6284ad96~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200215164707134&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-启动-neo4j-镜像&#34;&gt;3. 启动 neo4j 镜像&lt;/h2&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;docker run \
    --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/neo4j/data:/data \
    --rm -d neo4j
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480f43959d204~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200215164756361&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;​	&lt;em&gt;参数说明：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;publish&lt;/strong&gt;: 配置本机与容器之间的映射端口,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;volume&lt;/strong&gt;:配置共享的宗卷，用于数据持久化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-启动-neo4j-自带的前端页面&#34;&gt;4. 启动 neo4j 自带的前端页面&lt;/h2&gt;
&lt;p&gt;在浏览器中输入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;http://localhost:7474/browser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到,这里的端口是7474,是我们 run 命令里面设置的.还有一个端口7687用来连接数据库&lt;/p&gt;
&lt;h2 id=&#34;5-连接neo4j&#34;&gt;5. 连接neo4j&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf628a5e65~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200215165022204&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;账号密码默认都是 neo4j&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此就连接上了neo4j&lt;/strong&gt;&lt;/p&gt;
">Docker 中搭建 Neo4j 图数据库 </a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/git_1/"" data-c="
          &lt;p&gt;在刚开始学习git的时候，我很疑惑git可以同时管理这么多分支，而且切换分支都是瞬间完成。尽管Git官方推荐我们多使用分支去开发，但是天真的我很担心分支太多，导致文件数量会剧增，所以一直不敢使用太多分支。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;直到有一天想要去揭开心中的疑惑，git是怎么样管理这些不同分支的，最后发现和git里面的3个对象有关，搞懂3个对象的关系，相信在以后使用git命令的时候，头脑里会自然而然的浮现这些对象的关系网图&lt;/p&gt;
&lt;p&gt;在命令行中，可以使用 &lt;code&gt;git cat-file -p &amp;lt;object id&amp;gt;&lt;/code&gt;去查看每个对象里面的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Commit对象&lt;/p&gt;
&lt;p&gt;由3部分组成，parent存储父commit对象的ID，每一个commit对象都一个ID，使用&lt;code&gt;git log&lt;/code&gt;可以查看。Tree部分存储一个Tree对象的ID，下面部分存储的就是&lt;code&gt;git commit -m &amp;quot;xxx&amp;quot;&lt;/code&gt;里面的注释内容了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b6f68a02e~tplv-t2oaga2asx-imageimage-altimage-20200112200749581-stylezoom50&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b6f68a02e~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200112200749581&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;Tree 对象&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;可以把Tree对象理解为一个文件夹，每一个commit对象对应一个Tree，可以把这个Tree当作根目录。这个Tree里面存储了根目录下的子Tree的ID，以及BlobId。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;mark&gt;Blob 对象&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;一个Tree对应一个文件夹，Blob对应的是文件，Blog里面存储的也真的是文件的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;举个&#34;&gt;举个🌰&lt;/h4&gt;
&lt;h6 id=&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7661d997~tplv-t2oaga2asx-imageimage-altimage-20200112202046245-stylezoom50&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7661d997~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200112202046245&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/h6&gt;
&lt;p&gt;git的根目录是Java，Java文件夹里有一个test.class文件和一个JDK文件夹，JDK文件夹下面还有一个java8.class文件，那么我们第一次&lt;code&gt;git commit&lt;/code&gt;后的关系图就是这样&lt;/p&gt;
&lt;h6 id=&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b78581bba~tplv-t2oaga2asx-imageimage-altimage-20200112202700139-stylezoom-25&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b78581bba~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200112202700139&#34; style=&#34;zoom: 25%;&#34; /&gt;&lt;/h6&gt;
&lt;p&gt;此时我们修改了test.class文件的内容后，重新&lt;code&gt;git add test.class&lt;/code&gt;再&lt;code&gt;git commit -m&#39;update&#39;&lt;/code&gt;，这时候就会产生一个新的commit对象，结构就像这样:&lt;/p&gt;
&lt;h6 id=&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7b5e4a69~tplv-t2oaga2asx-imageimage-altimage-20200112203735217-stylezoom25&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7b5e4a69~tplv-t2oaga2asx-image.image&#34; alt=&#34;image-20200112203735217&#34; style=&#34;zoom:25%;&#34; /&gt;&lt;/h6&gt;
&lt;p&gt;发现只是保存了一个新的test.class的快照，java8.class没有发生改变，就没有生成生成新的快照。这样看来，真的是很节省磁盘了。&lt;/p&gt;
&lt;p&gt;git还有许许多多的使用场景，如果你能理解以上的关系，那么其他的情况下，都是一样的，不妨自己去命令行 &lt;code&gt;git cat-file -p &amp;lt;object id&amp;gt;&lt;/code&gt; 验证验证吧～&lt;/p&gt;
&lt;h3 id=&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b80651833~tplv-t2oaga2asx-imageimage-alt目录-stylezoom65-推荐阅读&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b80651833~tplv-t2oaga2asx-image.image&#34; alt=&#34;目录&#34; style=&#34;zoom:65%;&#34; /&gt;推荐阅读&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://ruby-china.org/topics/20723&#34;&gt;理解git对象&lt;/a&gt;&lt;/p&gt;
">Git 中指针与树的实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/Uh0rKjiE0/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;今天看到一篇文章，觉得不错。&lt;br&gt;
原文链接：https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434&lt;br&gt;
译文：https://www.jianshu.com/p/ab9aa8d4df7d&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;&#34;&gt;&lt;/h1&gt;
&lt;p&gt;最近我遇到了一个bug，我试着通过Rails在以“utf8”编码的MariaDB中保存一个UTF-8字符串，然后出现了一个离奇的错误：&lt;/p&gt;
&lt;p&gt;Incorrect string value:‘ð&amp;lt;…’for column ‘summary’ at row 1&lt;br&gt;
我用的是UTF-8编码的客户端，服务器也是UTF-8编码的，数据库也是，就连要保存的这个字符串“???? &amp;lt;…”也是合法的UTF-8。&lt;/p&gt;
&lt;p&gt;问题的症结在于，MySQL的“utf8”实际上不是真正的UTF-8。&lt;/p&gt;
&lt;p&gt;“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。&lt;/p&gt;
&lt;p&gt;MySQL一直没有修复这个bug，他们在2010年发布了一个叫作“utf8mb4”的字符集，绕过了这个问题。&lt;/p&gt;
&lt;p&gt;当然，他们并没有对新的字符集广而告之（可能是因为这个bug让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的。&lt;/p&gt;
&lt;p&gt;简单概括如下：&lt;/p&gt;
&lt;p&gt;1.MySQL的“utf8mb4”是真正的“UTF-8”。&lt;/p&gt;
&lt;p&gt;2.MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。&lt;/p&gt;
&lt;p&gt;我要在这里澄清一下：所有在使用“utf8”的MySQL和MariaDB用户都应该改用“utf8mb4”，永远都不要再使用“utf8”。&lt;/p&gt;
&lt;p&gt;那么什么是编码？什么是UTF-8？&lt;/p&gt;
&lt;p&gt;我们都知道，计算机使用0和1来存储文本。比如字符“C”被存成“01000011”，那么计算机在显示这个字符时需要经过两个步骤：&lt;/p&gt;
&lt;p&gt;1、计算机读取“01000011”，得到数字67，因为67被编码成“01000011”。&lt;/p&gt;
&lt;p&gt;2、计算机在Unicode字符集中查找67，找到了“C”。&lt;/p&gt;
&lt;p&gt;同样的：&lt;/p&gt;
&lt;p&gt;1、我的电脑将“C”映射成Unicode字符集中的67。&lt;/p&gt;
&lt;p&gt;2、我的电脑将67编码成“01000011”，并发送给Web服务器。&lt;/p&gt;
&lt;p&gt;几乎所有的网络应用都使用了Unicode字符集，因为没有理由使用其他字符集。&lt;/p&gt;
&lt;p&gt;Unicode字符集包含了上百万个字符。最简单的编码是UTF-32，每个字符使用32位。这样做最简单，因为一直以来，计算机将32位视为数字，而计算机最在行的就是处理数字。但问题是，这样太浪费空间了。&lt;/p&gt;
&lt;p&gt;UTF-8可以节省空间，在UTF-8中，字符“C”只需要8位，一些不常用的字符，比如“”需要32位。其他的字符可能使用16位或24位。一篇类似本文这样的文章，如果使用UTF-8编码，占用的空间只有UTF-32的四分之一左右。&lt;/p&gt;
&lt;p&gt;MySQL的“utf8”字符集与其他程序不兼容，它所谓的“”，可能真的是一坨……&lt;br&gt;
MySQL简史&lt;/p&gt;
&lt;p&gt;为什么MySQL开发者会让“utf8”失效？我们或许可以从提交日志中寻找答案。&lt;br&gt;
MySQL从4.1版本开始支持UTF-8，也就是2003年，而今天使用的UTF-8标准（RFC3629）是随后才出现的。&lt;/p&gt;
&lt;p&gt;旧版的UTF-8标准（RFC2279）最多支持每个字符6个字节。2002年3月28日，MySQL开发者在第一个MySQL4.1预览版中使用了RFC2279。&lt;/p&gt;
&lt;p&gt;同年9月，他们对MySQL源代码进行了一次调整：“UTF8现在最多只支持3个字节的序列”。&lt;br&gt;
是谁提交了这些代码？他为什么要这样做？这个问题不得而知。在迁移到Git后（MySQL最开始使用的是BitKeeper），MySQL代码库中的很多提交者的名字都丢失了。2003年9月的邮件列表中也找不到可以解释这一变更的线索。&lt;/p&gt;
&lt;p&gt;不过我可以试着猜测一下。&lt;/p&gt;
&lt;p&gt;2002年，MySQL做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么MySQL就可以在性能方面来一个大提升。为此，用户需要将文本列定义为“CHAR”，每个“CHAR”列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。&lt;/p&gt;
&lt;p&gt;MySQL开发者在最开始尝试UTF-8时使用了每个字符6个字节，CHAR(1)使用6个字节，CHAR(2)使用12个字节，并以此类推。&lt;/p&gt;
&lt;p&gt;应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解UTF-8的人都认同文档里写的东西。&lt;/p&gt;
&lt;p&gt;不过很显然，MySQL开发者或厂商担心会有用户做这两件事：&lt;/p&gt;
&lt;p&gt;1、使用CHAR定义列（在现在看来，CHAR已经是老古董了，但在那时，在MySQL中使用CHAR会更快，不过从2005年以后就不是这样子了）。&lt;/p&gt;
&lt;p&gt;2、将CHAR列的编码设置为“utf8”。&lt;/p&gt;
&lt;p&gt;我的猜测是MySQL开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了“utf8”编码。&lt;/p&gt;
&lt;p&gt;所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用“utf8”的CHAR列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用“utf8”编码时，却无法保存像“”这样的字符。&lt;/p&gt;
&lt;p&gt;在这个不合法的字符集发布了之后，MySQL就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL在2010年重新发布了“utf8mb4”来支持真正的UTF-8。&lt;/p&gt;
&lt;p&gt;为什么这件事情会让人如此抓狂？&lt;/p&gt;
&lt;p&gt;因为这个问题，我整整抓狂了一个礼拜。我被“utf8”愚弄了，花了很多时间才找到这个bug。但我一定不是唯一的一个，网络上几乎所有的文章都把“utf8”当成是真正的UTF-8。&lt;br&gt;
“utf8”只能算是个专有的字符集，它给我们带来了新问题，却一直没有得到解决。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;如果你在使用MySQL或MariaDB，不要用“utf8”编码，改用“utf8mb4”。这里（https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4）提供了一个指南用于将现有数据库的字符编码从“utf8”转成“utf8mb4”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编号3722，输入编号直达本文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入m获取文章目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;个人总结&#34;&gt;个人总结&lt;/h2&gt;
&lt;p&gt;对于作者说的不要再使用utf-8，本人不完全认同，完全可以在需要的时候才使用utf8mb4（毕竟utf-8更省空间）像微信小程序，编码的坑大家应该都踩过，可是除了这个外，似乎也没遇到过什么问题。所以了解这么一个问题后，以后完全可以按需要来确定使用何种编码。&lt;/p&gt;
">Mysql UTF-8 编码注意事项</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/wNJouB2lg/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;有一次我的项目中采用了前后端分离的模式，引起了跨域问题，本文将介绍我所采用的跨域解决方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先要了解产生跨域的本质，也就是同源策略的限制，源是指域名、端口号、协议，有一者不相同将被浏览器拒绝接受响应信息，（请求可以发送出去，但是浏览器不接受响应）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;解决方法&#34;&gt;解决方法：&lt;/h2&gt;
&lt;h3 id=&#34;1-jsonp&#34;&gt;1. jsonp&lt;/h3&gt;
&lt;p&gt;jsonp的原理的 src=&amp;quot;&amp;quot; 属性不受同源策略的限制，动态创建一个callback回调函数，服务器调用回调函数把数据放进去，具体的细节打算以后做一个专门讲解。&lt;/p&gt;
&lt;p&gt;这里给一个模版:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;            $.ajax({
             type: &amp;quot;get&amp;quot;,               //jsonp只能使用get
             async: false,
             url: &amp;quot;&amp;quot;
             dataType: &amp;quot;jsonp&amp;quot;,
             jsonp: &amp;quot;callback&amp;quot;,        
             jsonpCallback:&amp;quot;message&amp;quot;,       //注意这里给回调函数起的名字
                 success: function(json){
                 
                }
            })
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果这里你的回调函数起名为message，那么你在后端返回json的时候，也要注意在最外面包一层message{}。&lt;/p&gt;
&lt;p&gt;这里jsonp的缺点也可以明显的看出，只支持get请求，原因就是因为通过src=“”发送请求，所以可以知道是url传参。&lt;/p&gt;
&lt;p&gt;那么jsonp的好处是什么呢，兼容性，几乎所有浏览器都支持（包括一些版本比较老的），不需要XMLHttpRequest或ActiveX的支持。&lt;/p&gt;
&lt;h3 id=&#34;2-cors&#34;&gt;2. cors&lt;/h3&gt;
&lt;p&gt;又称跨域访问，浏览器将cors请求分为简单请求和非简单请求，因为本文主要讲解具体的方法，所以关于细节部分有兴趣可以去看其他博客或者我以后再做一篇具体的讲解（和jsonp一起）。在springboot中，官方已经提供了支持。直接贴代码：&lt;/p&gt;
&lt;h3 id=&#34;方式一全局定义&#34;&gt;方式一：全局定义&lt;/h3&gt;
&lt;p&gt;注意@Order这个注解，不加的话很大可能导致配置失效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Component
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public class CorsFilter implements Filter {
        @Override
        public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            HttpServletResponse response = (HttpServletResponse) res;
            HttpServletRequest request = (HttpServletRequest) req;
            response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);
            response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;);
            response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;,
                    &amp;quot;ACL, CANCELUPLOAD, CHECKIN, CHECKOUT, COPY, DELETE, GET, HEAD, LOCK, MKCALENDAR, MKCOL, MOVE, OPTIONS, POST, PROPFIND, PROPPATCH, PUT, REPORT, SEARCH, UNCHECKOUT, UNLOCK, UPDATE, VERSION-CONTROL&amp;quot;);
            response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;3600&amp;quot;);
            response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,
                    &amp;quot;Origin, X-Requested-With, Content-Type, Accept, x-userId&amp;quot;);

            if (&amp;quot;OPTIONS&amp;quot;.equalsIgnoreCase(request.getMethod())) {
                response.setStatus(HttpServletResponse.SC_OK);
            } else {
                chain.doFilter(req, res);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方式二局部定义&#34;&gt;方式二：局部定义&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        @CrossOrigin(origins = &amp;quot;*&amp;quot;,allowCredentials=&amp;quot;true&amp;quot;,allowedHeaders = &amp;quot;&amp;quot;,methods = {})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接在需要跨域的方法上添加注解,十分方便。也可以在类上使用该注解.&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结：&lt;/h2&gt;
&lt;p&gt;个人推荐使用cors，如果因为兼容性问题不得不使用jsonp那也没办法。然后如果是前后端分离的模式下，对于用户权限验证这一块也是一个需要注意点，如果使用cookie-session，跨域会导致后台获取不到session，我们可以利用token的方法来解决这个问题，我打算以后介绍一下jwt（Json web Token）来实现用户认证。&lt;/p&gt;
">SpringBoot 跨域 Jsonp 和 Cors</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/gei-xue-di-men-fen-xi-wireshark/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;前一阵子要给实验室的学弟们技术分享，当时收到建议给他们普及一些计算机网络的知识，可是关&lt;br&gt;
有理论知识讲课肯定不够吸引人，于是便一边学习Wireshark一边做PPT一边写讲稿。忙碌了两个星期后，分享会后还是得到了不错的的评价😁，我也在博客中总结下一些使用技巧，内容主要面向新手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;1-wireshark的用途&#34;&gt;1. WireShark的用途&lt;/h2&gt;
&lt;h3 id=&#34;用途一-学习网络知识提供实际操作&#34;&gt;用途一： 学习网络知识，提供实际操作&lt;/h3&gt;
&lt;p&gt;在我大二学习计算机网络的时候，老师上课只负责书本的讲解，导致我产生了计算机网络很无聊的错觉，所以那时候也没太认真的学习这门课程。但是后来当我自己边抓包边温习计网知识的时候，才发现是如此的有趣。而在抓包工具中，我使用过小花瓶（charles）和小鲨鱼（wireshark），我推荐小鲨鱼。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还有一款比较流行，叫fiddler，因为本人使用mac，fiddler未推出mac版，所以未接触过它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;用途二-获取网络资源信息&#34;&gt;用途二： 获取网络资源信息&lt;/h3&gt;
&lt;p&gt;通俗点讲就是抓包，wireshark可以抓的请求类型非常多，新手常见的像http、https（需要下载补丁）、tcp、udp、arp等等都可以。&lt;/p&gt;
&lt;h3 id=&#34;用途三进行网络状况分析&#34;&gt;用途三：进行网络状况分析&lt;/h3&gt;
&lt;p&gt;比如网络故障排查，因为本人也没利用wireshark分析过，所以就不误导大家了，不过我推荐一本书，也是我学习wireshark的一本书。&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b034e550e178ea~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
作者的风格真的很风趣，读起来就像小说一样，指不定哪个地方就会偷偷冒出一段笑话。&lt;/p&gt;
&lt;h2 id=&#34;2-抓包前的准备工作&#34;&gt;2. 抓包前的准备工作&lt;/h2&gt;
&lt;h3 id=&#34;1-修改着色规则&#34;&gt;1. 修改着色规则&lt;/h3&gt;
&lt;p&gt;我们第一次使用的适合，显示的界面可能像这样&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/14/16f04764d3d10a9f~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一片白的，对于我们快速分辨不同请求类型是有妨碍的，所以简单操作下：&lt;/p&gt;
&lt;h4 id=&#34;1-打开视图选项找到着色规则就像&#34;&gt;1）： 打开视图选项，找到着色规则，就像&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b03844f45a802a~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2-修改背景配色&#34;&gt;2）： 修改背景配色&lt;/h4&gt;
&lt;p&gt;我们根据自己的颜色偏好，设置不同的配色（想要搭配出一套养眼的配色真的是一件费力的事），我这里主要修改&lt;strong&gt;SYN报文&lt;/strong&gt;（&lt;strong&gt;绿色&lt;/strong&gt;）和&lt;strong&gt;FIN报文&lt;/strong&gt;（&lt;strong&gt;灰色&lt;/strong&gt;），配完后，就可以发现界面人性化许多，这下一眼就可以知道tcp握手和挥手的请求啦～&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b03873fb04efdf~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-只抓包头&#34;&gt;2. 只抓包头&lt;/h3&gt;
&lt;p&gt;众所周知，一个数据帧是由多个部分组成，对于我们所要获取的数据，我们也只要前面部分即可。单击菜单栏上的Capture--&amp;gt;Options，然后在弹出的窗口上定义“Limit each packet to”的值即可。一般可以设置一个偏大一点的数字：80字节，这样就可以只抓前80字节了。这样的话，TCP层、网络层和数据链路层的信息都可以包括在内了。我推荐设置200字节，这样可以获取到http、tcp、网络层协议的数据了。&lt;/p&gt;
&lt;!--![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b038b192f25302~tplv-t2oaga2asx-image.image)--&gt;
&lt;h3 id=&#34;3-认识下分层&#34;&gt;3. 认识下分层&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/14/16f047976a357b7f~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意：在这里网络层对应Ipv4，传输层对应tcp，应用层对应http。如果是udp，长这样⬇&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b0397dc455cff5~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-数据过滤技巧&#34;&gt;4. 数据过滤技巧&lt;/h3&gt;
&lt;p&gt;这也是比较重要的一个小技巧，会使用过滤器的话对于快速定位还是有很大帮助的，我这里列出一些比较常用的技巧，一通则百通。&lt;/p&gt;
&lt;h4 id=&#34;1协议过滤&#34;&gt;1）协议过滤&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b2a5642e35~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b40ea70225~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b515b268f2~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2-端口过滤&#34;&gt;2） 端口过滤&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b9b618a472~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039bab4fddc54~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039bbc3d5152a~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3ip过滤&#34;&gt;3）Ip过滤&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c72b129565~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c8a6e3c3ec~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c9eb316c96~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039d555376068~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4标识符过滤&#34;&gt;4）标识符过滤&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039db9dd136f4~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;5长度过滤&#34;&gt;5）长度过滤&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039df7abb24f7~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;先分享到这里，这几天在忙着写微信小程序，过几天通过wireshark分析下tcp3次握手和4次挥手来实战操作下～ 如果哪里有错误，还恳请大家指出。&lt;/p&gt;
">给学弟们分析 WireShark</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/hwe1uEAHe/"" data-c="
          &lt;p&gt;我们在写小程序的时候，手机端预览发现获取不到后台数据，只能用真机调试才可以，可是mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了。ps：我室友预览的时候一样可也以有数据。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;关键点&#34;&gt;关键点：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;手机，服务器，保持同一局域网。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;第一步开启局域网&#34;&gt;第一步：开启局域网&lt;/h2&gt;
&lt;h3 id=&#34;方法1使用电脑开启共享wifi手机连接此wifi-不过这里因为我们学校内部网需要账号登陆所以我没采用这种方法不过这种方法的后续流程和第二种方法差不多&#34;&gt;方法1）&lt;strong&gt;使用电脑开启共享wifi，手机连接此wifi&lt;/strong&gt;。不过这里因为我们学校内部网需要账号登陆，所以我没采用这种方法，不过这种方法的后续流程和第二种方法差不多。&lt;/h3&gt;
&lt;h3 id=&#34;方法2手机开启热点电脑连接此热点&#34;&gt;方法2）&lt;strong&gt;手机开启热点，电脑连接此热点&lt;/strong&gt;。&lt;/h3&gt;
&lt;h4 id=&#34;1连接后首先找到分配给电脑的ip-mac获取ip在设置-网络里面就可以看到&#34;&gt;1）连接后，首先找到分配给电脑的IP。mac获取IP在设置-&amp;gt;网络，里面就可以看到。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b071a3d75c0c24~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
或者在终端输入&lt;strong&gt;ifconfig&lt;/strong&gt;，可以找到&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b071e4ad724f4e~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第二步修改服务器地址&#34;&gt;第二步：修改服务器地址&lt;/h2&gt;
&lt;p&gt;我后台使用的SpringBoot，在properties里面直接修改&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b0720284e518d4~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;第三步修改url地址&#34;&gt;第三步：修改url地址：&lt;/h2&gt;
&lt;p&gt;之前使用的url地址类似于：&lt;strong&gt;http://localhost:8080/user/login/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改后服务器地址后同一修改为：&lt;strong&gt;http://172.20.10.2:8080/user/login/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重启后台，然后在postman测试一下：&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b07252a4316a41~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ok，可以获取到数据。&lt;br&gt;
然后我们把小程序里的request里的url全部使用这种方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b072a3158b4750~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
重新编译后，测试一下可不可以获取到数据，如果之前步骤没错，肯定没问题的。&lt;br&gt;
我们直接使用预览，也是一样可以获取到数据的。&lt;/p&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点：&lt;/h2&gt;
&lt;p&gt;1） 在后台修改了地址后，以后必须在热点环境下运行项目，不然会报错。（我就是有一次忘记连热点，结果一直启动失败，我还以为是8080端口占用问题）&lt;/p&gt;
&lt;p&gt;2）如果要别人预览你的小程序，得先连接你的热点，才能获取到数据。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结：&lt;/h2&gt;
&lt;p&gt;对了，如果你还有了网页，那么一样可以使用这种方法在手机上访问你的界面的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小程序截图：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b0739305696dd0~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网页手机截图：&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b073aa9f2958a9~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">微信小程序：预览页实现与后台通信</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://zexho994.github.io/blog.zexho.life/post/dU5Kti6_I/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;最近在学习微信小程序，遇到了一些坑，有些问题我看官网或者其他博客，可能讲的不是那么易懂，所以自己找到解决方法后，写下来供大家参考，如有不对指出，还恳请大家指出～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;p&gt;比如在实现购物车批量购买的时候，我们需要向后台请求一个list，包含所有勾选的物品信息，在微信小程序里，page里的data是这样定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        data {  
            orders：[]  
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我们给它赋值后，数据类似于&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc450f3dd4a23~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果我们利用wx.request把这个list发送的时候，根据微信官方文档的解释：&lt;/p&gt;
&lt;!--![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc476b45019b8~tplv-t2oaga2asx-image.image)--&gt;
&lt;p&gt;&lt;strong&gt;data 参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String 。转换规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 GET 方法的数据，会将数据转换成 query string（encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/li&gt;
&lt;li&gt;对于 POST 方法且 header[&#39;content-type&#39;] 为 application/json 的数据，会对数据进行 JSON 序列化&lt;/li&gt;
&lt;li&gt;对于 POST 方法且 header[&#39;content-type&#39;] 为 application/x-www-form-urlencoded 的数据，会将数据转换成 query string （encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html&#34;&gt;微信对于该部位解释官网文档地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;意思就是所有的data数据都会以String类型发送。所以很多朋友可能刚开始和我一样，请求总是错误，或者后台接收了请求，可是值却是null。许多博客给的方法比如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        header: {
        &#39;content-type&#39;: &#39;application/json&#39;
      },
      改为
      header: {
          &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;
        },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我尝试之后发现请求还是报错，下面给出我的解决方法：&lt;/p&gt;
&lt;h2 id=&#34;微信小程序&#34;&gt;微信小程序：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        wx.request({
          url: &#39;http://172.20.10.2:8080/order/wx/buy&#39;,
          header: {
               &#39;content-type&#39;: &#39;application/json&#39;
            },
          method: &amp;quot;POST&amp;quot;,
          data:{
            buyGoodsDTOS:this.data.orders,
            user_id:this.data.user_info.user_id
        },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;data里面有列表类型的orders，以及一个用户ID，&lt;br&gt;
我们就这直接这样发起请求，orders和user_id都会被序列化为json&lt;/p&gt;
&lt;h2 id=&#34;后台接收&#34;&gt;后台接收&lt;/h2&gt;
&lt;p&gt;利用阿里的&lt;strong&gt;fastjson&lt;/strong&gt;，我使用的&lt;strong&gt;SpringBoot&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;pomxml里添加&#34;&gt;pom.xml里添加：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.2.46&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;controller里面&#34;&gt;Controller里面：&lt;/h3&gt;
&lt;p&gt;利用&lt;strong&gt;fastjson&lt;/strong&gt;的&lt;strong&gt;JSONObject&lt;/strong&gt;接收wx序列化后的json数据&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc9d899d22dda~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过JSONObject类的源码，可以发现他实现类Map接口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public class JSONObject extends JSON implements Map&amp;lt;String, Object&amp;gt;,。。。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以知道，它是利用键值对存储微信小程序发送的json数据，存储方式类似于&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc685bf16f9d4~tplv-t2oaga2asx-image.image&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下划线部分为key，名称相同，value就是传过来的数据。&lt;br&gt;
对于里面jsonData里面orders数据（list）的获取：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        JSONArray jsonArray = jsonData.getJSONArray(&amp;quot;buyGoodsDTOS&amp;quot;);    //根据key名获取
        List&amp;lt;BuyGoodsDTO&amp;gt; list = jsonArray.toJavaList(BuyGoodsDTO.class); //将数组对象转化为list，BuyGoodsDTO是与orders里面对象要对应
        
        String user_id = jsonData.get(&amp;quot;user_id&amp;quot;).toString();    //获取user_id
        Integer id = Integer.parseInt(user_id);         //转化类型
```j
这样所有的数据都获取到啦～



&lt;/code&gt;&lt;/pre&gt;
">微信小程序：POST 传输 List 数据</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;最近在梳理我们系统架构的时候，想从分布式领域的角度来分析架构设计，但是由于之前没系统性接触过分布式相关的知识，正好借此机会来学习分布式相关的知识，并进行自己的总结。本文的目的是搞清楚什么是CAP。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;分布式系统的最大难点，就是各个节点的状态如何同步&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;历史背景\&#34;&gt;历史背景&lt;/h1&gt;\n&lt;p&gt;时间回到 1985 年，彼时，后来证明了 CAP 理论的 Lynch 教授此时给当时的 IT 界来了一记惊雷：她通过不可辩驳的证明告诉业界的工程师们，如果在一个不稳定（消息要么乱序要么丢了）的网络环境里（分布式异步模型），想始终保持数据一致是不可能的。这是个什么概念呢？就是她打破了那些既想提供超高质量服务，又想提供超高性能服务的技术人员的幻想。这本质是在告诉大家，在分布式系统里，需要妥协。&lt;br&gt;\n过了15年，在2000 年时，Eric Brewer 教授在 PODC 会议上提出了 CAP 理论，但是由于没有被证明过，所以，当时只能被称为 CAP 猜想。这个猜想引起了巨大的反响，因为 CAP 很符合人们对设计纲领的预期。在 2002 年后，经过 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP 猜想后，CAP 理论正式成为了分布式系统理论的基石之一。&lt;/p&gt;\n&lt;h1 id=\&#34;概念解释\&#34;&gt;概念解释&lt;/h1&gt;\n&lt;p&gt;要准确的理解CAP，首先必须明白CAP中3个概念的准确定义，3个概念分别对应CAP的3个缩写 Consistency、Availability、Partition Tolerance。&lt;br&gt;\n&lt;img src=\&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iegjbmz8j20u00u0gno.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;consistency-一致性\&#34;&gt;Consistency 一致性&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;all nodes see the same data at the same time&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;在服务节点进行更新操作后，所有节点同一时间的数据完全一致，也称数据一致性。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iegrn0bdj20lu0i00tb.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;在DB1更新完成后，步骤3的查询结果一定是最新的数据，那么步骤4的查询结果必须要和3一样，不然就是数据不一致。&lt;/p&gt;\n&lt;h2 id=\&#34;availability-可靠性\&#34;&gt;Availability 可靠性&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Reads and writes always succeed&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;在预期的响应时间内，必须返回结果（非异常的）。这里有两个概念，一个是预期响应时间，一个是非异常的结果。&lt;/p&gt;\n&lt;p&gt;预期响应时间应该是早在系统设计时就定义好的，要结合业务场景的考虑，例如我们google搜索要在0.5s内返回我们想要的结果，那么0.5就是定义好的结果，&lt;/p&gt;\n&lt;p&gt;一个文件转换的服务，预期响应时间可能会是数十秒甚至以分钟计算。只要能在预期响应时间内返回，都可以算作未超时的。&lt;/p&gt;\n&lt;p&gt;非异常的结果是指能被客户端接收并进行正常后续处理的，12306抢票时刷新后看到有票，点击购买又告知没票了，刷新后看到的是旧数据，但整个流程是没有发生异常，也可以说是可靠性。&lt;/p&gt;\n&lt;h2 id=\&#34;partition-tolerance-分区容错性\&#34;&gt;Partition Tolerance 分区容错性&lt;/h2&gt;\n&lt;p&gt;分布式场景下节点间都是通过网络进行通信的，网络肯定不是100%可靠的，也会有异常的时候。&lt;/p&gt;\n&lt;p&gt;当两个节点间发生了异常不能正常通信了，就可以说这两个节点之间发生&lt;strong&gt;分区&lt;/strong&gt;了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0iehceicrj20zq0muta5.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那么对于A服务而言，假设B发生异常了，A是否要容忍这种情况呢？选择不容忍，那么对应的措施就是A马上对外停止服务。这对于分布式系统来说绝对是不能接受的，所以我们必须容忍网络分区的发生，即使相关服务发生了异常，服务也不能停止运行。&lt;br&gt;\n这么看来CAP中P是必须要的，同时也知道CAP3这不能同时满足，现在的难题就是C和A中如何进行取舍&lt;/p&gt;\n&lt;h1 id=\&#34;为什么c和a不能同时存在\&#34;&gt;为什么C和A不能同时存在&lt;/h1&gt;\n&lt;p&gt;假如必须要满足一致性，那么数据中心只能有一个，这样所有的节点拿到的数据肯定都是最新的了。&lt;/p&gt;\n&lt;p&gt;那就会有一个问题，数据中心一旦发生网络分区，就导致所有节点无法处理请求，这样可靠性必然不能保证。&lt;/p&gt;\n&lt;p&gt;假如必须要满足可靠性，那么我们可以采用多数据中心的方式，这样即使个别节点发生网络分区，也不会导致整个服务不可用。可是这就有一个问题，最新的数据无法同步给其他分区的节点，就可能会导致数据不一下的可能。&lt;/p&gt;\n&lt;h1 id=\&#34;如何取舍c和a\&#34;&gt;如何取舍C和A&lt;/h1&gt;\n&lt;p&gt;在没有发生网络分区的时候，CAP三者都是满足的，只有当发生网络分区这种小概率事件的时候。&lt;br&gt;\n先看一些开源框架是如何进行设计的&lt;br&gt;\ncp - Zookeeper，Redis：当zookeeper和redis会保证数据的一致性，保证任何时候获取到的数据都是最新的。&lt;br&gt;\nca - Mysql，RocketMQ:  在Mysql和RocketMQ的主从架构中，当主从之间发生网络分区时&lt;br&gt;\n，从从库获取到的数据可能是不一致的。&lt;/p&gt;\n&lt;p&gt;说到底，还是看业务场景。例如涉及到钱的系统，那么一致性是肯定要保证的，银行系统哪怕停止服务也要保证数据的一致性。用过12306，肯定遇到过页面刷新后同一车次有时候有票有时候没票的情况，这就是为了提高可用性，保证刷新操作成功，但是一致性就无法得到保证了。&lt;/p&gt;\n&lt;h1 id=\&#34;参考\&#34;&gt;参考&lt;/h1&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://mp.weixin.qq.com/s/6PgqyigrgVICl0JiI73oNg\&#34;&gt;https://mp.weixin.qq.com/s/6PgqyigrgVICl0JiI73oNg&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/54105974/answer/1643846752\&#34;&gt;https://www.zhihu.com/question/54105974/answer/1643846752&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.hollischuang.com/archives/666\&#34;&gt;https://www.hollischuang.com/archives/666&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;wo-li-jie-de-cap&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;最近在梳理我们系统架构的时候，想从分布式领域的角度来分析架构设计，但是由于之前没系统性接触过分布式相关的知识，正好借此机会来学习分布式相关的知识，并进行自己的总结。本文的目的是搞清楚什么是CAP。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;分布式系统的最大难点，就是各个节点的状态如何同步&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;我理解的CAP&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;学习归纳&#34;,&#34;slug&#34;:&#34;xue-xi-gui-na&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/xue-xi-gui-na/&#34;},{&#34;name&#34;:&#34;分布式&#34;,&#34;slug&#34;:&#34;fen-bu-shi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/fen-bu-shi/&#34;}],&#34;date&#34;:&#34;2022-03-20 17:50:28&#34;,&#34;dateFormat&#34;:&#34;2022-03-20 05:50:28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/wo-li-jie-de-cap/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:307000,&#34;words&#34;:1455,&#34;minutes&#34;:6},&#34;description&#34;:&#34;最近在梳理我们系统架构的时候，想从分布式领域的角度来分析架构设计，但是由于之前没系统性接触过分布式相关的知识，正好借此机会来学习分布式相关的知识，并进行自己的总结。本文的目的是搞清楚什么是CAP。\n\n分布式系统的最大难点，就是各个节点的状态...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF\&#34;&gt;历史背景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A\&#34;&gt;概念解释&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#consistency-%E4%B8%80%E8%87%B4%E6%80%A7\&#34;&gt;Consistency 一致性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#availability-%E5%8F%AF%E9%9D%A0%E6%80%A7\&#34;&gt;Availability 可靠性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#partition-tolerance-%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7\&#34;&gt;Partition Tolerance 分区容错性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88c%E5%92%8Ca%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8\&#34;&gt;为什么C和A不能同时存在&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%8F%96%E8%88%8Dc%E5%92%8Ca\&#34;&gt;如何取舍C和A&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在JDK8之后，Lambda表达式的功能为日常开发提供了很多便捷的操作，但是没接触过的人会对这种表达式有很大的疑惑，为什么要这样表示？我要怎么写出Lambda风格的代码？本文旨在快速理解lambda。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;先看下lambda表达式是什么。在JDK8中，我们可以对接口添加一个注解&lt;code&gt;@FunctionalInterface&lt;/code&gt;,我们看下JDK中&lt;code&gt;Runnalble&lt;/code&gt;接口&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@FunctionalInterface\npublic interface Runnable {\n    \n    void run();\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;接口内有一个抽象方法&lt;code&gt;run()&lt;/code&gt;，要注意一点，如果我们自己要实现一个lambda接口，那么接口内有且仅有一个抽象方法（&lt;code&gt;default&lt;/code&gt;修饰的不算），为什么要这么限制？看完后文就知道了。&lt;/p&gt;\n&lt;p&gt;与&lt;code&gt;Runnable&lt;/code&gt;常常一起出现的是&lt;code&gt;Thread&lt;/code&gt;类，看下Thread中是如何使用&lt;code&gt;Runnable&lt;/code&gt;的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public Thread(Runnable target) {\n    init(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;构造方法中可以传入一个&lt;code&gt;Runnable&lt;/code&gt;对象，在JDK8之前可以使用匿名类的方式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Thread thread = new Thread(new Runnable() {\n    @Override\n    public void run() {\n        // 编写运行逻辑\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这就相当于传入了一个Runnalble实例对象了。&lt;/p&gt;\n&lt;p&gt;现在思考一下，我们知道接口的参数对象是Runnable，知到Runnable仅有一个抽象方法（上文提到的限制），那我们可以简化这个表达式吗？&lt;/p&gt;\n&lt;p&gt;尝试去掉多余的参数声明语句&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d806efa7ee00439bacd42920b680277c~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n接着去掉多余的方法声明语句&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b0646872074fac998da89e8225d212~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;是的，最后剩下的就是实际有效的部分，方法的参数和方法的逻辑。&lt;/p&gt;\n&lt;p&gt;最后我们加个箭头&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2af1d6ea86aa4f34982b8b8040fb658c~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;没错，这个就是lambda表达式了，就是这么变化过来的。&lt;/p&gt;\n&lt;p&gt;考虑有参数的情况，加入Runnable接口的run方法是有参数的，例如&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@FunctionalInterface\npublic interface Runnable {\n    \n    void run(String key,int val);\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么对应，lambda表达式就变成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new Thread((&amp;quot;hello&amp;quot;,20) -&amp;gt; {\n    String k = key; // k == &amp;quot;hello&amp;quot;\n    int v = val;    // v == 20\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果方法的代码只有一行，我们可以省略中括号&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new Thread((&amp;quot;hello&amp;quot;,20) -&amp;gt; log.info(&amp;quot;key = {}&amp;quot;,key));\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;kuai-su-kan-qing-lambda-de-ben-zhi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在JDK8之后，Lambda表达式的功能为日常开发提供了很多便捷的操作，但是没接触过的人会对这种表达式有很大的疑惑，为什么要这样表示？我要怎么写出Lambda风格的代码？本文旨在快速理解lambda。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;快速看清lambda的本质&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2022-02-11 19:13:57&#34;,&#34;dateFormat&#34;:&#34;2022-02-11 07:13:57&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/kuai-su-kan-qing-lambda-de-ben-zhi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:116000,&#34;words&#34;:504,&#34;minutes&#34;:2},&#34;description&#34;:&#34;在JDK8之后，Lambda表达式的功能为日常开发提供了很多便捷的操作，但是没接触过的人会对这种表达式有很大的疑惑，为什么要这样表示？我要怎么写出Lambda风格的代码？本文旨在快速理解lambda。\n\n先看下lambda表达式是什么。在J...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;假设已经了解一致性Hash的相关知识，如果不了解可以先看&lt;a href=\&#34;https://www.zsythink.net/archives/1182\&#34;&gt;https://www.zsythink.net/archives/1182&lt;/a&gt;&lt;br&gt;\n代码地址：&lt;a href=\&#34;https://github.com/zexho994/ConsistentHash\&#34;&gt;https://github.com/zexho994/ConsistentHash&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;我们知道一致性hash的核心思想是对2^32进行取模，然后保存到一个Hash环上:&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20726d0655964e89a79dbb2f4d91e809~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;要实现一致性Hash，先解决几个问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如何表示这个环？&lt;/li&gt;\n&lt;li&gt;如何在环上插入节点、删除节点、查找最近的节点？&lt;/li&gt;\n&lt;li&gt;虚拟节点如何表示，怎么插入到环中？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;hash环\&#34;&gt;Hash环&lt;/h2&gt;\n&lt;p&gt;思考下这个hash环的特点，我们的节点要插入到哪个位置由节点的hash值决定，现在加入有两个节点A和B，&lt;code&gt;A.hashcode = 50&lt;/code&gt;,&lt;code&gt;B.hashcode = 100&lt;/code&gt;,由于环是按顺时针方向查找，那么查找的逻辑就是:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;[0,50] , (50,2^32] 的数据会找到A&lt;/li&gt;\n&lt;li&gt;(50,100] 的数据会找到B&lt;br&gt;\n可以发现一个特点，就是要有序，以及可以支持快速找到下一个节点，&lt;code&gt;TreeMap&lt;/code&gt;就十分契合, 每个节点的右子树就是最小的最近的大于某个hashcode的节点。&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f70674010c44788ba3189a9a3522965~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n整个算法核心的部分也是基于&lt;code&gt;TreeMap&lt;/code&gt;实现的，首先声明&lt;code&gt;ring&lt;/code&gt;，后面所有的节点数据都将存储到ring上。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class ConsistentHashManager {\n\n    private final SortedMap&amp;lt;Integer/*索引大小*/, Node/*节点*/&amp;gt; ring = new TreeMap();\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;中&lt;code&gt;key&lt;/code&gt;存储的节点的&lt;code&gt;索引&lt;/code&gt;值（后面会讲计算方式），&lt;code&gt;val&lt;/code&gt;中存储节点对象实例&lt;code&gt;Node&lt;/code&gt;，其中&lt;code&gt;Node&lt;/code&gt;是模拟表示现实服务器信息的对象，需要重写&lt;code&gt;equals()&lt;/code&gt;和&lt;code&gt;hashcode()&lt;/code&gt;方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Node {\n\n    //服务器名称\n    private String name;\n    //服务器域名\n    private String host;\n    //服务器端口\n    private Integer port;\n\n    public Node(String name, String host, int port) {\n        this.name = name;\n        this.host = host;\n        this.port = port;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Node)) return false;\n        Node node = (Node) o;\n        return getPort() == node.getPort() &amp;amp;&amp;amp; getName().equals(node.getName()) &amp;amp;&amp;amp; getHost().equals(node.getHost());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getName(), getHost(), getPort());\n    }\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;添加新节点\&#34;&gt;添加新节点&lt;/h2&gt;\n&lt;p&gt;要将一个节点存储到环上，首先是要知道存储到哪个位置上，位置由索引的大小决定，这就需要计算&lt;code&gt;Node对象&lt;/code&gt;的索引值&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349fd9c6f8ca43268c9abdaf5e1d92c5~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n先声明一个接口对象，因为以后可能会有各种计算方式，那么会有各种不同的具体实现类，所以这里采用基于接口而非实例的方式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface HashUtil {\n\n    int hash(String key);\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面是使用MD5的方式，这肯定不是最好的方法，重点是表达&lt;code&gt;hash()&lt;/code&gt;的作用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Md5HashUtil implements HashUtil {\n\n    private MessageDigest messageDigest;\n\n    public Md5HashUtil() {\n        try {\n            this.messageDigest = MessageDigest.getInstance(&amp;quot;MD5&amp;quot;);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public int hash(String key) {\n        this.messageDigest.update(String.valueOf(key).getBytes();\n        byte[] digest = this.messageDigest.digest();\n        int h = 0;\n        for (int i = 0; i &amp;lt; 4; i++) {\n            h |= ((int) digest[i]) &amp;amp; 0xFF;\n            // 循环4次，每次移动8位，正好32次\n            h &amp;lt;&amp;lt;= 8;\n        }\n        return h;\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有了&lt;code&gt;hash()&lt;/code&gt;方法，可以知道节点的索引值了，就可以将Node存储到ring中了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void addNode(Node node) {\n    ring.put(hashUtil.hash(node.getKey()), node);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么这时候还有一件事要做，如何添加虚拟节点呢？刚开始的时候我认为为了保证平均分布，那么虚拟节点的分布特征应该如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ff31e6502b4cc195d50224ce7951a7~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;但是会发现一个问题，要继续增加更多物理节点时，如何继续保持平均分布？这很难实现，从另一个方面再想，虚拟节点的作用是什么？是为了让分配更平均，防止血崩的概率，其实哪怕这些虚拟节点的位置都是随机的，只要节点数量够多，就已经达到了目的。&lt;/p&gt;\n&lt;p&gt;完善一下&lt;code&gt;addNode()&lt;/code&gt;方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void addNode(Node node) {\n    ring.put(hashUtil.hash(node.getKey()), node);\n    for (int i = 0; i &amp;lt; this.virNodeCount; i++) {\n        this.ring.put(hashUtil.hash(node.getKey() + i), node);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;删除节点\&#34;&gt;删除节点&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;ring&lt;/code&gt;中存储的val是Node，这样在遍历ring的匹配node进行删除即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void removeNote(Node node) {\n    ring.entrySet().removeIf(next -&amp;gt; next.getValue().equals(node));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;获取下一个节点\&#34;&gt;获取下一个节点&lt;/h2&gt;\n&lt;p&gt;这部分看代码了解下&lt;code&gt;TreeMap&lt;/code&gt;的&lt;code&gt;api&lt;/code&gt;就可以理解，没什么难度&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public Node getNextNode(String key) {\n    SortedMap&amp;lt;Integer, Node&amp;gt; longNodeSortedMap = ring.tailMap(hashUtil.hash(key));\n    if (longNodeSortedMap.isEmpty()) {\n        return ring.get(ring.firstKey());\n    }\n    return longNodeSortedMap.get(longNodeSortedMap.firstKey());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;测试\&#34;&gt;测试&lt;/h1&gt;\n&lt;h2 id=\&#34;负载均衡\&#34;&gt;负载均衡&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Test\nvoid loadBalancingTest() {\n    ConsistentHashManager consistentHashManager = new ConsistentHashManager();\n    // 添加四个节点\n    consistentHashManager.addNode(new Node(&amp;quot;node1&amp;quot;, &amp;quot;192.0.0.1&amp;quot;, 8080));\n    consistentHashManager.addNode(new Node(&amp;quot;node2&amp;quot;, &amp;quot;192.0.0.2&amp;quot;, 8080));\n    consistentHashManager.addNode(new Node(&amp;quot;node3&amp;quot;, &amp;quot;192.0.0.3&amp;quot;, 8080));\n    consistentHashManager.addNode(new Node(&amp;quot;node4&amp;quot;, &amp;quot;192.0.0.4&amp;quot;, 8080));\n\n    String preKey = &amp;quot;Data_&amp;quot;;\n    // map用来记录每个节点命中的次数\n    Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(200000);\n    map.put(&amp;quot;node1&amp;quot;, 0);\n    map.put(&amp;quot;node2&amp;quot;, 0);\n    map.put(&amp;quot;node3&amp;quot;, 0);\n    map.put(&amp;quot;node4&amp;quot;, 0);\n    // 假设有20w个数据\n    for (int i = 0; i &amp;lt; 200000; i++) {\n        Node nextNote = consistentHashManager.getNextNote(preKey + i);\n        // 累加命中次数\n        map.computeIfPresent(nextNote.getName(), (k, v) -&amp;gt; v + 1);\n    }\n    // 打印\n    map.entrySet().forEach(System.out::println);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88147670d09b40c8aab81a41269e700d~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;整体的比例是 &lt;code&gt;5 : 6 : 4.5 : 4.5&lt;/code&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;删除节点后的命中率\&#34;&gt;删除节点后的命中率&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Test\nvoid removeNodeTest() {\n    // 省略添加节点的代码 ...\n    \n    // 移除一个节点\n    consistentHashManager.removeNote(node4);\n    // 测试下移除节点后的命中率\n    AtomicInteger n1 = new AtomicInteger(0);\n    AtomicInteger n2 = new AtomicInteger(0);\n    AtomicInteger n3 = new AtomicInteger(0);\n    for (int i = 0; i &amp;lt; 200000; i++) {\n        Node nextNode = consistentHashManager.getNextNode(preKey + i);\n        if (nextNode.getName().equals(&amp;quot;node1&amp;quot;)) {\n            n1.incrementAndGet();\n        } else if (nextNode.getName().equals(&amp;quot;node2&amp;quot;)) {\n            n2.incrementAndGet();\n        } else if (nextNode.getName().equals(&amp;quot;node3&amp;quot;)) {\n            n3.incrementAndGet();\n        } else {\n            throw new RuntimeException(&amp;quot;node4 未清理干净&amp;quot;);\n        }\n    }\n\n    // 打印命中率, 原本的次数/删除后的次数\n    statistic.forEach((key, value) -&amp;gt; {\n        if (key.equals(&amp;quot;node1&amp;quot;)) {\n            System.out.println(&amp;quot;Node1,总访问次数=&amp;quot; + n1 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n1.get());\n        } else if (key.equals(&amp;quot;node2&amp;quot;)) {\n            System.out.println(&amp;quot;Node2,总访问次数=&amp;quot; + n2 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n2.get());\n        } else if (key.equals(&amp;quot;node3&amp;quot;)) {\n            System.out.println(&amp;quot;Node3,总访问次数=&amp;quot; + n3 + &amp;quot;,有效访问 &amp;quot; + value + &amp;quot; 命中率 = &amp;quot; + (double) (value) / n3.get());\n        }\n    });\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72b63651f134c3eade1c41a75fdd122~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;shi-xian-yi-zhi-xing-hash-suan-fa&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;假设已经了解一致性Hash的相关知识，如果不了解可以先看&lt;a href=\&#34;https://www.zsythink.net/archives/1182\&#34;&gt;https://www.zsythink.net/archives/1182&lt;/a&gt;&lt;br&gt;\n代码地址：&lt;a href=\&#34;https://github.com/zexho994/ConsistentHash\&#34;&gt;https://github.com/zexho994/ConsistentHash&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;我们知道一致性hash的核心思想是对2^32进行取模，然后保存到一个Hash环上:&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;实现一致性Hash算法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;分布式&#34;,&#34;slug&#34;:&#34;fen-bu-shi&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/fen-bu-shi/&#34;},{&#34;name&#34;:&#34;造轮子&#34;,&#34;slug&#34;:&#34;KrLfgh9WlS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/&#34;}],&#34;date&#34;:&#34;2022-02-02 15:12:22&#34;,&#34;dateFormat&#34;:&#34;2022-02-02 03:12:22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/shi-xian-yi-zhi-xing-hash-suan-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:392000,&#34;words&#34;:1449,&#34;minutes&#34;:7},&#34;description&#34;:&#34;\n假设已经了解一致性Hash的相关知识，如果不了解可以先看https://www.zsythink.net/archives/1182\n代码地址：https://github.com/zexho994/ConsistentHash\n\n我们知...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#hash%E7%8E%AF\&#34;&gt;Hash环&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%8A%82%E7%82%B9\&#34;&gt;添加新节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9\&#34;&gt;删除节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9\&#34;&gt;获取下一个节点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8B%E8%AF%95\&#34;&gt;测试&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\&#34;&gt;负载均衡&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%90%8E%E7%9A%84%E5%91%BD%E4%B8%AD%E7%8E%87\&#34;&gt;删除节点后的命中率&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;前提：本文假设你已经了解AOP切面编程的基础概念&lt;br&gt;\n项目地址：&lt;a href=\&#34;https://github.com/zexho994/IOC-AOP\&#34;&gt;https://github.com/zexho994/IOC-AOP&lt;/a&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;aop的逻辑\&#34;&gt;AOP的逻辑&lt;/h1&gt;\n&lt;p&gt;首先我们定义一个被代理类&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic class A interface I{\n\n    public void print() {\n        System.out.println(&amp;quot;aaa&amp;quot;);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定义切点和切面&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\n@Aspect\npublic class AdviceSample {\n\n    @Before\n    @Pointcut(beanName = &amp;quot;A&amp;quot;)\n    public void enhance2Before() {\n        System.out.println(&amp;quot;before&amp;quot;);\n    }\n\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;后续我们使用A的时候，都会先打印切面的内容，也就是：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;before\naaa\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83758a4da5594e43aee236ff3ba476df~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如何将切面的内容添加到代理的方法里面去呢？&lt;/p&gt;\n&lt;h1 id=\&#34;切面切入实现\&#34;&gt;切面切入实现&lt;/h1&gt;\n&lt;h2 id=\&#34;jdk动态代理实现\&#34;&gt;JDK动态代理实现&lt;/h2&gt;\n&lt;p&gt;提到代理，最先想到的是JDK提供的动态代理类&lt;code&gt;InvocationHandler&lt;/code&gt;，下面尝试使用JDK动态代理实现 ，切入的方式假设使用&lt;code&gt;before&lt;/code&gt;，而&lt;code&gt;after&lt;/code&gt;和&lt;code&gt;around&lt;/code&gt;看完就懂如何实现了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class JDKDynamicProxy implements InvocationHandler {\n    \n    private Method before = null;\n    private Object beforeObj = null;\n\n    \n    /**\n     * @param proxy  代理的真实对象\n     * @param method 要调用的真实对象的方法\n     * @param args   方法的参数\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t// 执行before方法\n        if (before != null) {\n            before.invoke(beforeObj);\n        }\n\n        // 执行本体方法\n        Object invoke = method.invoke(target, args);\n\n        return invoke;\n    }\n    \n    /**\n     * 获取动态代理对象\n     *\n     * @param obj 被代理类\n     * @return obj的父接口实现子类, 因为返回的是T父接口重写的类\n     */\n    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n    public &amp;lt;T&amp;gt; T getDynamicProxyImpl(T obj,Method before, Object beforeObj) {\n        assert obj != null;\n        this.before = before;\n        this.beforeObj = beforeObj;\n\n        // newProxyInstance() 会创建类$A，$A实现了obj的父接口，所有接口方法内容都为 {@link #invoke()} 。\n        return (T) newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n    }\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;统一调用&lt;code&gt;getDynamicProxyImpl()&lt;/code&gt;来获取新的代理类，参数里面传入before的Method对象，&lt;code&gt;invoke()&lt;/code&gt;方法定义了在执行本体方法之前执行&lt;code&gt;before&lt;/code&gt;方法，这样新的代理类都会先执行&lt;code&gt;before&lt;/code&gt;方法再执行本体方法了。&lt;/p&gt;\n&lt;p&gt;实现非常简单易懂，那么要实现&lt;code&gt;after&lt;/code&gt;方法就是可以传入after的&lt;code&gt;Method&lt;/code&gt;对象，然后在&lt;code&gt;invoke()&lt;/code&gt;的本体方法之后执行，&lt;code&gt;around&lt;/code&gt;的实现不用再增加新的逻辑了，只要同时传入&lt;code&gt;before&lt;/code&gt;和&lt;code&gt;after&lt;/code&gt;的&lt;code&gt;Method&lt;/code&gt;对象，这样新的代理类就会同时执行&lt;code&gt;before()&lt;/code&gt;和&lt;code&gt;after()&lt;/code&gt;了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e5dca4c4a049519f0edaa0986605f5~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;cglib实现\&#34;&gt;Cglib实现&lt;/h2&gt;\n&lt;p&gt;JDK动态代理可以实现，但是有约束条件就是被代理类必须要有父接口，因为JDK动态实现的原理就是实现接口生成增强的子类。那么如果一个类没有父接口该如何进行切面增强呢？&lt;code&gt;Spring&lt;/code&gt;中使用了&lt;code&gt;cglib&lt;/code&gt;这个库来实现。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class CglibProxy implements MethodInterceptor {\n\n    public static final Enhancer ENHANCER = new Enhancer();\n\n    private Method before = null;\n    private Object beforeObj = null;\n\n    private Method after = null;\n    private Object afterObj = null;\n\n    /**\n     * @param obj         cglib动态代理生成的实例\n     * @param method      被调用的方法的引用\n     * @param params      参数列表\n     * @param methodProxy 代理类对方法的代理引用\n     */\n    @Override\n    public Object intercept(Object obj, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {\n        if (before != null) {\n            before.invoke(beforeObj);\n        }\n        Object result = methodProxy.invokeSuper(obj, params);\n        if (after != null) {\n            after.invoke(afterObj);\n        }\n        return result;\n    }\n\n    public void setBefore(Method before, Object beforeObj) {\n        this.before = before;\n        this.beforeObj = beforeObj;\n    }\n\n    public void setAfter(Method after, Object afterObj) {\n        this.after = after;\n        this.afterObj = afterObj;\n    }\n\n    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n    public static &amp;lt;T&amp;gt; T getProxy(T target, Method before, Object beforeObj, Method after, Object afterObj) {\n        ENHANCER.setSuperclass(target.getClass());\n        CglibProxy cglibProxy = new CglibProxy();\n        cglibProxy.setBefore(before, beforeObj);\n        cglibProxy.setAfter(after, afterObj);\n\n        ENHANCER.setCallback(cglibProxy);\n        return (T) ENHANCER.create();\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实现的思路和JDK动态代理几乎一致，通过调用&lt;code&gt;getProxy()&lt;/code&gt;方法传入&lt;code&gt;before()&lt;/code&gt;或&lt;code&gt;after()&lt;/code&gt;方法就可以获得代理类了。&lt;/p&gt;\n&lt;p&gt;为什么cglib的实现不需要接口呢？cglib的实现原理是为被代理类创建一个子类，然后将切面通过ASM提供的字节码技术织入到目标方法中，这样子类的方法就包含了本体和切面的逻辑了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8116c3d61d4f8d8b72d525d210355d~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;li-yong-cglib-he-jdk-dong-tai-dai-li-shi-xian-aop&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;前提：本文假设你已经了解AOP切面编程的基础概念&lt;br&gt;\n项目地址：&lt;a href=\&#34;https://github.com/zexho994/IOC-AOP\&#34;&gt;https://github.com/zexho994/IOC-AOP&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;利用Cglib和JDK动态代理实现AOP&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;},{&#34;name&#34;:&#34;造轮子&#34;,&#34;slug&#34;:&#34;KrLfgh9WlS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/&#34;}],&#34;date&#34;:&#34;2021-11-11 19:11:07&#34;,&#34;dateFormat&#34;:&#34;2021-11-11 07:11:07&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/li-yong-cglib-he-jdk-dong-tai-dai-li-shi-xian-aop/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:233000,&#34;words&#34;:900,&#34;minutes&#34;:4},&#34;description&#34;:&#34;前提：本文假设你已经了解AOP切面编程的基础概念\n项目地址：https://github.com/zexho994/IOC-AOP\n\nAOP的逻辑\n首先我们定义一个被代理类\n@Bean\npublic class A interface I{...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#aop%E7%9A%84%E9%80%BB%E8%BE%91\&#34;&gt;AOP的逻辑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5%E5%AE%9E%E7%8E%B0\&#34;&gt;切面切入实现&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0\&#34;&gt;JDK动态代理实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#cglib%E5%AE%9E%E7%8E%B0\&#34;&gt;Cglib实现&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;何为路由中心？&lt;br&gt;\n在通常的理解中，提到消息队列，最简单的模型如下图：&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f71895f47ec4236a5bea69b046546dc~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;很好理解，生产者只要知道消息队列的网络地址，然后发送消息到这个网络地址上。但是实际往往不是这么简单，因为消息队列一般是集群模式，再如下图，4个实例组成集群：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506c5a983c63464da45316ec8e8d91ae~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;假如现在继续采用生产者/消费者直接记录4个实例网络地址的方式，也是可以实现的。随着业务的发展，需要对队列进行水平扩展，要将4台实例临时扩展到6台，那么生产者和消费者是不知道新增的两个实例网络地址的，这时只能重启，记录两个新实例的网络地址再重启。这是不是非常麻烦？针对这个问题可以思考下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;对于集群模式的服务，有没有更好更灵活的方式去记录路由信息？&lt;/li&gt;\n&lt;li&gt;当集群实例数量增加或者减少时，怎么让其他服务可以知道？并且不用做任何操作。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;这时如果我们新增一个路由中心系统，负责两件事：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;所有服务可以去路由中心上报自己的网络地址。&lt;/li&gt;\n&lt;li&gt;所有服务可以去路由中心获取其他服务的网络地址。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6aa125536e4dfb83330ef43de7e9d7~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这样我们系统有多少的业务系统，我们只要知道路由中心的地址就可以了。&lt;/p&gt;\n&lt;p&gt;那么路由中心怎么感知实例数量的变化呢？最朴素的手段就是心跳，路由中心定期向所有上报的系统发送心跳包，如果心跳包没有响应则说明实例已经停止运行了，在路由记录中剔除该服务地址就可以了。&lt;/p&gt;\n&lt;p&gt;其实这两个步骤都有专门名称：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;服务注册：将某个服务调用信息记录到一个公共组件中&lt;/li&gt;\n&lt;li&gt;服务发现：当服务新增/减少，要能被其他调用者自动发现。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;市面上已有的代表性产品有：zookeeper、consul、etcd。&lt;/p&gt;\n&lt;h1 id=\&#34;rocketmq中的namesrv\&#34;&gt;RocketMQ中的Namesrv&lt;/h1&gt;\n&lt;p&gt;图中展示了Namesrv的3个功能，也是核心的3个功能：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;注册broker&lt;/li&gt;\n&lt;li&gt;获取路由信息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;定时心跳检测&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c54c19fc50942ddbdd8bc47e62990b1~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;接下来看看rocketmq的源码是如何实现这3个功能的&lt;/p&gt;\n&lt;h1 id=\&#34;路由元信息\&#34;&gt;路由元信息&lt;/h1&gt;\n&lt;p&gt;namesrv作为路由信息的管理者，本质上可以这么对namesrv进行理解：&lt;strong&gt;保存路由信息的数据结构 + 操作数据结构的算法&lt;/strong&gt;，路由元信息便是第一部分，所以先看看namesrv保存路由信息的数据结构是什么样子？&lt;/p&gt;\n&lt;p&gt;在&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager.java&lt;/code&gt;类下，包含了所有的路由元信息&lt;/p&gt;\n&lt;h3 id=\&#34;topicqueuetable\&#34;&gt;topicQueueTable&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * 保存Topic和队列的信息，也叫真正的路由信息。\n     * 一个Topic的queue可能分布在不同的broker中，也有可能分布在同一个broker中。\n     * key:topic . val:QueueData\n     */\n    private final HashMap&amp;lt;String, List&amp;lt;QueueData&amp;gt;&amp;gt; topicQueueTable;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9e4c5596d5446c904f294c0309bc2c~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;brokeraddrtable\&#34;&gt;brokerAddrTable&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Broker基础信息，broker名称和broker信息的对应信息\n     * key:broker name . val:broker data\n     */\n    private final HashMap&amp;lt;String, BrokerData&amp;gt; brokerAddrTable;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddec0178522a42d791986edd1daf1756~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;clusteraddrtable\&#34;&gt;clusterAddrTable&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Broker集群信息,集群中所有Broker名称\n     * key: cluster name . val:set&amp;lt;broker name&amp;gt;\n     */\n    private final HashMap&amp;lt;String, Set&amp;lt;String&amp;gt;&amp;gt; clusterAddrTable;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac1bd42e6464d548a8df4725b37a8ab~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;brokerlivetable\&#34;&gt;brokerLiveTable&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Broker状态信息，NameServer每次收心跳包都会替换该信息\n     * key: broker addr . val:broker live info\n     */\n    private final HashMap&amp;lt;String, BrokerLiveInfo&amp;gt; brokerLiveTable;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24bca7def87a46868684c025076f71cd~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;filterservertable\&#34;&gt;filterServerTable&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * 用于类模式消息过滤\n     * key:broker addr . val:filter server\n     */\n    private final HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; filterServerTable;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;知道了路由元信息的数据结构，再看看路由信息是如何保存到这些map中的以及如何查询的。&lt;/p&gt;\n&lt;h1 id=\&#34;服务注册\&#34;&gt;服务注册&lt;/h1&gt;\n&lt;p&gt;注册broker和获取路由信息是namesrv提供的API，位于&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/processor/DefaultRequestProcessor.java&lt;/code&gt;类下的&lt;code&gt;processRequest()&lt;/code&gt;，根据请求的code判断请求的类型。下面包含了namesrv所有的对外接口API。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;switch (request.getCode()) {\n    case RequestCode.PUT_KV_CONFIG:\n        // 添加配置\n        return this.putKVConfig(ctx, request);\n    case RequestCode.GET_KV_CONFIG:\n        // 获取配置\n        return this.getKVConfig(ctx, request);\n    case RequestCode.DELETE_KV_CONFIG:\n        // 删除配置\n        return this.deleteKVConfig(ctx, request);\n    case RequestCode.QUERY_DATA_VERSION:\n        return queryBrokerTopicConfig(ctx, request);\n    case RequestCode.REGISTER_BROKER:\n        // 注册broker\n        Version brokerVersion = MQVersion.value2Version(request.getVersion());\n        if (brokerVersion.ordinal() &amp;gt;= MQVersion.Version.V3_0_11.ordinal()) {\n            // 3.0.11之后\n            return this.registerBrokerWithFilterServer(ctx, request);\n        } else {\n            // 3.0.11之前\n            return this.registerBroker(ctx, request);\n        }\n    case RequestCode.UNREGISTER_BROKER:\n        // 注销broker\n        return this.unregisterBroker(ctx, request);\n    case RequestCode.GET_ROUTEINFO_BY_TOPIC:\n        // 根据topic获取路由信息\n        return this.getRouteInfoByTopic(ctx, request);\n    case RequestCode.GET_BROKER_CLUSTER_INFO:\n        // 获取broker集群信息\n        return this.getBrokerClusterInfo(ctx, request);\n    case RequestCode.WIPE_WRITE_PERM_OF_BROKER:\n        // 删除Broker的写权限\n        return this.wipeWritePermOfBroker(ctx, request);\n    case RequestCode.GET_ALL_TOPIC_LIST_FROM_NAMESERVER:\n        // 获取全部Topic信息\n        return getAllTopicListFromNameserver(ctx, request);\n    case RequestCode.DELETE_TOPIC_IN_NAMESRV:\n        // 删除Topic信息\n        return deleteTopicInNamesrv(ctx, request);\n    case RequestCode.GET_KVLIST_BY_NAMESPACE:\n        // 获取kv列表\n        return this.getKVListByNamespace(ctx, request);\n    case RequestCode.GET_TOPICS_BY_CLUSTER:\n        // 获取topic根据集群\n        return this.getTopicsByCluster(ctx, request);\n\t..\n    default:\n        break;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中服务注册对应的是code是&lt;code&gt;REGISTER_BROKER&lt;/code&gt;，下面看到根据版本的不同分为&lt;code&gt;registerBrokerWithFilterServer()&lt;/code&gt;和&lt;code&gt;registerBroker()&lt;/code&gt;，我使用的是v4.9.1，所以看看&lt;code&gt;registerBrokerWithFilterServer()&lt;/code&gt;的实现&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public RemotingCommand registerBrokerWithFilterServer(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException {\n\t...省略...        \n        \n    // 注册的方法\n\tRegisterBrokerResult result = this.namesrvController.getRouteInfoManager().registerBroker(...);\n\n    ...省略...\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;核心的注册逻辑在&lt;code&gt;registerBroker()&lt;/code&gt;中 ,继续看下&lt;code&gt;registerBroker()&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public RegisterBrokerResult registerBroker(final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List&amp;lt;String&amp;gt; filterServerList, final Channel channel) {\n    RegisterBrokerResult result = new RegisterBrokerResult();\n    try {\n        try {\n            this.lock.writeLock().lockInterruptibly();\n\n            // step1\n            // 根据集群名称获取 broker name 集合\n            Set&amp;lt;String&amp;gt; brokerNames = this.clusterAddrTable.get(clusterName);\n            if (null == brokerNames) {\n                brokerNames = new HashSet&amp;lt;&amp;gt;();\n                this.clusterAddrTable.put(clusterName, brokerNames);\n            }\n            // 添加broker name 到集合中\n            brokerNames.add(brokerName);\n\n            // 是否第一次注册\n            boolean registerFirst = false;\n\n            // step2\n            // 如果 broker table 里没有数据，则表示broker为第一次注册\n            BrokerData brokerData = this.brokerAddrTable.get(brokerName);\n            if (null == brokerData) {\n                registerFirst = true;\n                brokerData = new BrokerData(clusterName, brokerName, new HashMap&amp;lt;&amp;gt;());\n                this.brokerAddrTable.put(brokerName, brokerData);\n            }\n            Map&amp;lt;Long, String&amp;gt; brokerAddrsMap = brokerData.getBrokerAddrs();\n            //Switch slave to master: first remove &amp;lt;1, IP:PORT&amp;gt; in namesrv, then add &amp;lt;0, IP:PORT&amp;gt;\n            //The same IP:PORT must only have one record in brokerAddrTable\n            brokerAddrsMap.entrySet().removeIf(item -&amp;gt; null != brokerAddr &amp;amp;&amp;amp; brokerAddr.equals(item.getValue()) &amp;amp;&amp;amp; brokerId != item.getKey());\n\n            String oldAddr = brokerAddrsMap.put(brokerId, brokerAddr);\n            registerFirst = registerFirst || (null == oldAddr);\n\n            // step3\n            // 如果 topic 信息不为空，而且是 master\n            if (null != topicConfigWrapper &amp;amp;&amp;amp; MixAll.MASTER_ID == brokerId) {\n                // 如果是第一次注册，或者 broker topic 信息发生变动过\n                if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || registerFirst) {\n                    // 获取 topic info 列表\n                    ConcurrentMap&amp;lt;String, TopicConfig&amp;gt; tcTable = topicConfigWrapper.getTopicConfigTable();\n                    if (tcTable != null) {\n                        for (Map.Entry&amp;lt;String, TopicConfig&amp;gt; entry : tcTable.entrySet()) {\n                            this.createAndUpdateQueueData(brokerName, entry.getValue());\n                        }\n                    }\n                }\n            }\n\n            // step4\n            BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr, new BrokerLiveInfo(System.currentTimeMillis(), topicConfigWrapper.getDataVersion(), channel, haServerAddr));\n            if (null == prevBrokerLiveInfo) {\n                log.info(&amp;quot;new broker registered, {} HAServer: {}&amp;quot;, brokerAddr, haServerAddr);\n            }\n\n            // step5\n            if (filterServerList != null) {\n                if (filterServerList.isEmpty()) {\n                    this.filterServerTable.remove(brokerAddr);\n                } else {\n                    this.filterServerTable.put(brokerAddr, filterServerList);\n                }\n            }\n\n            // 如果broker的身份是slave\n            if (MixAll.MASTER_ID != brokerId) {\n                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);\n                if (masterAddr != null) {\n                    BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);\n                    if (brokerLiveInfo != null) {\n                        // 在返回结果中，携带master的地址，主从同步步骤需要。\n                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());\n                        result.setMasterAddr(masterAddr);\n                    }\n                }\n            }\n        } finally {\n            this.lock.writeLock().unlock();\n        }\n    } catch (Exception e) {\n        log.error(&amp;quot;registerBroker Exception&amp;quot;, e);\n    }\n\n    return result;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码注释中使用step1 ~ step5对5个不同阶段进行标记，这5个阶段的作用可以这么理解&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b53e34de8e48ca8e5adcbb371babcd~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;路由剔除\&#34;&gt;路由剔除&lt;/h1&gt;\n&lt;p&gt;namesrv要删除一个broker的路由信息的只有一个：这个broker目前不能正常提供服务了。这也可以分为两种情况&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;broker正常停止。&lt;/li&gt;\n&lt;li&gt;broker发生异常。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;broker-正常停止\&#34;&gt;Broker 正常停止&lt;/h2&gt;\n&lt;p&gt;broker在停止的时候会给namesrv发送一个&lt;code&gt;unregisterBroker&lt;/code&gt;类型的消息，发送代码部分在&lt;code&gt;broker/src/main/java/org/apache/rocketmq/broker/out/BrokerOuterAPI.java&lt;/code&gt;类的&lt;code&gt;unregisterBrokerAll()&lt;/code&gt;，namesrv处理这个消息的入口上文服务注册部分提到过，代码的逻辑很直白，就是从&lt;code&gt;topicQueueTable&lt;/code&gt; 、&lt;code&gt;brokerAddrTable&lt;/code&gt; 、&lt;code&gt;brokerLiveTable&lt;/code&gt; 、&lt;code&gt;filterServerTable&lt;/code&gt; 删除与该Broker相关的信息。&lt;/p&gt;\n&lt;h2 id=\&#34;broker-异常\&#34;&gt;Broker 异常&lt;/h2&gt;\n&lt;p&gt;broker异常的时候，肯定是无法主动向namesrv发送注销消息的，所以需要namesrv主动去发现哪些异常的broker。按照这个思路，可以想到两种实现手段：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt; namesrv启动一个定时任务，然后向所有broker发送心跳请求，无法响应的broker可以怀疑是发生了异常了。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt; 记录broker向namesrv最后发送心跳消息的时间，namesrv启动定时任务，判断每个最后心跳时间与当前的时间是否超时，超时说明broker异常导致无法发送心跳包&lt;/p&gt;\n&lt;p&gt;RocketMQ的设计思路和方案二类似。&lt;/p&gt;\n&lt;h3 id=\&#34;启动定时任务\&#34;&gt;启动定时任务&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/NamesrvController#initailize()&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public boolean initialize() {\n    //...略\n    \n    this.scheduledExecutorService.scheduleAtFixedRate(NamesrvController.this.routeInfoManager::scanNotActiveBroker, 5, 10, TimeUnit.SECONDS);\n    \n\t//... 略\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;namesrv/src/main/java/org/apache/rocketmq/namesrv/routeinfo/RouteInfoManager#scanNotActiveBroker()&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void scanNotActiveBroker() {\n    // 从存活列表里获取broker数据\n    Iterator&amp;lt;Entry&amp;lt;String, BrokerLiveInfo&amp;gt;&amp;gt; it = this.brokerLiveTable.entrySet().iterator();\n    while (it.hasNext()) {\n        Entry&amp;lt;String, BrokerLiveInfo&amp;gt; next = it.next();\n        long last = next.getValue().getLastUpdateTimestamp();\n        // 判断消息发送间隔\n        if ((last + BROKER_CHANNEL_EXPIRED_TIME) &amp;lt; System.currentTimeMillis()) {\n            RemotingUtil.closeChannel(next.getValue().getChannel());\n\t\t\t// 移除该broker信息\n            it.remove();\n            log.warn(&amp;quot;The broker channel expired, {} {}ms&amp;quot;, next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);\n            this.onChannelDestroy(next.getKey(), next.getValue().getChannel());\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;何为路由中心？&lt;br&gt;\n在通常的理解中，提到消息队列，最简单的模型如下图：&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;_Ywd8fi71&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/&#34;},{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;}],&#34;date&#34;:&#34;2021-10-27 22:09:19&#34;,&#34;dateFormat&#34;:&#34;2021-10-27 10:09:19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:562000,&#34;words&#34;:2159,&#34;minutes&#34;:10},&#34;description&#34;:&#34;何为路由中心？\n在通常的理解中，提到消息队列，最简单的模型如下图：\n\n\n很好理解，生产者只要知道消息队列的网络地址，然后发送消息到这个网络地址上。但是实际往往不是这么简单，因为消息队列一般是集群模式，再如下图，4个实例组成集群：\n\n假如现在...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#rocketmq%E4%B8%AD%E7%9A%84namesrv\&#34;&gt;RocketMQ中的Namesrv&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF\&#34;&gt;路由元信息&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#topicqueuetable\&#34;&gt;topicQueueTable&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#brokeraddrtable\&#34;&gt;brokerAddrTable&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#clusteraddrtable\&#34;&gt;clusterAddrTable&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#brokerlivetable\&#34;&gt;brokerLiveTable&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#filterservertable\&#34;&gt;filterServerTable&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C\&#34;&gt;服务注册&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%AF%E7%94%B1%E5%89%94%E9%99%A4\&#34;&gt;路由剔除&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#broker-%E6%AD%A3%E5%B8%B8%E5%81%9C%E6%AD%A2\&#34;&gt;Broker 正常停止&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#broker-%E5%BC%82%E5%B8%B8\&#34;&gt;Broker 异常&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\&#34;&gt;启动定时任务&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;接着上一篇 [RocketMQv4.9.1源码分析-HA主从 Master读写处理] 解答了Master相关的问题，这篇文章围绕Slave相关的一些问题继续看代码。&lt;/p&gt;\n&lt;p&gt;对于slave，我们有如下一些疑惑：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何获取&lt;code&gt;master&lt;/code&gt;的路由信息&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何向&lt;code&gt;master&lt;/code&gt;报告&lt;code&gt;offset&lt;/code&gt;的&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何处理&lt;code&gt;master&lt;/code&gt;同步的数据&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;在整体的类图布局中，slave相关的代码都在HAClient类中&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed3a2d9fc0214105b8bbf8f96114a677~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;haclient\&#34;&gt;HAClient&lt;/h2&gt;\n&lt;p&gt;HAClient部分是Slave处理的核心，其中包括三部分：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;slave与master建立连接&lt;/li&gt;\n&lt;li&gt;slave向master汇报同步进度&lt;/li&gt;\n&lt;li&gt;slave接收master的同步数据并处理&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49ce7b1d1f3a4b6bb097e0aef244cc56~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;haclient-启动\&#34;&gt;HAClient 启动&lt;/h3&gt;\n&lt;p&gt;之前提到了，HAClient启动的触发时机是HAService启动的方法中，在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService.start()&lt;/code&gt;中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// HAService 启动\npublic void start() throws Exception {\n    this.acceptSocketService.beginAccept();\n    this.acceptSocketService.start();\n    this.groupTransferService.start();\n    this.haClient.start();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;HAClient的启动代码在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService$HAClient.run()&lt;/code&gt;路径下。&lt;/p&gt;\n&lt;p&gt;其中3个核心的步骤在代码注释中有进行标记&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic void run() {\n    log.info(this.getServiceName() + &amp;quot; service started&amp;quot;);\n\n    while (!this.isStopped()) {\n        try {\n            // 步骤一：连接到master\n            if (this.connectMaster()) {\n                // 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告\n                if (this.isTimeToReportOffset()) {\n                    // 报告slave offset\n                    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);\n                    if (!result) {\n                        this.closeMaster();\n                    }\n                }\n                // 检查是否有读事件\n                this.selector.select(1000);\n                //步骤三：处理master返回的消息\n                boolean ok = this.processReadEvent();\n                if (!ok) {\n                    this.closeMaster();\n                }\n                // 处理完读事件后，如果slave offset更新，需要再次发送新的slave offset\n                if (!reportSlaveMaxOffsetPlus()) {\n                    continue;\n                }\n\n                long interval = HAService.this.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n                if (interval &amp;gt; HAService.this.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n                    log.warn(&amp;quot;HAClient, housekeeping, found this connection[&amp;quot; + this.masterAddress + &amp;quot;] expired, &amp;quot; + interval);\n                    this.closeMaster();\n                    log.warn(&amp;quot;HAClient, master not response some time, so close connection&amp;quot;);\n                }\n            } else {\n                this.waitForRunning(1000 * 5);\n            }\n        } catch (Exception e) {\n            log.warn(this.getServiceName() + &amp;quot; service has exception. &amp;quot;, e);\n            this.waitForRunning(1000 * 5);\n        }\n    }\n\n    log.info(this.getServiceName() + &amp;quot; service end&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;slave连接master\&#34;&gt;Slave连接Master&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;connectMaster()&lt;/code&gt;方法的目的是与master进行连接。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// master 地址(master的地址在配置文件中配置)\nprivate final AtomicReference&amp;lt;String&amp;gt; masterAddress = new AtomicReference&amp;lt;&amp;gt;();\n\nprivate boolean connectMaster() throws ClosedChannelException {\n    if (null == socketChannel) {\n        String addr = this.masterAddress.get();\n        if (addr != null) {\n            SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);\n            if (socketAddress != null) {\n                this.socketChannel = RemotingUtil.connect(socketAddress);\n                if (this.socketChannel != null) {\n                    // 读事件,用于监听master的返回消息\n                    this.socketChannel.register(this.selector, SelectionKey.OP_READ);\n                }\n            }\n        }\n        // 设置为当前commitlog的偏移量\n        this.currentReportedOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();\n        this.lastWriteTimestamp = System.currentTimeMillis();\n    }\n\n    return this.socketChannel != null;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有一个点关注下，就是&lt;code&gt;currentReportedOffset&lt;/code&gt;字段，这个字段的目的是表示当前slave已同步的进度，后续在向master进行汇报时也是使用该字段的值。这里进行初始化的时候直接设置为commitlog文件的最大偏移量，如果没有commitlog文件则为0。&lt;/p&gt;\n&lt;h3 id=\&#34;slave汇报offset\&#34;&gt;Slave汇报offset&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 步骤二：如果距离上次报告的时间间隔到了最大等待时间,立刻执行一次报告\nif (this.isTimeToReportOffset()) {\n    // 报告slave offset\n    boolean result = this.reportSlaveMaxOffset(this.currentReportedOffset);\n    if (!result) {\n        this.closeMaster();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;isTimeToReportOffset()&lt;/code&gt;的作用是判断上一次进行汇报的时间与当前时间差是否大于最大等待间隔（默认5s），这意味着即使5s没有收到master的任何消息，slave也会发送一个汇报请求给master，作用相对于一个心跳包。&lt;/p&gt;\n&lt;p&gt;看下&lt;code&gt;reportSlaveMaxOffset()&lt;/code&gt;方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private boolean reportSlaveMaxOffset(final long maxOffset) {\n    // 写位置设为0\n    this.reportOffset.position(0);\n    // 可写长度为8字节\n    this.reportOffset.limit(8);\n    // 数据内容为slave当前的offset\n    this.reportOffset.putLong(maxOffset);\n    // 写模式切换到模式\n    // 将读位置设为0\n    this.reportOffset.position(0);\n    // 可读长度为8字节\n    this.reportOffset.limit(8);\n\n    for (int i = 0; i &amp;lt; 3 &amp;amp;&amp;amp; this.reportOffset.hasRemaining(); i++) {\n        try {\n            // 将数据写入channel中\n            this.socketChannel.write(this.reportOffset);\n        } catch (IOException e) {\n            log.error(this.getServiceName() + &amp;quot;reportSlaveMaxOffset this.socketChannel.write exception&amp;quot;, e);\n            return false;\n        }\n    }\n\n    lastWriteTimestamp = HAService.this.defaultMessageStore.getSystemClock().now();\n    return !this.reportOffset.hasRemaining();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以知道slave的汇报请求的数据包内容很简单，就是一个8字节大小的offset数据。&lt;/p&gt;\n&lt;p&gt;这里代码中有一个细节，rocketmq的作用再进行写模式切换到读模式时没有使用&lt;code&gt;flip()&lt;/code&gt;方法，而是手动设置&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;limit&lt;/code&gt;,这是由于NIO是一个非阻塞IO，write方法不一定会一次将ByteBuffer的数据全部写入。&lt;/p&gt;\n&lt;h3 id=\&#34;slave处理同步数据\&#34;&gt;Slave处理同步数据&lt;/h3&gt;\n&lt;p&gt;步骤三中，调用&lt;code&gt;processReadEvent()&lt;/code&gt;对master返回的数据进行处理，看代码前，我们已经知道master返回的数据是未同步的消息，那么slave要做的事情是什么？当然就是把这个未同步的数据保存到本地的commitlog文件中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private boolean processReadEvent() {\n    // 连续读取到数据大小为0的次数\n    int readSizeZeroTimes = 0;\n    // 一直读取缓冲区的数据，直到没有剩余\n    while (this.byteBufferRead.hasRemaining()) {\n        try {\n            int readSize = this.socketChannel.read(this.byteBufferRead);\n            if (readSize &amp;gt; 0) {\n                readSizeZeroTimes = 0;\n                boolean result = this.dispatchReadRequest();\n                if (!result) {\n                    log.error(&amp;quot;HAClient, dispatchReadRequest error&amp;quot;);\n                    return false;\n                }\n            } else if (readSize == 0) {\n                // 如果连续三次读到为空,则跳出方法,这里的作用？\n                if (++readSizeZeroTimes &amp;gt;= 3) {\n                    break;\n                }\n            } else {\n                log.info(&amp;quot;HAClient, processReadEvent read socket &amp;lt; 0&amp;quot;);\n                return false;\n            }\n        } catch (IOException e) {\n            log.info(&amp;quot;HAClient, processReadEvent read socket exception&amp;quot;, e);\n            return false;\n        }\n    }\n\n    return true;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码里调用了&lt;code&gt;dispatchReadRequest()&lt;/code&gt;方法进行请求的处理，看下这个方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private boolean dispatchReadRequest() {\n    final int msgHeaderSize = 8 + 4; // phyoffset + size\n\n    while (true) {\n        int diff = this.byteBufferRead.position() - this.dispatchPosition;\n        if (diff &amp;gt;= msgHeaderSize) {\n            // master commitlog 偏移量\n            long masterPhyOffset = this.byteBufferRead.getLong(this.dispatchPosition);\n            // 消息大小\n            int bodySize = this.byteBufferRead.getInt(this.dispatchPosition + 8);\n            // 本地  commitlog 偏移量\n            long slavePhyOffset = HAService.this.defaultMessageStore.getMaxPhyOffset();\n            if (slavePhyOffset != 0) {\n                // 如果slave的offset和master的offset不一样，说明数据同步过程发生了问题，不再继续同步。\n                if (slavePhyOffset != masterPhyOffset) {\n                    log.error(&amp;quot;master pushed offset not equal the max phy offset in slave, SLAVE: &amp;quot; + slavePhyOffset + &amp;quot; MASTER: &amp;quot; + masterPhyOffset);\n                    return false;\n                }\n            }\n\n            // 剩余空间够用,将消息追加到commitlog中\n            if (diff &amp;gt;= (msgHeaderSize + bodySize)) {\n                // 消息数组\n                byte[] bodyData = byteBufferRead.array();\n                // 消息的\n                int dataStart = this.dispatchPosition + msgHeaderSize;\n                // 添加数据到本地commitlog中\n                HAService.this.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData, dataStart, bodySize);\n                this.dispatchPosition += msgHeaderSize + bodySize;\n\n                if (!reportSlaveMaxOffsetPlus()) {\n                    return false;\n                }\n\n                continue;\n            }\n        }\n\n        if (!this.byteBufferRead.hasRemaining()) {\n            this.reallocateByteBuffer();\n        }\n\n        break;\n    }\n\n    return true;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;整体的逻辑可以分为俩部分，第一部分是解析请求包，获取消息数据，第二部分是把消息数据写入到commitlog文件中。&lt;/p&gt;\n&lt;p&gt;这两部分代码已经写的很清楚了，比较容易理解，就不再赘述。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;接着上一篇 [RocketMQv4.9.1源码分析-HA主从 Master读写处理] 解答了Master相关的问题，这篇文章围绕Slave相关的一些问题继续看代码。&lt;/p&gt;\n&lt;p&gt;对于slave，我们有如下一些疑惑：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何获取&lt;code&gt;master&lt;/code&gt;的路由信息&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何向&lt;code&gt;master&lt;/code&gt;报告&lt;code&gt;offset&lt;/code&gt;的&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何处理&lt;code&gt;master&lt;/code&gt;同步的数据&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;RocketMQ4.9.1源码解析-(HA模块)主从Slave上报与消息处理&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;_Ywd8fi71&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/&#34;},{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;}],&#34;date&#34;:&#34;2021-10-14 23:07:58&#34;,&#34;dateFormat&#34;:&#34;2021-10-14 11:07:58&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-jie-xi-ha-mo-kuai-zhu-cong-slave-shang-bao-yu-xiao-xi-chu-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:401000,&#34;words&#34;:1500,&#34;minutes&#34;:7},&#34;description&#34;:&#34;接着上一篇 [RocketMQv4.9.1源码分析-HA主从 Master读写处理] 解答了Master相关的问题，这篇文章围绕Slave相关的一些问题继续看代码。\n对于slave，我们有如下一些疑惑：\n\nslave如何获取master的路...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#haclient\&#34;&gt;HAClient&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#haclient-%E5%90%AF%E5%8A%A8\&#34;&gt;HAClient 启动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#slave%E8%BF%9E%E6%8E%A5master\&#34;&gt;Slave连接Master&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#slave%E6%B1%87%E6%8A%A5offset\&#34;&gt;Slave汇报offset&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#slave%E5%A4%84%E7%90%86%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE\&#34;&gt;Slave处理同步数据&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;从最抽象的角度看，主从同步流程可以分为3个步骤:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;master启动&lt;/li&gt;\n&lt;li&gt;slave的启动&lt;/li&gt;\n&lt;li&gt;m/s 数据同步&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4040fe9fe04d9b877449592aaa9770~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;针对上述步骤，结合rocketmq的设计，可以先提一些问题。&lt;/p&gt;\n&lt;h1 id=\&#34;疑问点\&#34;&gt;疑问点&lt;/h1&gt;\n&lt;h2 id=\&#34;master\&#34;&gt;Master&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何接受&lt;code&gt;slave&lt;/code&gt;的请求？&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;处理&lt;code&gt;slave&lt;/code&gt;请求时，如何判断哪些数据需要同步？&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何保证发送的数据同步成功的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;slave\&#34;&gt;Slave&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何获取&lt;code&gt;master&lt;/code&gt;的路由信息&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何向&lt;code&gt;master&lt;/code&gt;报告&lt;code&gt;offset&lt;/code&gt;的&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;slave&lt;/code&gt;如何处理&lt;code&gt;master&lt;/code&gt;同步的数据&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;高级\&#34;&gt;高级&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;同步通知&lt;/strong&gt;和&lt;strong&gt;异步通知&lt;/strong&gt;是如何实现的？&lt;/li&gt;\n&lt;li&gt;RocketMQ的&lt;strong&gt;读写分离&lt;/strong&gt;是如何实现的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;本文先对Master的部分进行解析：&lt;/p&gt;\n&lt;h1 id=\&#34;ha类\&#34;&gt;HA类&lt;/h1&gt;\n&lt;p&gt;主从相关的代码位于 &lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/&lt;/code&gt;路径下，其中主要为两个类&lt;code&gt;HAService&lt;/code&gt;和&lt;code&gt;HAConnection&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;ha类说明\&#34;&gt;HA类说明&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;HAService: RocketMQ 主从同步核心实现类&lt;/li&gt;\n&lt;li&gt;HAService$AcceptSocketService: Master 监听客户端连接&lt;/li&gt;\n&lt;li&gt;HAService$GroupTransferService: 主从同步通知&lt;/li&gt;\n&lt;li&gt;HAService$HAClient: Client 端&lt;/li&gt;\n&lt;li&gt;HAConnection: M/S间Channel的封装，同时负责MS数据同步逻辑。&lt;/li&gt;\n&lt;li&gt;HAConnection$ReadSocketService： Master 网络读实现类&lt;/li&gt;\n&lt;li&gt;HAConnection$WriteSocketService：Master 网络写实现类&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9f4b11e8cac44a3940e929af0f2f839~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;源码部分\&#34;&gt;源码部分&lt;/h1&gt;\n&lt;h2 id=\&#34;haservice-模块启动\&#34;&gt;HAService 模块启动&lt;/h2&gt;\n&lt;p&gt;HA模块的启动路径在&lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAService#start()&lt;/code&gt;下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// HAService 启动\npublic void start() throws Exception {\n    // master相关\n    this.acceptSocketService.beginAccept();\n    this.acceptSocketService.start();\n    this.groupTransferService.start();  // 同步模式的实现\n    \n    //slave相关\n    this.haClient.start();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;acceptSocketService.beginAccept() : 启动slave的监听服务&lt;/li&gt;\n&lt;li&gt;acceptSocketService.start(): 处理slave的连接事件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;acceptsocketservicebeginaccept\&#34;&gt;acceptSocketService.beginAccept()&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void beginAccept() throws Exception {\n    // 创建 channel\n    this.serverSocketChannel = ServerSocketChannel.open();\n    // 创建 selector\n    this.selector = RemotingUtil.openSelector();\n    // 设置 TCP reuseAddress\n    this.serverSocketChannel.socket().setReuseAddress(true);\n    // 绑定监听端口,默认10912\n    this.serverSocketChannel.socket().bind(this.socketAddressListen);\n    // 设置为非阻塞模式\n    this.serverSocketChannel.configureBlocking(false);\n    // 注册OP_ACCEPT(连接事件)\n    this.serverSocketChannel.register(this.selector, SelectionKey.OP_ACCEPT);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;acceptsocketservicestart\&#34;&gt;acceptSocketService.start()&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic void run() {\n    log.info(this.getServiceName() + &amp;quot; service started&amp;quot;);\n\n    while (!this.isStopped()) {\n        try {\n            // 每1s钟处理一次slave连接事件\n            this.selector.select(1000);\n            Set&amp;lt;SelectionKey&amp;gt; selected = this.selector.selectedKeys();\n\n            if (selected != null) {\n                for (SelectionKey k : selected) {\n                    if ((k.readyOps() &amp;amp; SelectionKey.OP_ACCEPT) != 0) {\n                        // slave的连接channel\n                        SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();\n\n                        if (sc != null) {\n                            HAService.log.info(&amp;quot;HAService receive new connection, &amp;quot; + sc.socket().getRemoteSocketAddress());\n\n                            try {\n                                // 创建一个HAConnection对象，保存slave的Channel\n                                HAConnection conn = new HAConnection(HAService.this, sc);\n                                // 启动HAConnection\n                                conn.start();\n                                // 保存HAConnection到connectionList中\n                                HAService.this.addConnection(conn);\n                            } catch (Exception e) {\n                                log.error(&amp;quot;new HAConnection exception&amp;quot;, e);\n                                sc.close();\n                            }\n                        }\n                    } else {\n                        log.warn(&amp;quot;Unexpected ops in select &amp;quot; + k.readyOps());\n                    }\n                }\n\n                selected.clear();\n            }\n        } catch (Exception e) {\n            log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);\n        }\n    }\n\n    log.info(this.getServiceName() + &amp;quot; service end&amp;quot;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当有新的连接时，会将该连接封装成一个&lt;code&gt;HAConnection&lt;/code&gt;对象，调用&lt;code&gt;HAConnection.start()&lt;/code&gt;方法，然后将连接保存到连接列表中。&lt;/p&gt;\n&lt;p&gt;master如何处理slave的请求以及如何向slave发送消息的逻辑全部在&lt;code&gt;HAConnection&lt;/code&gt;对象里，继续追踪&lt;code&gt;HAConnection#start()&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;haconnection启动\&#34;&gt;HAConnection启动&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void start() {\n    // master处理slave的消息部分\n    this.readSocketService.start();\n    // mastger向slave发送消息部分\n    this.writeSocketService.start();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里分为&lt;code&gt;readSocketService&lt;/code&gt;和&lt;code&gt;writeSocketService&lt;/code&gt;，顾名思义，一个处理slave的读事件，一个处理写事件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;readSocketService : 处理接收到的slave的请求&lt;/li&gt;\n&lt;li&gt;writeSocketService: 负责master向slave同步数据的逻辑&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;master处理slave请求\&#34;&gt;Master处理slave请求&lt;/h3&gt;\n&lt;p&gt;在 &lt;code&gt;store/src/main/java/org/apache/rocketmq/store/ha/HAConnection.run()&lt;/code&gt;中，主要关注这部分逻辑:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;while (!this.isStopped()) {\n    try {\n        // 1s检查一次读请求\n        this.selector.select(1000);\n        // 处理读事件\n        boolean ok = this.processReadEvent();\n        if (!ok) {\n            HAConnection.log.error(&amp;quot;processReadEvent error&amp;quot;);\n            break;\n        }\n\n        // 两次读事件的间隔超过了既定的值，则master和slave的连接失效，跳出循环。\n        long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastReadTimestamp;\n        if (interval &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaHousekeepingInterval()) {\n            log.warn(&amp;quot;ha housekeeping, found this connection[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] expired, &amp;quot; + interval);\n            break;\n        }\n    } catch (Exception e) {\n        HAConnection.log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);\n        break;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;处理读事件的代码：&lt;/p&gt;\n&lt;p&gt;slave发送的消息内容为要拉取的数据的offset，而master接收要这个offset后，含义有两层&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;这个offset表示slave这次要拉取的位置，给master提供参考。&lt;/li&gt;\n&lt;li&gt;这个offset也表示slave以及同步到的位置，可以当作一个ack包的作用。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private boolean processReadEvent() {\n    int readSizeZeroTimes = 0;\n\n    // 若byteBufferRead没有剩余\n    if (!this.byteBufferRead.hasRemaining()) {\n        this.byteBufferRead.flip();\n        this.processPosition = 0;\n    }\n\n    while (this.byteBufferRead.hasRemaining()) {\n        try {\n            int readSize = this.socketChannel.read(this.byteBufferRead);\n            if (readSize &amp;gt; 0) {\n                readSizeZeroTimes = 0;\n                this.lastReadTimestamp = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now();\n                // 超过8字节就处理,因为slave发送的心跳包就是8字节的offset\n                if ((this.byteBufferRead.position() - this.processPosition) &amp;gt;= 8) {\n                    // 获取离byteBufferRead.position()最近的8的整数\n                    int pos = this.byteBufferRead.position() - (this.byteBufferRead.position() % 8);\n                    long readOffset = this.byteBufferRead.getLong(pos - 8);\n                    this.processPosition = pos;\n                    // 更新slave 已拉取的 offset\n                    HAConnection.this.slaveAckOffset = readOffset;\n                    // 假如是第一次拉取的情况\n                    if (HAConnection.this.slaveRequestOffset &amp;lt; 0) {\n                        HAConnection.this.slaveRequestOffset = readOffset;\n                        log.info(&amp;quot;slave[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] request offset &amp;quot; + readOffset);\n                    }\n                    // 通知slave已经更新，更新push2SlaveMaxOffset字段\n                    HAConnection.this.haService.notifyTransferSome(HAConnection.this.slaveAckOffset);\n                }\n            } else if (readSize == 0) {\n                if (++readSizeZeroTimes &amp;gt;= 3) {\n                    break;\n                }\n            } else {\n                log.error(&amp;quot;read socket[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;] &amp;lt; 0&amp;quot;);\n                return false;\n            }\n        } catch (IOException e) {\n            log.error(&amp;quot;processReadEvent exception&amp;quot;, e);\n            return false;\n        }\n    }\n\n    return true;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;master获取到offset后，更新&lt;code&gt;push2SlavemaxOffset&lt;/code&gt;字段，这个字段的作用是表示当前M/S之间已成功同步的位置，在master向slave发送数据时需要。&lt;/p&gt;\n&lt;h2 id=\&#34;master传输数据\&#34;&gt;Master传输数据&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;while (!this.isStopped()) {\n    try {\n        this.selector.select(1000);\n\n        if (-1 == HAConnection.this.slaveRequestOffset) {\n            Thread.sleep(10);\n            continue;\n        }\n\n        // 是否第一次进行传输\n        if (-1 == this.nextTransferFromWhere) {\n            // request为0\n            if (0 == HAConnection.this.slaveRequestOffset) {\n                long masterOffset = HAConnection.this.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();\n                masterOffset = masterOffset - (masterOffset % HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getMappedFileSizeCommitLog());\n\n                if (masterOffset &amp;lt; 0) {\n                    masterOffset = 0;\n                }\n\n                this.nextTransferFromWhere = masterOffset;\n            } else {\n                // slaveRequestOffset != 0\n                this.nextTransferFromWhere = HAConnection.this.slaveRequestOffset;\n            }\n\n            log.info(&amp;quot;master transfer data from &amp;quot; + this.nextTransferFromWhere + &amp;quot; to slave[&amp;quot; + HAConnection.this.clientAddr + &amp;quot;], and slave request &amp;quot; + HAConnection.this.slaveRequestOffset);\n        }\n\n        // 上次传输是否成功\n        if (this.lastWriteOver) {\n            // 距离上次写的时间间隔\n            long interval = HAConnection.this.haService.getDefaultMessageStore().getSystemClock().now() - this.lastWriteTimestamp;\n            // 如果等待时间间隔 &amp;gt; ha心跳时间间隔\n            if (interval &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaSendHeartbeatInterval()) {\n                // Build Header\n                this.byteBufferHeader.position(0);\n                this.byteBufferHeader.limit(headerSize);\n                this.byteBufferHeader.putLong(this.nextTransferFromWhere);\n                this.byteBufferHeader.putInt(0);\n                this.byteBufferHeader.flip();\n                this.lastWriteOver = this.transferData();\n                if (!this.lastWriteOver) continue;\n            }\n        } else {\n            //上次失败，需要进行重新传输\n            this.lastWriteOver = this.transferData();\n            if (!this.lastWriteOver) continue;\n        }\n\n        // 根据nextTransferFromWhere获取commitlog数据\n        SelectMappedBufferResult selectResult = HAConnection.this.haService.getDefaultMessageStore().getCommitLogData(this.nextTransferFromWhere);\n        if (selectResult != null) {\n            int size = selectResult.getSize();\n            if (size &amp;gt; HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) {\n                size = HAConnection.this.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();\n            }\n\n            long thisOffset = this.nextTransferFromWhere;\n            this.nextTransferFromWhere += size;\n\n            selectResult.getByteBuffer().limit(size);\n            this.selectMappedBufferResult = selectResult;\n\n            // Build Header\n            this.byteBufferHeader.position(0);\n            this.byteBufferHeader.limit(headerSize);\n            this.byteBufferHeader.putLong(thisOffset);\n            this.byteBufferHeader.putInt(size);\n            this.byteBufferHeader.flip();\n\n            this.lastWriteOver = this.transferData();\n        } else {\n\n            HAConnection.this.haService.getWaitNotifyObject().allWaitForRunning(100);\n        }\n    } catch (Exception e) {\n\n        HAConnection.log.error(this.getServiceName() + &amp;quot; service has exception.&amp;quot;, e);\n        break;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/438c5aae0acf4ea3b06b92a35b010648~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何接受&lt;code&gt;slave&lt;/code&gt;的请求？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：在readSocketService类中进行OP_READ事件处理。master收到slave发送的的offset，表示slave当前同步的位置，master保存该offset。&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;处理&lt;code&gt;slave&lt;/code&gt;请求时，如何判断哪些数据需要同步？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：slave的请求会携带同步完的offset，master在readSocketService中保存了该offset，后续writeSocketService在执行OP_WRITE事件时，会与 master的offset进行比较，如果有新的数据则发送给slave。&lt;/p&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;&lt;code&gt;master&lt;/code&gt;如何保证发送的数据同步成功的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：ack机制，slave -&amp;gt; master 发送的请求中的offset即代表slave已同步完成的进度，假如slave在同步操作时发送异常，那么未同步成功的数据下一次master会再发送过来。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;关于slave于高级部分在后续文章中更新。&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq491-yuan-ma-fen-xi-ha-mo-kuai-master-du-xie-chu-li&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;从最抽象的角度看，主从同步流程可以分为3个步骤:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;master启动&lt;/li&gt;\n&lt;li&gt;slave的启动&lt;/li&gt;\n&lt;li&gt;m/s 数据同步&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;RocketMQ4.9.1源码分析(HA模块) Master读写处理&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;_Ywd8fi71&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/&#34;},{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;}],&#34;date&#34;:&#34;2021-10-08 01:06:31&#34;,&#34;dateFormat&#34;:&#34;2021-10-08 01:06:31&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-ha-mo-kuai-master-du-xie-chu-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:483000,&#34;words&#34;:1720,&#34;minutes&#34;:9},&#34;description&#34;:&#34;从最抽象的角度看，主从同步流程可以分为3个步骤:\n\nmaster启动\nslave的启动\nm/s 数据同步\n\n\n\n针对上述步骤，结合rocketmq的设计，可以先提一些问题。\n疑问点\nMaster\n\nmaster如何接受slave的请求？\nm...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E7%82%B9\&#34;&gt;疑问点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#master\&#34;&gt;Master&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#slave\&#34;&gt;Slave&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%AB%98%E7%BA%A7\&#34;&gt;高级&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ha%E7%B1%BB\&#34;&gt;HA类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ha%E7%B1%BB%E8%AF%B4%E6%98%8E\&#34;&gt;HA类说明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86\&#34;&gt;源码部分&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#haservice-%E6%A8%A1%E5%9D%97%E5%90%AF%E5%8A%A8\&#34;&gt;HAService 模块启动&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#acceptsocketservicebeginaccept\&#34;&gt;acceptSocketService.beginAccept()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#acceptsocketservicestart\&#34;&gt;acceptSocketService.start()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#haconnection%E5%90%AF%E5%8A%A8\&#34;&gt;HAConnection启动&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#master%E5%A4%84%E7%90%86slave%E8%AF%B7%E6%B1%82\&#34;&gt;Master处理slave请求&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#master%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE\&#34;&gt;Master传输数据&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;half消息属于RocketMQ事务处理的第一个阶段，可以包括两部分：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;producer -&amp;gt; broker 发送half消息&lt;/li&gt;\n&lt;li&gt;broker 处理half消息&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;对应图中的步骤1、2。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bd34b7c086149a298df6672e9c5dda2~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;带着问题看源码, 先提几个问题：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;producer 如何发送 half 消息的？&lt;/li&gt;\n&lt;li&gt;broker 又是如何区分普通消息和事务消息的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!----&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;half消息不会被Consumer消费，是如何实现的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;看完就有答案了。&lt;/p&gt;\n&lt;h1 id=\&#34;producer-half-消息发送\&#34;&gt;Producer Half 消息发送&lt;/h1&gt;\n&lt;p&gt;首先生产者的使用代码如下，要使用事务消息的功能，生产者对象要使用&lt;code&gt;TransactionMQProducer&lt;/code&gt;进行声明。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void main(String[] args) throws MQClientException {\n    // 创建 TransactionMQProducer 实例，并设置生产者组名\n    TransactionMQProducer producer = new TransactionMQProducer(&amp;quot;transactionGroup&amp;quot;);\n    // 设置 NameServer 地址\n    producer.setNamesrvAddr(&amp;quot;127.0.0.1:9876&amp;quot;);\n\n    // 添加事务监听器\n    producer.setTransactionListener(new TransactionListener() {\n        /**\n         * 执行本地事务的方法\n         */\n        @Override\n        public LocalTransactionState executeLocalTransaction(Message message, Object o) {\n            // 执行本地事务\n            doXXX();\n            // 返回执行结果\n            return LocalTransactionState.xxx;\n        }\n\n        /**\n         * 消息回查执行的方法\n         */\n        @Override\n        public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {\n\t\t\t// 回查事务状态\n            findxxx();\n            // 消息来回查的时候，进行提交事务\n            return LocalTransactionState.xxx;\n        }\n    });\n\n    // 启动producer\n    producer.start();\n}\n\n// 发送消息\nSendResult result = producer.sendMessageInTransaction(msg, null);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;和普通消息不同，在37行中使用&lt;code&gt;sendMessageIntransaction()&lt;/code&gt;方法发送事务方法，那么发送的逻辑肯定都在这个方法下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException {\n    // 本地事务处理逻辑必须要先定义好\n    if (null == this.transactionListener) {\n        throw new MQClientException(&amp;quot;TransactionListener is null&amp;quot;, null);\n    }\n\n    // 对topic进行包装,附带延迟、重试标记\n    msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));\n    return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;进入&lt;code&gt;sendMessageInTransaction()&lt;/code&gt;方法, 我们主要关注方法的前半部分：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter localTransactionExecuter, final Object arg) throws MQClientException {\n    TransactionListener transactionListener = getCheckListener();\n    if (null == localTransactionExecuter &amp;amp;&amp;amp; null == transactionListener) {\n        throw new MQClientException(&amp;quot;tranExecutor is null&amp;quot;, null);\n    }\n\n    // ignore DelayTimeLevel parameter\n    if (msg.getDelayTimeLevel() != 0) {\n        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);\n    }\n    Validators.checkMessage(msg, this.defaultMQProducer);\n\n    SendResult sendResult;\n    // 给消息打上TRAN_MSG标记,标记为事务消息\n    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &amp;quot;true&amp;quot;);\n    // 标记生产者组的目的是broker进行回查时需要\n    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());\n    try {\n        // 发送half消息\n        sendResult = this.send(msg);\n    } catch (Exception e) {\n        throw new MQClientException(&amp;quot;send message Exception&amp;quot;, e);\n    }\n    \n    // 略\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到代码里给消息添加了两个属性：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;PROPERTY_TRANSACTION_PREPARED : 标记为事务消息，broker可以根据msg是否有该字段来判断是否是事务消息。&lt;/li&gt;\n&lt;li&gt;PROPERTY_PRODUCER_GROUP : 生产者组，这个在broker进行事务结果回查时候需要。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在对消息进行特殊包装变成事务消息后，调用的&lt;code&gt;send()&lt;/code&gt;方法就是通用的消息发送方法了，所有消息都是通过这个方法进行发送的。&lt;/p&gt;\n&lt;h1 id=\&#34;broker-处理-half-消息\&#34;&gt;Broker 处理 Half 消息&lt;/h1&gt;\n&lt;p&gt;在 broker/src/main/java/org/apache/rocketmq/broker/processor/SendMessageProcessor.java 类中，&lt;code&gt;asyncSendMessage()&lt;/code&gt;方法中有一段代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;...\n// 获取事务属性字段\nString transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n// 判断是否为空 &amp;amp;&amp;amp; 值为true\nif (transFlag != null &amp;amp;&amp;amp; Boolean.parseBoolean(transFlag)) {\n  if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n    response.setCode(ResponseCode.NO_PERMISSION);\n    response.setRemark(&amp;quot;the broker[&amp;quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &amp;quot;] sending transaction message is forbidden&amp;quot;);\n    return CompletableFuture.completedFuture(response);\n  }\n  // 存储prepare消息\n  putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n} else {\n  // 存储普通消息\n  putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n}\n...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看看如果处理prepare消息的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic CompletableFuture&amp;lt;PutMessageResult&amp;gt; asyncPrepareMessage(MessageExtBrokerInner messageInner) {\n    return transactionalMessageBridge.asyncPutHalfMessage(messageInner);  //1 调用asyncPutHalfMessage()方法\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;asyncPrepareMessage()&lt;/code&gt;调用&lt;code&gt;asyncPutHalfMessage()&lt;/code&gt;方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public CompletableFuture&amp;lt;PutMessageResult&amp;gt; asyncPutHalfMessage(MessageExtBrokerInner messageInner) {\n    return store.asyncPutMessage(parseHalfMessageInner(messageInner));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;store.asyncPutMessage()&lt;/code&gt;就是通用的方法，普通消息的存储也是使用这个方法，所以half消息的特殊处理在&lt;code&gt;parseHalfMessageInner()&lt;/code&gt;中&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) {\n    // 备份消息的原主题和原队列ID\n    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());\n    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId()));\n    msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));\n    // 事务消息的topic和queueID是写死固定的\n    msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());\n    msgInner.setQueueId(0);\n    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n    return msgInner;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;分为两部分逻辑&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;备份原有的topic和queueId，将消息真正的topic放在&lt;code&gt;REAL_TOPIC&lt;/code&gt;属性中，queueId放在&lt;code&gt;REAL_QID&lt;/code&gt;属性中&lt;/li&gt;\n&lt;li&gt;使用事务专用的topic和queueId覆盖旧值，topic = &lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;,queueId = 0。这样意味着所有的half消息都会存在同一个topic队列中。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h1 id=\&#34;疑问解答\&#34;&gt;疑问解答&lt;/h1&gt;\n&lt;p&gt;现在可以回答之前的疑惑了&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;producer 如何发送 half 消息的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：RocketMQ对于事务消息，使用了专门的Producer对象&lt;code&gt;TransactionMQProducer&lt;/code&gt;，这个producer的发送消息的方法把消息包装成事务消息。&lt;/p&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;broker 又是如何区分普通消息和事务消息的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：在消息发送的时候，在消息的 &lt;code&gt;property&lt;/code&gt;里添加&lt;code&gt;PROPERTY_TRANSACTION_PREPARED&lt;/code&gt;标记，broker根据和这个标记来区分普通消息和事务消息。&lt;/p&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;half消息不会被Consumer消费，是如何实现的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;答：消息经过特殊处理，都被分配到特有的topic队列中，被隔离了。这样消费者就无法获取到这些消息了。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq491-yuan-ma-fen-xi-_shi-wu-half-ban-xiao-xi-chu-li&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;half消息属于RocketMQ事务处理的第一个阶段，可以包括两部分：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;producer -&amp;gt; broker 发送half消息&lt;/li&gt;\n&lt;li&gt;broker 处理half消息&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;RocketMQ4.9.1源码分析_(事务) Half半消息处理&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;_Ywd8fi71&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/&#34;},{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;}],&#34;date&#34;:&#34;2021-10-05 20:04:53&#34;,&#34;dateFormat&#34;:&#34;2021-10-05 08:04:53&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-_shi-wu-half-ban-xiao-xi-chu-li/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:301000,&#34;words&#34;:1167,&#34;minutes&#34;:6},&#34;description&#34;:&#34;half消息属于RocketMQ事务处理的第一个阶段，可以包括两部分：\n\nproducer -&amp;gt; broker 发送half消息\nbroker 处理half消息\n\n\n对应图中的步骤1、2。\n\n带着问题看源码, 先提几个问题：\n\npro...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#producer-half-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81\&#34;&gt;Producer Half 消息发送&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#broker-%E5%A4%84%E7%90%86-half-%E6%B6%88%E6%81%AF\&#34;&gt;Broker 处理 Half 消息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94\&#34;&gt;疑问解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;启动任务\&#34;&gt;启动任务&lt;/h1&gt;\n&lt;p&gt;broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic void run() {\n    log.info(&amp;quot;Start transaction check service thread!&amp;quot;);\n    long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();  // 默认值为60000，即60s\n    while (!this.isStopped()) {\n        this.waitForRunning(checkInterval);\n    }\n    log.info(&amp;quot;End transaction check service thread!&amp;quot;);\n}\n\n@Override\nprotected void onWaitEnd() {\n    long timeout = brokerController.getBrokerConfig().getTransactionTimeOut();\n    int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();\n    long begin = System.currentTimeMillis();\n    log.info(&amp;quot;Begin to check prepare message, begin time:{}&amp;quot;, begin);\n    // 调用chekc方法\n    this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());\n    log.info(&amp;quot;End to check prepare message, consumed time:{}&amp;quot;, System.currentTimeMillis() - begin);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里采用了模板设计模式，重写了&lt;code&gt;run()&lt;/code&gt;和&lt;code&gt;onWaitEnd()&lt;/code&gt;两个方法，其中可以看到&lt;code&gt;onWaitEnd()&lt;/code&gt;方法中调用了&lt;code&gt;check()&lt;/code&gt;方法，那么在哪里调用了这个onWaitEnd()方法呢？看下&lt;code&gt;waitForRunning()&lt;/code&gt;方法，在&lt;code&gt;src/main/java/org/apache/rocketmq/common/ServiceThread.java&lt;/code&gt;中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;protected void waitForRunning(long interval) {\n    if (hasNotified.compareAndSet(true, false)) {\n        // 调用子类重写的逻辑\n        this.onWaitEnd();\n        return;\n    }\n\n    //entry to wait\n    waitPoint.reset();\n\n    try {\n        // 等待\n        waitPoint.await(interval, TimeUnit.MILLISECONDS);\n    } catch (InterruptedException e) {\n        log.error(&amp;quot;Interrupted&amp;quot;, e);\n    } finally {\n        hasNotified.set(false);\n        this.onWaitEnd();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;总结就是以默认60s的间隔执行一次check()方法，check()方法就是定时回查方法，下面看下。&lt;/p&gt;\n&lt;h1 id=\&#34;check-流程\&#34;&gt;check 流程&lt;/h1&gt;\n&lt;p&gt;broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中,先看下全部的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\n    public void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) {\n        try {\n            // 定义topic为&amp;quot;RMQ_SYS_TRANS_HALF_TOPIC&amp;quot;\n            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n            // 获取half队列\n            Set&amp;lt;MessageQueue&amp;gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\n            if (msgQueues == null || msgQueues.size() == 0) {\n                log.warn(&amp;quot;The queue of topic is empty :&amp;quot; + topic);\n                return;\n            }\n            log.debug(&amp;quot;Check topic={}, queues={}&amp;quot;, topic, msgQueues);\n            for (MessageQueue messageQueue : msgQueues) {\n                long startTime = System.currentTimeMillis();\n                // 获取opQueue\n                MessageQueue opQueue = getOpQueue(messageQueue);\n                // 获取half队列的消费offset\n                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n                // 获取op队列的offset\n                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n                log.info(&amp;quot;Before check, the queue={} msgOffset={} opOffset={}&amp;quot;, messageQueue, halfOffset, opOffset);\n                if (halfOffset &amp;lt; 0 || opOffset &amp;lt; 0) {\n                    log.error(&amp;quot;MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue&amp;quot;, messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n\n                List&amp;lt;Long/*处理过得opQueue的offset*/&amp;gt; doneOpOffset = new ArrayList&amp;lt;&amp;gt;();\n                HashMap&amp;lt;Long/*halfQueue offset*/, Long/*opQueue offset*/&amp;gt; removeMap = new HashMap&amp;lt;&amp;gt;();  //存储已经处理过,但还未添加到doneOpOffset中的消息\n                // 将已处理但未更新的消息保存到removeMap中，后续进行判断时需要\n                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n                if (null == pullResult) {\n                    log.error(&amp;quot;The queue={} check msgOffset={} with opOffset={} failed, pullResult is null&amp;quot;, messageQueue, halfOffset, opOffset);\n                    continue;\n                }\n                int getMessageNullCount = 1;  //获取空消息的次数\n                long newOffset = halfOffset;  //当前处理half队列的最新进度\n                long i = halfOffset; //当前处理消息的half队列偏移量\n                while (true) {\n                    // 检查当前任务的时间片是否用完\n                    if (System.currentTimeMillis() - startTime &amp;gt; MAX_PROCESS_TIME_LIMIT) {\n                        log.info(&amp;quot;Queue={} process time reach max={}&amp;quot;, messageQueue, MAX_PROCESS_TIME_LIMIT);\n                        break;\n                    }\n                    // 如果half消息已经被处理过,继续处理下一条消息\n                    if (removeMap.containsKey(i)) {\n                        log.debug(&amp;quot;Half offset {} has been committed/rolled back&amp;quot;, i);\n                        Long removedOpOffset = removeMap.remove(i);\n                        doneOpOffset.add(removedOpOffset);\n                    } else {\n                        // 根据half队列消费offset获取消息\n                        GetResult getResult = getHalfMsg(messageQueue, i);\n                        MessageExt msgExt = getResult.getMsg();\n                        if (msgExt == null) {\n                            // 是否最大重试次数\n                            if (getMessageNullCount++ &amp;gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n                                break;\n                            }\n                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n                                log.debug(&amp;quot;No new msg, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                break;\n                            } else {\n                                log.info(&amp;quot;Illegal offset, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());\n                                i = getResult.getPullResult().getNextBeginOffset();\n                                newOffset = i;\n                                continue;\n                            }\n                        }\n\n                        // 如果超过存储时间(默认3天)或者超过回查时间(默认15次)\n                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n                            listener.resolveDiscardMsg(msgExt);\n                            newOffset = i + 1;\n                            i++;\n                            continue;\n                        }\n\n                        // 如果存储时间大于开始时间，不处理\n                        if (msgExt.getStoreTimestamp() &amp;gt;= startTime) {\n                            log.debug(&amp;quot;Fresh stored. the miss offset={}, check it later, store={}&amp;quot;, i, new Date(msgExt.getStoreTimestamp()));\n                            break;\n                        }\n\n                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();  //消息已存储时间\n                        long checkImmunityTime = transactionTimeout; //立即检测事务消息的时间\n                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS); //获取消息的最晚回查时间\n                        if (null != checkImmunityTimeStr) {\n                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n                            // 如果未到回查时间，不处理\n                            if (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime) {\n                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                                    newOffset = i + 1;\n                                    i++;\n                                    continue;\n                                }\n                            }\n                        } else {\n                            if ((0 &amp;lt;= valueOfCurrentMinusBorn) &amp;amp;&amp;amp; (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime)) {\n                                log.debug(&amp;quot;New arrived, the miss offset={}, check it later checkImmunity={}, born={}&amp;quot;, i, checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n                                break;\n                            }\n                        }\n\n                        // 获取消息列表\n                        List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();\n                        // 判断是否需要进行回查\n                        boolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime) || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout)) || (valueOfCurrentMinusBorn &amp;lt;= -1);\n                        if (isNeedCheck) {\n                            // 消息重新put到halfQueue中\n                            if (!putBackHalfMsgQueue(msgExt, i)) {\n                                continue;\n                            }\n                            // 执行回查\n                            listener.resolveHalfMsg(msgExt);\n                        } else {\n                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n                            log.debug(&amp;quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&amp;quot;, i, messageQueue, pullResult);\n                            continue;\n                        }\n                    }\n                    newOffset = i + 1;\n                    i++;\n                }\n                if (newOffset != halfOffset) {\n                    // 更新halfQueue消费进度\n                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n                }\n                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\n                if (newOpOffset != opOffset) {\n                    // 更新opQueue消费进度\n                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n                }\n            }\n        } catch (Throwable e) {\n            log.error(&amp;quot;Check error&amp;quot;, e);\n        }\n\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码太多了，一个个拆解分析：&lt;/p&gt;\n&lt;h2 id=\&#34;获取half队列\&#34;&gt;获取half队列&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 定义topic为&amp;quot;RMQ_SYS_TRANS_HALF_TOPIC&amp;quot;\nString topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;\n// 获取half队列\nSet&amp;lt;MessageQueue&amp;gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);\nif (msgQueues == null || msgQueues.size() == 0) {\n    log.warn(&amp;quot;The queue of topic is empty :&amp;quot; + topic);\n    return;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在rocketmq中，所有事务消息会保存在两个topic队列中，分别是&lt;code&gt;RMQ_SYS_TRANS_HALF_TOPIC&lt;/code&gt;（简称halfQueue）和&lt;code&gt;RMQ_SYS_TRANS_OP _HALF _TOPIC&lt;/code&gt;（简称opQueue）&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;RMQ_SYS_TRANS _HALF _TOPIC : 保存 half 消息&lt;/li&gt;\n&lt;li&gt;RMQ_SYS_TRANS_OP _HALF _TOPIC : 当 half消息收到 commit/rollback 后，会保存到opQueue中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;定义偏移量\&#34;&gt;定义偏移量&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 开始时间\nlong startTime = System.currentTimeMillis();\n// 获取opQueue\nMessageQueue opQueue = getOpQueue(messageQueue);\n// 获取half队列的消费offset\nlong halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);\n// 获取op队列的offset\nlong opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;startTime : 作用是记录当前时间，后续在判断任务的执行时间时需要&lt;/li&gt;\n&lt;li&gt;opQueue : 即&lt;code&gt;RMQ_SYS_TRANS_OP_HALF_TOPIC&lt;/code&gt;队列，保存已处理过的消息。&lt;/li&gt;\n&lt;li&gt;halfOffset ： halfQueue 中的消费记录位置，可以保证的halfOffset之后的消息才需要进行回查操作&lt;/li&gt;\n&lt;li&gt;opOffset : opQueue中的消费记录，大于opOffset的消息就是距离上次定时回查任务结束后，这段时间新增的消息。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;标记已处理消息\&#34;&gt;标记已处理消息&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;List&amp;lt;Long/*处理过得opQueue的offset*/&amp;gt; doneOpOffset = new ArrayList&amp;lt;&amp;gt;();\nHashMap&amp;lt;Long/*halfQueue offset*/, Long/*opQueue offset*/&amp;gt; removeMap = new HashMap&amp;lt;&amp;gt;();  //存储已经处理过,但还未添加到doneOpOffset中的消息\n// 将已处理但未更新的消息保存到removeMap中，后续进行判断时需要\nPullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;doneOpOffset: 保存opQueue中已经处理过得消息的offset，后续更新opQueue的offset时候要使用&lt;/li&gt;\n&lt;li&gt;removeMap : 保存已经保存到opQueue中，但仍在halfQueue中的消息，后续判断消息是否需要回查时的依据之一。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;fillopremove\&#34;&gt;fillOpRemove()&lt;/h3&gt;\n&lt;p&gt;方法的目的就是填充已处理的消息到 removeMap&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private PullResult fillOpRemoveMap(HashMap&amp;lt;Long, Long&amp;gt; removeMap, MessageQueue opQueue, long pullOffsetOfOp, long miniOffset, List&amp;lt;Long&amp;gt; doneOpOffset) {\n    // step1 : 获取op消息,拉取32条消息\n    PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, 32);\n    if (null == pullResult) {\n        return null;\n    }\n    // step2 : 判断状态\n    if (pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) {\n        log.warn(&amp;quot;The miss op offset={} in queue={} is illegal, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);\n        transactionalMessageBridge.updateConsumeOffset(opQueue, pullResult.getNextBeginOffset());\n        return pullResult;\n    } else if (pullResult.getPullStatus() == PullStatus.NO_NEW_MSG) { //没有新消息\n        log.warn(&amp;quot;The miss op offset={} in queue={} is NO_NEW_MSG, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);\n        return pullResult;\n    }\n    List&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();\n    if (opMsg == null) {\n        log.warn(&amp;quot;The miss op offset={} in queue={} is empty, pullResult={}&amp;quot;, pullOffsetOfOp, opQueue, pullResult);\n        return pullResult;\n    }\n    // step3 : 遍历所有消息\n    for (MessageExt opMessageExt : opMsg) {\n        // 获取opQueue的offset\n        Long queueOffset = getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));\n        log.debug(&amp;quot;Topic: {} tags: {}, OpOffset: {}, HalfOffset: {}&amp;quot;, opMessageExt.getTopic(), opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);\n        if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) {\n            if (queueOffset &amp;lt; miniOffset) {\n                // 正常情况，opQueue里的消息在halfQueue中offset要小于当前halfQueue的offset\n                doneOpOffset.add(opMessageExt.getQueueOffset());\n            } else {\n                // 消息已经存储到opQueue中，但是halfQueue中的offset还没有更新\n                // 保存到removeMap中，防止后续重复进行回查操作\n                removeMap.put(queueOffset, opMessageExt.getQueueOffset());\n            }\n        } else {\n            log.error(&amp;quot;Found a illegal tag in opMessageExt= {} &amp;quot;, opMessageExt);\n        }\n    }\n    log.debug(&amp;quot;Remove map: {}&amp;quot;, removeMap);\n    log.debug(&amp;quot;Done op list: {}&amp;quot;, doneOpOffset);\n    return pullResult;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;定义变量\&#34;&gt;定义变量&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;int getMessageNullCount = 1;  //获取空消息的次数\nlong newOffset = halfOffset;  //当前处理half队列的最新进度\nlong i = halfOffset; //当前处理消息的half队列偏移量\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;getMessageNullCount : rocketMQ允许进行重试，该字段是重试次数判断的依据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;判断是否满足回查条件\&#34;&gt;判断是否满足回查条件&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 检查当前任务的时间片是否用完\nif (System.currentTimeMillis() - startTime &amp;gt; MAX_PROCESS_TIME_LIMIT) {\n    log.info(&amp;quot;Queue={} process time reach max={}&amp;quot;, messageQueue, MAX_PROCESS_TIME_LIMIT);\n    break;\n}\n// 如果half消息已经被处理过,继续处理下一条消息\nif (removeMap.containsKey(i)) {\n    log.debug(&amp;quot;Half offset {} has been committed/rolled back&amp;quot;, i);\n    Long removedOpOffset = removeMap.remove(i);\n    doneOpOffset.add(removedOpOffset);\n} else {\n    // 根据half队列消费offset获取消息\n    GetResult getResult = getHalfMsg(messageQueue, i);\n    MessageExt msgExt = getResult.getMsg();\n    if (msgExt == null) {\n        // 是否最大重试次数\n        if (getMessageNullCount++ &amp;gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) {\n            break;\n        }\n        if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) {\n            log.debug(&amp;quot;No new msg, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());\n            break;\n        } else {\n            log.info(&amp;quot;Illegal offset, the miss offset={} in={}, continue check={}, pull result={}&amp;quot;, i, messageQueue, getMessageNullCount, getResult.getPullResult());\n            i = getResult.getPullResult().getNextBeginOffset();\n            newOffset = i;\n            continue;\n        }\n    }\n\n    // 如果超过存储时间(默认3天)或者超过回查时间(默认15次)\n    if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {\n        listener.resolveDiscardMsg(msgExt);\n        newOffset = i + 1;\n        i++;\n        continue;\n    }\n\n    // 如果存储时间大于开始时间，不处理\n    if (msgExt.getStoreTimestamp() &amp;gt;= startTime) {\n        log.debug(&amp;quot;Fresh stored. the miss offset={}, check it later, store={}&amp;quot;, i, new Date(msgExt.getStoreTimestamp()));\n        break;\n    }\n\n    long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();  //消息已存储时间\n    long checkImmunityTime = transactionTimeout; //立即检测事务消息的时间\n    String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS); //获取消息的最晚回查时间\n    if (null != checkImmunityTimeStr) {\n        checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);\n        // 如果未到回查时间，不处理\n        if (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime) {\n            if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) {\n                newOffset = i + 1;\n                i++;\n                continue;\n            }\n        }\n    } else {\n        if ((0 &amp;lt;= valueOfCurrentMinusBorn) &amp;amp;&amp;amp; (valueOfCurrentMinusBorn &amp;lt; checkImmunityTime)) {\n            log.debug(&amp;quot;New arrived, the miss offset={}, check it later checkImmunity={}, born={}&amp;quot;, i, checkImmunityTime, new Date(msgExt.getBornTimestamp()));\n            break;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;任务时间片机制：在rocketmq中，有一种通用的设计方案就是给任务分配时间片， 如果时间片用完则直接退出。&lt;/p&gt;\n&lt;h2 id=\&#34;执行回查\&#34;&gt;执行回查&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 获取消息列表\nList&amp;lt;MessageExt&amp;gt; opMsg = pullResult.getMsgFoundList();\n// 判断是否需要进行回查\nboolean isNeedCheck = (opMsg == null &amp;amp;&amp;amp; valueOfCurrentMinusBorn &amp;gt; checkImmunityTime) || (opMsg != null &amp;amp;&amp;amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &amp;gt; transactionTimeout)) || (valueOfCurrentMinusBorn &amp;lt;= -1);\nif (isNeedCheck) {\n    // 消息重新put到halfQueue中\n    if (!putBackHalfMsgQueue(msgExt, i)) {\n        continue;\n    }\n    // 执行回查\n    listener.resolveHalfMsg(msgExt);\n} else {\n    pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);\n    log.debug(&amp;quot;The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}&amp;quot;, i, messageQueue, pullResult);\n    continue;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中比较重要的两个部分，&lt;code&gt;putBackHalfMsgQueue()&lt;/code&gt;和&lt;code&gt;resolveHalfMsg()&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;putbackhalfmsgqueue\&#34;&gt;putBackHalfMsgQueue()&lt;/h3&gt;\n&lt;p&gt;这里消息会重写追加到commitlog中，设计巧妙之处：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;发送回查的接口是异步的，将消息重写追加到队列中，下一次回查的时候还能获取到该消息。如果回查有结果，消息就会保存到opQueue中，这样也会在fillOpRemove()中被过滤掉，不影响。&lt;/li&gt;\n&lt;li&gt;每次进行回查消息都要修改消息的回查次数属性，使用顺序写的性能要高于修改已存储消息的性能。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private boolean putBackHalfMsgQueue(MessageExt msgExt, long offset) {\n    // 再次将消息存储到commitlog中\n    PutMessageResult putMessageResult = putBackToHalfQueueReturnResult(msgExt);\n    // 存储成功修改消息的属性\n    if (putMessageResult != null &amp;amp;&amp;amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {\n        // 设置新的消费队列逻辑offset\n        msgExt.setQueueOffset(putMessageResult.getAppendMessageResult().getLogicsOffset());\n        // 设置新的commitlog的offset\n        msgExt.setCommitLogOffset(putMessageResult.getAppendMessageResult().getWroteOffset());\n        // 设置新的msgId\n        msgExt.setMsgId(putMessageResult.getAppendMessageResult().getMsgId());\n        log.debug(&amp;quot;Send check message, the offset={} restored in queueOffset={} &amp;quot; + &amp;quot;commitLogOffset={} &amp;quot; + &amp;quot;newMsgId={} realMsgId={} topic={}&amp;quot;, offset, msgExt.getQueueOffset(), msgExt.getCommitLogOffset(), msgExt.getMsgId(), msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX), msgExt.getTopic());\n        return true;\n    } else {\n        log.error(&amp;quot;PutBackToHalfQueueReturnResult write failed, topic: {}, queueId: {}, &amp;quot; + &amp;quot;msgId: {}&amp;quot;, msgExt.getTopic(), msgExt.getQueueId(), msgExt.getMsgId());\n        return false;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;更新索引\&#34;&gt;更新索引&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;if (newOffset != halfOffset) {\n    // 更新halfQueue消费进度\n    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);\n}\n// 根据doneOpOffset 列表获取opQueue的offset\nlong newOpOffset = calculateOpOffset(doneOpOffset, opOffset);\nif (newOpOffset != opOffset) {\n    // 更新opQueue消费进度\n    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;calculateOpOffset()&lt;/code&gt;方法简单说返回就是doneOffset列表中最后一个值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private long calculateOpOffset(List&amp;lt;Long&amp;gt; doneOffset, long oldOffset) {\n    Collections.sort(doneOffset);\n    long newOffset = oldOffset;\n    for (int i = 0; i &amp;lt; doneOffset.size(); i++) {\n        if (doneOffset.get(i) == newOffset) {\n            newOffset++;\n        } else {\n            break;\n        }\n    }\n    return newOffset;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c075a3fc1d8440d5abf8ad13e2622179~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;rocketmq491-yuan-ma-fen-xi-_shi-wu-broker-ding-shi-hui-cha&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;启动任务\&#34;&gt;启动任务&lt;/h1&gt;\n&lt;p&gt;broker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;RocketMQ4.9.1源码分析_(事务)broker定时回查&#34;,&#34;tags&#34;:[{&#34;index&#34;:-1,&#34;name&#34;:&#34;RocketMQ&#34;,&#34;slug&#34;:&#34;_Ywd8fi71&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/&#34;},{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;}],&#34;date&#34;:&#34;2021-10-01 21:02:08&#34;,&#34;dateFormat&#34;:&#34;2021-10-01 09:02:08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-_shi-wu-broker-ding-shi-hui-cha/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;14 min read&#34;,&#34;time&#34;:805000,&#34;words&#34;:2731,&#34;minutes&#34;:14},&#34;description&#34;:&#34;启动任务\nbroker/src/main/java/org/apache/rocketmq/broker/transaction/queue/TransactionalMessageServiceImpl.java类中。\n\n@Overrid...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1\&#34;&gt;启动任务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#check-%E6%B5%81%E7%A8%8B\&#34;&gt;check 流程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96half%E9%98%9F%E5%88%97\&#34;&gt;获取half队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89%E5%81%8F%E7%A7%BB%E9%87%8F\&#34;&gt;定义偏移量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%87%E8%AE%B0%E5%B7%B2%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF\&#34;&gt;标记已处理消息&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#fillopremove\&#34;&gt;fillOpRemove()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F\&#34;&gt;定义变量&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E5%9B%9E%E6%9F%A5%E6%9D%A1%E4%BB%B6\&#34;&gt;判断是否满足回查条件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A7%E8%A1%8C%E5%9B%9E%E6%9F%A5\&#34;&gt;执行回查&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#putbackhalfmsgqueue\&#34;&gt;putBackHalfMsgQueue()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95\&#34;&gt;更新索引&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;项目地址：&lt;a href=\&#34;https://github.com/zexho994/River\&#34;&gt;https://github.com/zexho994/River&lt;/a&gt;&lt;br&gt;\n实现目标：支持和JDK Stream一样的功能, 提供与Stream一样的API，后续会进行更多的API扩展。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th&gt;类型&lt;/th&gt;\n&lt;th&gt;方法&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td&gt;创建操作&lt;/td&gt;\n&lt;td&gt;of(T...t)&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;中间操作&lt;/td&gt;\n&lt;td&gt;map()limit()sort()peek()skip()filter()distinct()&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;终结操作&lt;/td&gt;\n&lt;td&gt;toArray()reduce()collect()max()anyMatch()findFirst()等&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;同时River还需要具备延迟处理（遇到终结操作才触发）的特性。&lt;/p&gt;\n&lt;h2 id=\&#34;顶层接口-river\&#34;&gt;顶层接口-River&lt;/h2&gt;\n&lt;p&gt;在river接口中定义好所有需要支持的方法api&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface River&amp;lt;E&amp;gt; {\n\n    //===============================创建操作=====================================\n\n    @SafeVarargs\n    static &amp;lt;T&amp;gt; River&amp;lt;T&amp;gt; of(T... t) {\n        return RiverGenerator.create(t);\n    }\n\n    static &amp;lt;T&amp;gt; River&amp;lt;T&amp;gt; of(Collection&amp;lt;T&amp;gt; collection) {\n        return RiverGenerator.create(collection);\n    }\n\n    //===============================中间操作=====================================\n\n    /**\n     * 将流转换为并行流\n     *\n     * @return River\n     */\n    River&amp;lt;E&amp;gt; parallel();\n\n    /**\n     * 将流转换为串行流\n     *\n     * @return River\n     */\n    River&amp;lt;E&amp;gt; sequential();\n\n    /**\n     * 过滤操作\n     *\n     * @param predicate 过滤的表达式\n     * @return 过滤后的River\n     */\n    River&amp;lt;E&amp;gt; filter(Predicate&amp;lt;E&amp;gt; predicate);\n\n    /**\n     * 元素去重操作\n     *\n     * @return 去重后的River\n     */\n    River&amp;lt;E&amp;gt; distinct();\n\n    /**\n     * 限制River的元素数量\n     *\n     * @param size 元素的最大数量\n     * @return River\n     */\n    River&amp;lt;E&amp;gt; limit(int size);\n\n    /**\n     * 排序\n     *\n     * @param comparable 比较器\n     * @return 添加排序后的River\n     */\n    River&amp;lt;E&amp;gt; sort(Comparator&amp;lt;E&amp;gt; comparable);\n\n    /**\n     * 对元素进行预操作\n     *\n     * @param consumer 执行的操作\n     * @return 新River\n     */\n    River&amp;lt;E&amp;gt; peek(Consumer&amp;lt;E&amp;gt; consumer);\n\n    /**\n     * 跳过指定数量的元素\n     *\n     * @param size 要跳过的元素数\n     * @return new River\n     */\n    River&amp;lt;E&amp;gt; skip(int size);\n\n    /**\n     * 元素转换映射\n     *\n     * @param function 映射执行逻辑\n     * @return new River\n     */\n    &amp;lt;E_OUT&amp;gt; River&amp;lt;E_OUT&amp;gt; map(Function&amp;lt;? super E, ? extends E_OUT&amp;gt; function);\n\n    //===============================终结操作=====================================\n\n    /**\n     * 遍历River所有元素\n     *\n     * @param consumer 表达式\n     */\n    void forEach(Consumer&amp;lt;E&amp;gt; consumer);\n\n    /**\n     * 输出一个数组\n     *\n     * @return E类型的数组\n     */\n    Object[] toArray();\n\n    /**\n     * 输出元素到参数数组中\n     *\n     * @param e 承载元素的数组\n     */\n    void toArray(E[] e);\n\n    /**\n     * 计算元素的数量\n     *\n     * @return River中元素的数量\n     */\n    long count();\n\n    /**\n     * 操作\n     *\n     * @param identity    初始值\n     * @param accumulator 操作函数\n     * @return reduce result\n     */\n    E reduce(E identity, BinaryOperator&amp;lt;E&amp;gt; accumulator);\n\n    /**\n     * 执行操作\n     *\n     * @param collector 执行操作的收集器\n     * @param &amp;lt;R&amp;gt;       结果类型\n     * @param &amp;lt;A&amp;gt;       中间累加类型\n     * @return 执行结果\n     */\n    &amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super E, A, R&amp;gt; collector);\n\n    /**\n     * 获取比较后，最小的元素\n     *\n     * @param comparator 比较器\n     * @return 最小的元素\n     */\n    Optional&amp;lt;E&amp;gt; min(Comparator&amp;lt;? super E&amp;gt; comparator);\n\n    /**\n     * 获取比较后，最大的元素\n     *\n     * @param comparator 比较器\n     * @return 最大的元素\n     */\n    Optional&amp;lt;E&amp;gt; max(Comparator&amp;lt;? super E&amp;gt; comparator);\n\n    /**\n     * 判断匹配，任意即可\n     *\n     * @param predicate\n     * @return true:match success\n     */\n    boolean anyMatch(Predicate&amp;lt;? super E&amp;gt; predicate);\n\n    /**\n     * 判断匹配，所有都要匹配\n     *\n     * @param predicate\n     * @return\n     */\n    boolean allMatch(Predicate&amp;lt;? super E&amp;gt; predicate);\n\n    /**\n     * 判断匹配，都不要匹配上\n     *\n     * @param predicate\n     * @return\n     */\n    boolean noneMatch(Predicate&amp;lt;? super E&amp;gt; predicate);\n\n    /**\n     * 获取第一个元素\n     *\n     * @return\n     */\n    Optional&amp;lt;E&amp;gt; findFirst();\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;river实现类-abstractriverpipeline\&#34;&gt;River实现类 - AbstractRiverPipeline&lt;/h2&gt;\n&lt;p&gt;River接口的实现主要都在&lt;code&gt;AbstractRiverPipeline&lt;/code&gt;类中, 以&lt;code&gt;filter()&lt;/code&gt;为例，返回了一个新的River对象，典型的流式编程的实现方式。&lt;/p&gt;\n&lt;p&gt;方法事情主要两个：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;new一个新的River的实现类。&lt;/li&gt;\n&lt;li&gt;在&lt;code&gt;accept()&lt;/code&gt;方法中实现&lt;code&gt;wrapSink()&lt;/code&gt;,这个方法在后续构建&lt;code&gt;SinkChain&lt;/code&gt;时候需要调用。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class AbstractRiverPipeline&amp;lt;I, O&amp;gt;\n        extends Pipeline&amp;lt;I, O&amp;gt; implements River&amp;lt;O&amp;gt; {\n    \n    //存储元素的spliterator对象引用\n    protected Spliterator sourceSpliterator;\n\n    ...\n        \n    /**\n     * 追加filter操作\n     * 创建一个filter的{@link PipelineStage},然后将该stage追到到Pipeline的尾部\n     *\n     * @param predicate 过滤的表达式\n     * @return 新增的filter对象\n     */\n    @Override\n    public River&amp;lt;O&amp;gt; filter(Predicate&amp;lt;O&amp;gt; predicate) {\n        return new PipelineStage&amp;lt;O, O&amp;gt;(this) {\n            @Override\n            public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {\n                SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {\n                    @Override\n                    public void accept(O t) {\n                        if (!predicate.test(t)) {\n                            return;\n                        }\n                        getNext().accept(t);\n                    }\n                };\n                sinkChain.setNext(sink);\n                return sinkChain;\n            }\n        };\n    }\n    \n    ...\n        \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回的对象是&lt;code&gt;PipelineStage&lt;/code&gt;，是River的子类，扩展了一些于Sink相关的方法。&lt;/p&gt;\n&lt;h2 id=\&#34;阶段封装-pipelinestage\&#34;&gt;阶段封装-PipelineStage&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;PipelineStage&lt;/code&gt;表示一个阶段，什么是阶段？调用filter()后，就相当整个链中添加了一个阶段，可以理解为链表中的节点。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class PipelineStage&amp;lt;I, O&amp;gt; extends AbstractRiverPipeline&amp;lt;I, O&amp;gt; {\n\n    public PipelineStage(Spliterator&amp;lt;I&amp;gt; spliterator) {\n        this.setSourceSpliterator(spliterator);\n        this.isParallel = false;\n    }\n\n    /**\n     * @param river 上一个stage\n     */\n    public PipelineStage(AbstractRiverPipeline&amp;lt;?, I&amp;gt; river) {\n        previous = river;\n        isParallel = river.isParallel;\n        sourceSpliterator = river.sourceSpliterator;\n    }\n\n    public Object[] getArray() {\n        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);\n    }\n\n    public Object getState() {\n        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);\n    }\n\n    public void setState(O s) {\n    }\n\n    @Override\n    public PipelineStage&amp;lt;I, O&amp;gt; clone() {\n        throw new UnsupportedOperationException(&amp;quot;to override&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;不过stage中基于前驱指针previous链接的，所以后续wrapSink时候也是，也是从尾到头的方式。&lt;/p&gt;\n&lt;p&gt;假设我们的代码是这样&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;River.of(1,2,3).filter().distinct()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;of()操作生成第一个stage，filter()操作生成第二个stage，distinct()操作生成第三个stage。整体看下来就是这样：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92d0302e7b640c9a65d8ad5b70fdaab~tplv-k3u1fbpfcp-watermark.image?\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;head阶段生成-rivergenerator\&#34;&gt;Head阶段生成-RiverGenerator&lt;/h2&gt;\n&lt;p&gt;head是指第一个River对象，也可以表示为stage0。River接口中默认实现了of()方法，调用的就是&lt;code&gt;RiverGenerator.create()&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static &amp;lt;E&amp;gt; River&amp;lt;E&amp;gt; create(E... e) {\n    Spliterator&amp;lt;E&amp;gt; spliterator = Arrays.spliterator(e);\n    PipelineStage&amp;lt;E, E&amp;gt; head = new PipelineStage&amp;lt;E, E&amp;gt;(spliterator) {\n        @Override\n        public SinkChain&amp;lt;E, E&amp;gt; wrapSink(SinkChain&amp;lt;E, ?&amp;gt; sink) {\n            SinkChain&amp;lt;E, E&amp;gt; sinkChain = new SinkChain&amp;lt;E, E&amp;gt;() {\n                @Override\n                public void accept(E t) {\n                    next.accept(t);\n                }\n            };\n            sinkChain.setNext(sink);\n            return sinkChain;\n        }\n    };\n    head.setSourceSpliterator(spliterator);\n    return head;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;流的处理链-sinkchain\&#34;&gt;流的处理链-SinkChain&lt;/h2&gt;\n&lt;p&gt;任何时候，在调用终结操作之前，一切操作都只是通过stage链连接在一起，并没有进行任何实际的处理操作，这就需要一个开关来启动流，这个开关放在了所有终结操作中,看下&lt;code&gt;AbstractRiverPipeline.forEach()&lt;/code&gt;方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\n    public void forEach(Consumer&amp;lt;O&amp;gt; consumer) {\n        PipelineStage&amp;lt;O, O&amp;gt; stage = new PipelineStage&amp;lt;O, O&amp;gt;(this) {\n            @Override\n            public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {\n                return new SinkChain&amp;lt;O, O&amp;gt;() {\n                    @Override\n                    public void accept(O t) {\n                        consumer.accept(t);\n                    }\n                };\n            }\n        };\n        // 启动流的开关\n        evaluate(stage);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;evaluate()&lt;/code&gt;主要做两件事：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;将所有stage包装成&lt;code&gt;SinkChain&lt;/code&gt;。（对相关名词概念不清楚的可以看之前的Stream源码解析文章）&lt;/li&gt;\n&lt;li&gt;启动流，对所有元素进行处理。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private void evaluate(PipelineStage&amp;lt;?, O&amp;gt; stage) {\n    //构建处理链\n    SinkChain&amp;lt;O, O&amp;gt; sinkHead = warpPipeline(stage);\n\n    //开始处理\n    sinkHead.begin(-1);\n    //遍历元素\n    sinkHead.getSourceSpliterator().forEachRemaining(sinkHead);\n    sinkHead.end();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;包装-wrappipeline\&#34;&gt;包装 - wrapPipeline&lt;/h3&gt;\n&lt;p&gt;顺序是从尾到头进行的，返回的sink是第一个阶段。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private SinkChain&amp;lt;O, O&amp;gt; warpPipeline(AbstractRiverPipeline river) {\n    SinkChain&amp;lt;O, O&amp;gt; sink = null;\n    for (; river != null; river = river.previous) {\n        sink = river.wrapSink(sink);\n    }\n    return sink;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里的&lt;code&gt;wrapSink()&lt;/code&gt;的逻辑对应的就是&lt;code&gt;AbstractRiverPipeline&lt;/code&gt;中重写的逻辑&lt;/p&gt;\n&lt;p&gt;这样返回的对象就是一条sink链了，并且链中每一个sink都有自己的&lt;code&gt;begin()&lt;/code&gt;、&lt;code&gt;accept()&lt;/code&gt;、&lt;code&gt;end()&lt;/code&gt;方法。&lt;/p&gt;\n&lt;h3 id=\&#34;流的运行流程\&#34;&gt;流的运行流程&lt;/h3&gt;\n&lt;p&gt;evaluate第二部分的工作是运行流&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;首先调用&lt;code&gt;begin()&lt;/code&gt;方法，从头到尾执行一遍所有对象的&lt;code&gt;begin()&lt;/code&gt;方法，主要作用是进行初始化。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;forEachRemaining&lt;/code&gt;的作用就是对数据源spliterator元素执行&lt;code&gt;accept()&lt;/code&gt;方法，可以从头倒尾一个个执行。&lt;/li&gt;\n&lt;li&gt;最后调用&lt;code&gt;end()&lt;/code&gt;方法，从头到尾执行一遍，主要目的是数据的情况，字段设为null等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;依然用上面的&lt;code&gt;filter()&lt;/code&gt;方法和&lt;code&gt;distinct()&lt;/code&gt;为例:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic River&amp;lt;O&amp;gt; filter(Predicate&amp;lt;O&amp;gt; predicate) {\n    return new PipelineStage&amp;lt;O, O&amp;gt;(this) {\n        @Override\n        public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {\n            SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {\n                @Override\n                public void accept(O t) {\n                    // 如果不符合要求，不再向后传递该元素，该元素的处理到此为止\n                    if (!predicate.test(t)) {\n                        return;\n                    }\n                    //如何要求则调用下一个sink的accept()方法\n                    getNext().accept(t);\n                }\n            };\n            sinkChain.setNext(sink);\n            return sinkChain;\n        }\n    };\n}\n\n@Override\npublic River&amp;lt;O&amp;gt; distinct() {\n    return new PipelineStage&amp;lt;O, O&amp;gt;(this) {\n        @Override\n        public SinkChain&amp;lt;O, O&amp;gt; wrapSink(SinkChain&amp;lt;O, ?&amp;gt; sink) {\n            SinkChain&amp;lt;O, O&amp;gt; sinkChain = new SinkChain&amp;lt;O, O&amp;gt;() {\n                private HashSet&amp;lt;O&amp;gt; set;\n\n                @Override\n                public void begin(int n) {\n                    //执行初始化工作\n                    this.set = new HashSet&amp;lt;&amp;gt;(n &amp;gt; 0 ? n : 16);\n                    //调用下一个sink的begin()方法\n                    super.begin(n);\n                }\n\n                @Override\n                public void end() {\n                    this.set = null;\n                    super.end();\n                }\n\n                @Override\n                public void accept(O t) {\n                    if (!set.add(t)) {\n                        return;\n                    }\n                    getNext().accept(t);\n                }\n            };\n            sinkChain.setNext(sink);\n            return sinkChain;\n        }\n    };\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结&lt;/h2&gt;\n&lt;p&gt;文章只是列举了一些关键步骤的设计与实现，设计的思路大多数来源于JDK Stream的源码，如何实现一个Stream，主要的目的是可以更好的理解Stream一些地方为什么要那么设计，因为只有在自己开发的时候才能体会到设计的精妙。&lt;/p&gt;\n&lt;p&gt;项目的源码在github，测试代码在test包下，目前只支持串行流，后续会添加并行流的支持，并且提供更多的API，让River可以进行更多更强大的操作。&lt;/p&gt;\n&lt;p&gt;项目地址：&lt;a href=\&#34;https://github.com/zexho994/River\&#34;&gt;https://github.com/zexho994/River&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;shou-xie-shi-xian-java-stream&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;项目地址：&lt;a href=\&#34;https://github.com/zexho994/River\&#34;&gt;https://github.com/zexho994/River&lt;/a&gt;&lt;br&gt;\n实现目标：支持和JDK Stream一样的功能, 提供与Stream一样的API，后续会进行更多的API扩展。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;手写实现 Java Stream&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;造轮子&#34;,&#34;slug&#34;:&#34;KrLfgh9WlS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/&#34;}],&#34;date&#34;:&#34;2021-09-10 21:59:28&#34;,&#34;dateFormat&#34;:&#34;2021-09-10 09:59:28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/shou-xie-shi-xian-java-stream/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:573000,&#34;words&#34;:2075,&#34;minutes&#34;:10},&#34;description&#34;:&#34;项目地址：https://github.com/zexho994/River\n实现目标：支持和JDK Stream一样的功能, 提供与Stream一样的API，后续会进行更多的API扩展。\n\n\n\n\n类型\n方法\n\n\n\n\n创建操作\nof(T.....&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3-river\&#34;&gt;顶层接口-River&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#river%E5%AE%9E%E7%8E%B0%E7%B1%BB-abstractriverpipeline\&#34;&gt;River实现类 - AbstractRiverPipeline&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%B6%E6%AE%B5%E5%B0%81%E8%A3%85-pipelinestage\&#34;&gt;阶段封装-PipelineStage&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#head%E9%98%B6%E6%AE%B5%E7%94%9F%E6%88%90-rivergenerator\&#34;&gt;Head阶段生成-RiverGenerator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E9%93%BE-sinkchain\&#34;&gt;流的处理链-SinkChain&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8C%85%E8%A3%85-wrappipeline\&#34;&gt;包装 - wrapPipeline&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B\&#34;&gt;流的运行流程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;提出疑问\&#34;&gt;提出疑问&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;如何转换流类型，怎么实现的？&lt;/li&gt;\n&lt;li&gt;如何切分任务的？&lt;/li&gt;\n&lt;li&gt;如何合并任务结果的？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;任务切分\&#34;&gt;任务切分&lt;/h2&gt;\n&lt;p&gt;并行流的底层执行是基于ForkJoin框架的，了解的都知道ForkJoin框架要执行的任务逻辑需要使用者重写，重写内容包括如果切分任务，所以去看ForkJoinTask的实现子类如何实现Compute()方法就可以知道如何进行任务切分的。&lt;br&gt;\n在AbstractTask类中实现了核心方法。&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec498e18d90a4c11bb046b48ce762f02~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n其中最核心的方法是compute()方法，定义了计算算法的逻辑：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n    * 决定是否进一步拆分一个任务或直接计算它。\n    * 如果直接计算,调用doLeaf并将结果传递给setRawResult。\n    * 否则就拆分子任务，分叉一个，继续作为另一个。\n\t* 该方法的结构是为了在一系列的使用中节约资源。循环在分裂时继续进行其中一个子任务，\n    * 以避免深度递归。为了应对可能系统性地偏向于左重或右重拆分的拆分器，我们在循环中交替使用哪个子任务被分叉或继续。\n    **/\n    @Override\n    public void compute() {\n        Spliterator&amp;lt;P_IN&amp;gt; rs = spliterator, ls; // right, left spliterators\n        //估计rs的元素数量\n        long sizeEstimate = rs.estimateSize();\n        //获取大小阈值\n        long sizeThreshold = getTargetSize(sizeEstimate);\n        //\n        boolean forkRight = false;\n        @SuppressWarnings(&amp;quot;unchecked&amp;quot;) K task = (K) this;\n        // 判断条件\n        // 1. 元素数量 &amp;gt; 阈值\n        // 2. rs可以进行切割\n        while (sizeEstimate &amp;gt; sizeThreshold &amp;amp;&amp;amp; (ls = rs.trySplit()) != null) {\n            K leftChild, rightChild, taskToFork;\n            // 使用ls,rs构造两个新的任务\n            task.leftChild  = leftChild = task.makeChild(ls);\n            task.rightChild = rightChild = task.makeChild(rs);\n            //设置等待数量为1\n            task.setPendingCount(1);\n            \n            // 轮流执行左/右两个任务\n            if (forkRight) {\n                forkRight = false;\n                rs = ls;\n                task = leftChild;\n                taskToFork = rightChild;// rightChild.fork()\n            }\n            else { \n                forkRight = true;\n                task = rightChild;\n                taskToFork = leftChild;//leftChild.fork()\n            }\n            // 递归\n            taskToFork.fork();\n            sizeEstimate = rs.estimateSize();\n        }\n        task.setLocalResult(task.doLeaf());\n        task.tryComplete();\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;本质上理解，就是将一个Spliterator进行切分成两部分，然后两部分再进行切分，直到while()条件无法再满足，然后对该部分进行运算，将运算结果保存在节点的LocalResult字段上。这部分就是分支的切分阶段。&lt;/p&gt;\n&lt;h2 id=\&#34;结果合并\&#34;&gt;结果合并&lt;/h2&gt;\n&lt;p&gt;测试代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;long count = Stream.of(1, 2, 3, 4, 5).parallel().reduce((x, y) -&amp;gt; x + y + 10).get();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;AbstractPipeline.evaluate()&lt;/code&gt;方法是并行流与串行流的分叉点：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {\n        assert getOutputShape() == terminalOp.inputShape();\n        if (linkedOrConsumed)\n            throw new IllegalStateException(MSG_STREAM_LINKED);\n        linkedOrConsumed = true;\n\n        return isParallel()\n               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))  //并行流执行点\n               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;ReduceOps.evaluateParallel()&lt;/code&gt;方法是其实现之一&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic &amp;lt;P_IN&amp;gt; R evaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,\n                                 Spliterator&amp;lt;P_IN&amp;gt; spliterator) {\n    return new ReduceTask&amp;lt;&amp;gt;(this, helper, spliterator).invoke().get();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;主要做了两件事：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;创建一个ReduceTask任务&lt;/li&gt;\n&lt;li&gt;任务调用invoke()执行&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;创建的逻辑没有额外的操作，就是将三个参数赋值到实例变量中。&lt;/p&gt;\n&lt;p&gt;invoke()是ForkJoinTask的方法，方法这里主要关注&lt;code&gt;invoke()&lt;/code&gt;方法的逻辑：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n* Commences performing this task, awaits its completion if\n* necessary, and returns its result, or throws an (unchecked)\n* {@code RuntimeException} or {@code Error} if the underlying\n* computation did so.\n*\n* @return the computed result\n*/\npublic final V invoke() {\n    int s;\n    //执行任务\n    if ((s = doInvoke() &amp;amp; DONE_MASK) != NORMAL)\n        reportException(s);\n\n    // 这里放回的是最终结果\n    return getRawResult();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/**\n* Implementation for invoke, quietlyInvoke.\n*\n* @return status upon completion\n*/\nprivate int doInvoke() {\n    int s; Thread t; ForkJoinWorkerThread wt;\n    return (s = doExec()) &amp;lt; 0 ? s :\n    ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (wt = (ForkJoinWorkerThread)t).pool.\n        awaitJoin(wt.workQueue, this, 0L) :\n    externalAwaitDone();\n}\n\n==&amp;gt; JDK代码为了性能，牺牲了可读性，这里整理下：\n\nprivate int doInvoke() {\n    s = doExec();\n    if (s &amp;lt; 0) return s;\n    \n\tt = Thread.currentThread();\n    if (t instanceof ForkJoinWorkerThread) {\n    \tForkJoinWorkerThread wt = (ForkJoinWorkerThread)t.pool();\n        return wt.awaitJoin(wt.workQueue,this,0L);\n    }\n    \n    return externalAwaitDone();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;    /**\n     * If the pending count is nonzero, decrements the count;\n     * otherwise invokes {@link #onCompletion(CountedCompleter)}\n     * and then similarly tries to complete this task&#39;s completer,\n     * if one exists, else marks this task as complete.\n     */\n    public final void tryComplte() {\n        CountedCompleter&amp;lt;?&amp;gt; a = this, s = a;\n        for (int c;;) {\n            if ((c = a.pending) == 0) {\n                a.onCompletion(s);\n                if ((a = (s = a).completer) == null) {\n                    s.quietlyComplete();\n                    return;\n                }\n            }\n            else if (U.compareAndSwapInt(a, PENDING, c, c - 1))\n                return;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在&lt;code&gt;ReduceOps.onCompletion()&lt;/code&gt;的重写方法中，如果是不是叶子节点，则合并两个子节点的结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Override\npublic void onCompletion(CountedCompleter&amp;lt;?&amp;gt; caller) {\n    if (!isLeaf()) {\n        //如果不是叶子节点，将左右两个子节点的结果合并。\n        S leftResult = leftChild.getLocalResult();\n        leftResult.combine(rightChild.getLocalResult());\n        setLocalResult(leftResult);\n    }\n    // GC spliterator, left and right child\n    super.onCompletion(caller);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;关注里面3个方法:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;isLeaf()&lt;/li&gt;\n&lt;li&gt;combine()&lt;/li&gt;\n&lt;li&gt;super.onCompletion()&lt;br&gt;\nisLeaf()判断是不是叶子节点，只有非叶子节点才有两个子节点，然后才能进行合并任务：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;protected boolean isLeaf() {\n    return leftChild == null;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;节点在执行完后调用&lt;code&gt;super.onCompletionc(caller)&lt;/code&gt;方法, 字段设为null，为了gc&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic void onCompletion(CountedCompleter&amp;lt;?&amp;gt; caller) {\n    spliterator = null;\n    leftChild = rightChild = null;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;终点看下combine()方法，这个方法的作用是将结果组合&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic void combine(ReducingSink other) {\n    if (!other.empty)\n        accept(other.state);\n}\n\n// 将本类的state和参数t进行一次运算，由于t是另一个部分运算的结果\n// 这里的作用就是两部分进行运算求出结果\n@Override\npublic void accept(T t) {\n    if (empty) {\n        empty = false;\n        state = t;\n    } else {\n        state = operator.apply(state, t);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;apply(state,t)&lt;/code&gt;运算的逻辑是使用者定义的，对应我们的示例即 &lt;code&gt;.reduce((x, y) -&amp;gt; x + y + 10)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;通过这种方法，就可以对所有节点的结果进行两两组合，得出最终结果了。&lt;/p&gt;\n&lt;h2 id=\&#34;疑问解答\&#34;&gt;疑问解答&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;如何转换流类型，怎么实现的？\n&lt;ul&gt;\n&lt;li&gt;可以使用&lt;code&gt;sequential()&lt;/code&gt;或 &lt;code&gt;parallel()&lt;/code&gt;转换流的类型，源码中是对 &lt;code&gt;sourceStage.parallel = true;&lt;/code&gt;进行标记，最后在启动时候根据和这个标记决定串行or并行。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;如何切分任务的？\n&lt;ul&gt;\n&lt;li&gt;底层利用ForkJoindPool框架实现对任务的切分和合并任务，重写&lt;code&gt;compute()&lt;/code&gt;，对Splitertor进行拆分，然后递归调用&lt;code&gt;compute()&lt;/code&gt;方法进行不断切分，直到Splitertor无法再切分，执行该部分。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;如何合并任务结果的？\n&lt;ul&gt;\n&lt;li&gt;重写&lt;code&gt;onCompletionc()&lt;/code&gt;，对每一个非叶子节点，都会将两个子节点的结果通过&lt;code&gt;combine()&lt;/code&gt;方法进行组合，然后一直向上仿佛，知道所有节点结果都组合，最后返回根节点的结果。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;shen-ru-jie-xi-java-parallel-stream&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;提出疑问\&#34;&gt;提出疑问&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;如何转换流类型，怎么实现的？&lt;/li&gt;\n&lt;li&gt;如何切分任务的？&lt;/li&gt;\n&lt;li&gt;如何合并任务结果的？&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;深入解析 Java Parallel Stream&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2021-08-11 20:56:48&#34;,&#34;dateFormat&#34;:&#34;2021-08-11 08:56:48&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-parallel-stream/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:382000,&#34;words&#34;:1464,&#34;minutes&#34;:7},&#34;description&#34;:&#34;提出疑问\n\n如何转换流类型，怎么实现的？\n如何切分任务的？\n如何合并任务结果的？\n\n\n任务切分\n并行流的底层执行是基于ForkJoin框架的，了解的都知道ForkJoin框架要执行的任务逻辑需要使用者重写，重写内容包括如果切分任务，所以去看...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%90%E5%87%BA%E7%96%91%E9%97%AE\&#34;&gt;提出疑问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1%E5%88%87%E5%88%86\&#34;&gt;任务切分&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6\&#34;&gt;结果合并&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94\&#34;&gt;疑问解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;几个疑问\&#34;&gt;几个疑问&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;终结方法是如何进行操作的？&lt;/li&gt;\n&lt;li&gt;如何实现由终结操作触发流的运作的？&lt;/li&gt;\n&lt;li&gt;如何保证一个流一次只能执行一个终结方法？&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;使用方式\&#34;&gt;使用方式&lt;/h3&gt;\n&lt;p&gt;列举四种终结操作，在Stream提供的API中，也是四类：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f302257d5bb44e519c5bb32da6fb5daa~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 计算流中元素数量，FindOP\nlong count = afterLimit.count();\n\n// 遍历所有元素,ForEachOp\nafterLimit.forEach(System.out::printl);\n\n// 获取第一个元素,MatchOp\nOptional&amp;lt;Integer&amp;gt; any = afterLimit.findFirst();\n\n// 判断是否,ReduceOp\nboolean flag = afterLimit.anyMatch(i -&amp;gt; i == 1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;count\&#34;&gt;count()&lt;/h3&gt;\n&lt;p&gt;在&lt;code&gt;ReferencePipeline&lt;/code&gt;类中实现&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic final long count() {\n \t// 调用mapToLong将所有元素变成1，然后计算sum\n    return mapToLong(e -&amp;gt; 1L).sum();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;maotolong\&#34;&gt;maoToLong()&lt;/h4&gt;\n&lt;p&gt;mapToLong()方法，是一个中间操作&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\n    public final LongStream mapToLong(ToLongFunction&amp;lt;? super P_OUT&amp;gt; mapper) {\n        Objects.requireNonNull(mapper);\n        return new LongPipeline.StatelessOp&amp;lt;P_OUT&amp;gt;(this, StreamShape.REFERENCE,\n                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {\n            @Override\n            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;Long&amp;gt; sink) {\n                return new Sink.ChainedReference&amp;lt;P_OUT, Long&amp;gt;(sink) {\n                    @Override\n                    public void accept(P_OUT u) {\n                        //\n                        downstream.accept(mapper.applyAsLong(u));\n                    }\n                };\n            }\n        };\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ToLongFunction是一个函数式接口类, accept()里的逻辑便是&lt;code&gt;e -&amp;gt; 1L&lt;/code&gt;.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@FunctionalInterface\npublic interface ToLongFunction&amp;lt;T&amp;gt; {\n\n    /**\n     * Applies this function to the given argument.\n     *\n     * @param value the function argument\n     * @return the function result\n     */\n    long applyAsLong(T value);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看下Sum()方法,在LongPipeline类中，传入参数是一个Long::sum, sum的作用是相加两个值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic final long sum() {\n    // use better algorithm to compensate for intermediate overflow?\n    return reduce(0, Long::sum);\n}\n\n//public static long sum(long a, long b) {\n//    return a + b;\n//}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;reduce\&#34;&gt;reduce()&lt;/h4&gt;\n&lt;p&gt;reduce方法,将操作函数op封装成一个Sink，makeLong()的作用就是会生产一个Sink&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic final long reduce(long identity, LongBinaryOperator op) {\n    return evaluate(ReduceOps.makeLong(identity, op));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Constructs a {@code TerminalOp} that implements a functional reduce on\n     * {@code long} values.\n     *\n     * @param identity the identity for the combining function\n     * @param operator the combining function\n     * @return a {@code TerminalOp} implementing the reduction\n     */\n    public static TerminalOp&amp;lt;Long, Long&amp;gt;\n    makeLong(long identity, LongBinaryOperator operator) {\n        Objects.requireNonNull(operator);\n        class ReducingSink\n                implements AccumulatingSink&amp;lt;Long, Long, ReducingSink&amp;gt;, Sink.OfLong {\n                \n            //state是一个用作记录的值\n            private long state;\n\n            @Override\n            public void begin(long size) {\n                state = identity;\n            }\n\n\t\t\t//参数传进来的就是sun(),所以这里的accept()的作用就是对state不断进行累加\n            @Override\n            public void accept(long t) {\n                state = operator.applyAsLong(state, t);\n            }\n\n            @Override\n            public Long get() {\n                return state;\n            }\n\n            @Override\n            public void combine(ReducingSink other) {\n                accept(other.state);\n            }\n        }\n        return new ReduceOp&amp;lt;Long, Long, ReducingSink&amp;gt;(StreamShape.LONG_VALUE) {\n            @Override\n            public ReducingSink makeSink() {\n                return new ReducingSink();\n            }\n        };\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;evaluate\&#34;&gt;evaluate()&lt;/h4&gt;\n&lt;p&gt;看回evaluate()方法，这个方法用来执行终结操作的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {\n    assert getOutputShape() == terminalOp.inputShape();\n    //判断流是否已被使用\n    if (linkedOrConsumed)\n        throw new IllegalStateException(MSG_STREAM_LINKED);\n    //设置使用标记为true\n    linkedOrConsumed = true;\n\n    //根据流类型，执行相应的推断操作\n    return isParallel()\n        ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))\n        : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;关注时序流的推断方法，可以看到这个方法的实现分为四种，对应上面提到的四类类型操作，count属于ReduceOp，进去看下。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140540bd57794266af310e7c016400f5~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\n@Override\npublic &amp;lt;P_IN&amp;gt; R evaluateSequential(PipelineHelper&amp;lt;T&amp;gt; helper,\n                                   Spliterator&amp;lt;P_IN&amp;gt; spliterator) {\n    //调用wrapAndCopyInto()方法\n    return helper.wrapAndCopyInto(makeSink(), spliterator).get();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;wrapandcopyinto\&#34;&gt;wrapAndCopyInto()&lt;/h4&gt;\n&lt;p&gt;保证所有stage -&amp;gt; sink链表，然后执行copyInto()方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t@Override\n    final &amp;lt;P_IN, S extends Sink&amp;lt;E_OUT&amp;gt;&amp;gt; S wrapAndCopyInto(S sink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {\n        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);\n        return sink;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;warpsink\&#34;&gt;warpSink()&lt;/h4&gt;\n&lt;p&gt;就是在这里，从后向前，包装所有的stage阶段，形成一条sink链表。这样将之前一个个stage的链表结构包装成一个个Sink。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t@Override\n    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n    final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {\n        Objects.requireNonNull(sink);\n\t\t\n        //从后向前遍历\n        for ( @SuppressWarnings(&amp;quot;rawtypes&amp;quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {\n            //执行每个opWrapSink()方法，这个方法在每个操作类中都进行了重写\n            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);\n        }\n        //返回头sink\n        return (Sink&amp;lt;P_IN&amp;gt;) sink;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;copyinto\&#34;&gt;copyInto()&lt;/h4&gt;\n&lt;p&gt;这个方法是整个流水线的启动开关，流程如下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;调用第一个sink的begin()方法&lt;/li&gt;\n&lt;li&gt;执行数据源的spliterator.forEachRemaining(wrappendSink)方法遍历调用accept()方法&lt;/li&gt;\n&lt;li&gt;end() 通知结束&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t@Override\n    final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {\n        Objects.requireNonNull(wrappedSink);\n\n        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {\n            //通知第一个sink，做好准备接受流\n            wrappedSink.begin(spliterator.getExactSizeIfKnown());\n            //执行\n            spliterator.forEachRemaining(wrappedSink);\n            wrappedSink.end();\n        }\n        else {\n            copyIntoWithCancel(wrappedSink, spliterator);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;foreachremaining\&#34;&gt;forEachRemaining()&lt;/h4&gt;\n&lt;p&gt;在各个容器中都有实现forEachRemaining()这个方法，在ArrayList中:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public boolean tryAdvance(Consumer&amp;lt;? super E&amp;gt; action) {\n    if (action == null)\n        throw new NullPointerException();\n    int hi = getFence(), i = index;\n    if (i &amp;lt; hi) {\n        index = i + 1;\n        @SuppressWarnings(&amp;quot;unchecked&amp;quot;) E e = (E)list.elementData[i];\n        //执行accept()方法\n        action.accept(e);\n        if (list.modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n        return true;\n    }\n    return false;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;其他终结操作\&#34;&gt;其他终结操作&lt;/h3&gt;\n&lt;h4 id=\&#34;foreach\&#34;&gt;forEach()&lt;/h4&gt;\n&lt;p&gt;在&lt;code&gt;ReferencePipeline&lt;/code&gt;类中，实现了forEach()方法，&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// from ReferencePipeline.class\n\n@Override\npublic void forEach(Consumer&amp;lt;? super P_OUT&amp;gt; action) {\n    // ForEachOps..\n    evaluate(ForEachOps.makeRef(action, false));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;evaluate后面的逻辑与count后面的一样了，略。&lt;/p&gt;\n&lt;h4 id=\&#34;findfirst-anymatch\&#34;&gt;findFirst() anyMatch()&lt;/h4&gt;\n&lt;p&gt;findFirst()和anyMatch()的逻辑也不再多说了，一个套路，看下实现&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic final Optional&amp;lt;P_OUT&amp;gt; findFirst() {\n    return evaluate(FindOps.makeRef(true));\n}\n\n@Override\npublic final boolean anyMatch(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {\n    return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;疑问解答\&#34;&gt;疑问解答&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;终结方法是如何进行操作的？\n&lt;ul&gt;\n&lt;li&gt;终结操作的实现里面都有调用evaluate()方法，这个方法最后会warp所有操作变成一串sink，然后从头开始执行begin(),accept(),end()方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;如何实现由终结操作触发流的运作的？\n&lt;ul&gt;\n&lt;li&gt;触发的开关是wrapAndCopyInto(),这个方法只有在终结操作中才有被调用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;如何保证一个流一次只能执行一个终结方法？\n&lt;ul&gt;\n&lt;li&gt;evaluate()方法中执行一次后&lt;code&gt;linkedOrConsumed&lt;/code&gt;设为true，后续再出发evaluate()方法就会异常。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;参考引用：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://colobu.com/2014/11/18/Java-8-Stream/\&#34;&gt;Java 8 Stream探秘 (colobu.com)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;\&#34;&gt;原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;shen-ru-jie-xi-java-streamxia-zhong-jie-cao-zuo&#34;,&#34;abstract&#34;:&#34;&lt;h3 id=\&#34;几个疑问\&#34;&gt;几个疑问&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;终结方法是如何进行操作的？&lt;/li&gt;\n&lt;li&gt;如何实现由终结操作触发流的运作的？&lt;/li&gt;\n&lt;li&gt;如何保证一个流一次只能执行一个终结方法？&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;深入解析Java Stream（下）：终结操作&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2021-08-06 11:13:20&#34;,&#34;dateFormat&#34;:&#34;2021-08-06 11:13:20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamxia-zhong-jie-cao-zuo/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:377000,&#34;words&#34;:1321,&#34;minutes&#34;:7},&#34;description&#34;:&#34;几个疑问\n\n终结方法是如何进行操作的？\n如何实现由终结操作触发流的运作的？\n如何保证一个流一次只能执行一个终结方法？\n\n\n使用方式\n列举四种终结操作，在Stream提供的API中，也是四类：\n\n// 计算流中元素数量，FindOP\nlong...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE\&#34;&gt;几个疑问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\&#34;&gt;使用方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#count\&#34;&gt;count()&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#maotolong\&#34;&gt;maoToLong()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#reduce\&#34;&gt;reduce()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#evaluate\&#34;&gt;evaluate()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#wrapandcopyinto\&#34;&gt;wrapAndCopyInto()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#warpsink\&#34;&gt;warpSink()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#copyinto\&#34;&gt;copyInto()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#foreachremaining\&#34;&gt;forEachRemaining()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B6%E4%BB%96%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C\&#34;&gt;其他终结操作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#foreach\&#34;&gt;forEach()&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#findfirst-anymatch\&#34;&gt;findFirst() anyMatch()&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94\&#34;&gt;疑问解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;几个疑问\&#34;&gt;几个疑问&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;各个中间操作是如何进行关联的？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;如何执行完一个中间操作，然后执行下一个？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;有状态的中间操作是怎么保存状态的？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;懒加载如何实现的&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h3 id=\&#34;使用方式\&#34;&gt;使用方式&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Stream&amp;lt;Integer&amp;gt; st = headStream.filter(e-&amp;gt; e=1).distinct().sort();\n//等同于\nStream&amp;lt;Integer&amp;gt; afterFilter = headStream.filter(e -&amp;gt; e != 2);\nStream&amp;lt;Integer&amp;gt; afterDistinct = afterFilter.distinct();\nStream&amp;lt;Integer&amp;gt; afterSort = afterDistinct.sort();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;filter\&#34;&gt;Filter&lt;/h3&gt;\n&lt;p&gt;执行filter(op)会发生什么？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Stream&amp;lt;Integer&amp;gt; afterFilter = head.filter(e -&amp;gt; e = 1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;filter()方法定义在&lt;code&gt;Stream&lt;/code&gt;类，实现在&lt;code&gt;ReferencePipeline&lt;/code&gt;类。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//ReferencePipeline.class\n\n@Override\npublic final Stream&amp;lt;P_OUT&amp;gt; filter(Predicate&amp;lt;? super P_OUT&amp;gt; predicate) {\n    Objects.requireNonNull(predicate);\n\n    // 返回一个StatelessOp类\n    // 构造函数参数为(this,)\n    return new StatelessOp&amp;lt;P_OUT, P_OUT&amp;gt;(this, StreamShape.REFERENCE,\n                                         StreamOpFlag.NOT_SIZED) {\n        @Override\n        Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;P_OUT&amp;gt; sink) {\n            return new Sink.ChainedReference&amp;lt;P_OUT, P_OUT&amp;gt;(sink) {\n                @Override\n                public void begin(long size) {\n                    downstream.begin(-1);\n                }\n\n                @Override\n                public void accept(P_OUT u) {\n                    if (predicate.test(u))\n                        downstream.accept(u);\n                }\n            };\n        }\n    };\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回一个&lt;code&gt;StatelessOp&lt;/code&gt;类(因为filter是一个无状态操作)，看下&lt;code&gt;StatelessOp&lt;/code&gt;类,是一个静态抽象内部类，继承了&lt;code&gt;ReferencePipeline&lt;/code&gt;类。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//ReferencePipeline.class\n\n    /**\n     * Base class for a stateless intermediate stage of a Stream.\n     *\n     * @param &amp;lt;E_IN&amp;gt; type of elements in the upstream source\n     * @param &amp;lt;E_OUT&amp;gt; type of elements in produced by this stage\n     * @since 1.8\n     */\n    abstract static class StatelessOp&amp;lt;E_IN, E_OUT&amp;gt;\n            extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {\n        /**\n         * Construct a new Stream by appending a stateless intermediate\n         * operation to an existing stream.\n         *\n         * @param upstream The upstream pipeline stage\n         * @param inputShape The stream shape for the upstream pipeline stage\n         * @param opFlags Operation flags for the new stage\n         */\n        StatelessOp(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; upstream,\n                    StreamShape inputShape,\n                    int opFlags) {\n            super(upstream, opFlags);\n            assert upstream.getOutputShape() == inputShape;\n        }\n\n        @Override\n        final boolean opIsStateful() {\n            return false;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;中间super()会执行&lt;code&gt;AbstractPipeline&lt;/code&gt;类的构造方法, 连接stage之间的关系&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//AbstractPipeline.class\n\n    /**\n     * Constructor for appending an intermediate operation stage onto an\n     * existing pipeline.\n     *\n     * @param previousStage the upstream pipeline stage\n     * @param opFlags the operation flags for the new stage, described in\n     * {@link StreamOpFlag}\n     */\n    AbstractPipeline(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; previousStage, int opFlags) {\n        if (previousStage.linkedOrConsumed)\n            throw new IllegalStateException(MSG_STREAM_LINKED);\n        previousStage.linkedOrConsumed = true;\n        previousStage.nextStage = this;\n\n        this.previousStage = previousStage;\n        this.sourceOrOpFlags = opFlags &amp;amp; StreamOpFlag.OP_MASK;\n        this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);\n        this.sourceStage = previousStage.sourceStage;\n        if (opIsStateful())\n            sourceStage.sourceAnyStateful = true;\n        this.depth = previousStage.depth + 1;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83eb7d9726541b5826f8d5bcfef7538~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;distinct\&#34;&gt;Distinct&lt;/h3&gt;\n&lt;p&gt;示例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Stream&amp;lt;Integer&amp;gt; afterDistinct = afterFilter.distinct();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;distinct的方法实现在&lt;code&gt;ReferencePipeline&lt;/code&gt;类下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Override\npublic final Stream&amp;lt;P_OUT&amp;gt; distinct() {\n    return DistinctOps.makeRef(this);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;调用DistinctOps类的makeRef()方法，返回一个StatefulOp类，并重写了4个方法，实现逻辑在opWrapSink()中:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Appends a &amp;quot;distinct&amp;quot; operation to the provided stream, and returns the\n     * new stream.\n     *\n     * @param &amp;lt;T&amp;gt; the type of both input and output elements\n     * @param upstream a reference stream with element type T\n     * @return the new stream\n     */\n    static &amp;lt;T&amp;gt; ReferencePipeline&amp;lt;T, T&amp;gt; makeRef(AbstractPipeline&amp;lt;?, T, ?&amp;gt; upstream) {\n        // 返回一个StatefulOp类\n        return new ReferencePipeline.StatefulOp&amp;lt;T, T&amp;gt;(upstream, StreamShape.REFERENCE,\n                                                      StreamOpFlag.IS_DISTINCT | StreamOpFlag.NOT_SIZED) {\n\n            // 重写了以下几个方法，内容省略...\n            &amp;lt;P_IN&amp;gt; Node&amp;lt;T&amp;gt; reduce(PipelineHelper&amp;lt;T&amp;gt; helper, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {...}\n\n            @Override\n            &amp;lt;P_IN&amp;gt; Node&amp;lt;T&amp;gt; opEvaluateParallel(PipelineHelper&amp;lt;T&amp;gt; helper,\n                                              Spliterator&amp;lt;P_IN&amp;gt; spliterator,\n                                              IntFunction&amp;lt;T[]&amp;gt; generator) {...}\n\n            @Override\n            &amp;lt;P_IN&amp;gt; Spliterator&amp;lt;T&amp;gt; opEvaluateParallelLazy(PipelineHelper&amp;lt;T&amp;gt; helper, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {...}\n\n            @Override\n            Sink&amp;lt;T&amp;gt; opWrapSink(int flags, Sink&amp;lt;T&amp;gt; sink) {\n                Objects.requireNonNull(sink);\n\n                if (StreamOpFlag.DISTINCT.isKnown(flags)) {\n                    ...\n                } else if (StreamOpFlag.SORTED.isKnown(flags)) {\n                    ...\n                } else {\n                    // 返回一个SinkChainedReference类\n                    return new Sink.ChainedReference&amp;lt;T, T&amp;gt;(sink) {\n                        //使用一个Set缓存数据，进行去重\n                        Set&amp;lt;T&amp;gt; seen;\n\n                        //当上游通知begin的时候，初始化Set\n                        @Override\n                        public void begin(long size) {\n                            seen = new HashSet&amp;lt;&amp;gt;();\n                            downstream.begin(-1);\n                        }\n\n                        //略\n                        @Override\n                        public void end() {\n                            seen = null;\n                            downstream.end();\n                        }\n\n                        //如果已经存在，之间抛弃\n                        @Override\n                        public void accept(T t) {\n                            if (!seen.contains(t)) {\n                                seen.add(t);\n                                downstream.accept(t);\n                            }\n                        }\n                    };\n                }\n            }\n        };\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;StatefulOp类与StatelessOp类相似,都是继承了&lt;code&gt;ReferencePipeline&lt;/code&gt;类，然后中间super()页会执行&lt;code&gt;AbstractPipeline&lt;/code&gt;类的构造方法, 连接stage之间的关系&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * Base class for a stateful intermediate stage of a Stream.\n     *\n     * @param &amp;lt;E_IN&amp;gt; type of elements in the upstream source\n     * @param &amp;lt;E_OUT&amp;gt; type of elements in produced by this stage\n     * @since 1.8\n     */\n    abstract static class StatefulOp&amp;lt;E_IN, E_OUT&amp;gt; extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {\n \t\t//省略\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1bb602651a41efb5b38673063b1523~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;至于其他的中间操作，套路都是类似的，操作逻辑封装在&lt;code&gt;opWrapSink()&lt;/code&gt;方法里, 可以慢慢的看。&lt;/p&gt;\n&lt;h3 id=\&#34;疑问解答\&#34;&gt;疑问解答&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;各个中间操作是如何进行关联的？&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;一个个的操作封装成了一个个的&lt;code&gt;statelessOp&lt;/code&gt;或&lt;code&gt;stateFulOp&lt;/code&gt;对象，以双向链表的方法串起来。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;如何执行完一个中间操作，然后执行下一个？&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;Sink类负责流水线操作的承接上下游和执行操作的任务，核心方法为begain()、accept()、end()。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;有状态的中间操作是怎么保存状态的？&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;有状态的中间操作封装成&lt;code&gt;stateFulOp&lt;/code&gt;对象，各自都有独立的逻辑，具体的参考&lt;code&gt;sort()&lt;/code&gt;的实现逻辑。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;懒加载如何实现的&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;每个中间操作调用后，只是append在流程的尾部，保存了关联关系而已。&lt;/li&gt;\n&lt;li&gt;流水线操作的启动，要交给wrapAndCopyInto()方法调用Head的Sink()操作，而wrapAndCopyInto()方法都需要由终结操作进行触发。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;fileName&#34;:&#34;shen-ru-jie-xi-java-streamzhong-op-cao-zuo-liu&#34;,&#34;abstract&#34;:&#34;&lt;h3 id=\&#34;几个疑问\&#34;&gt;几个疑问&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;各个中间操作是如何进行关联的？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;如何执行完一个中间操作，然后执行下一个？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;有状态的中间操作是怎么保存状态的？&lt;/strong&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;懒加载如何实现的&lt;/strong&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;深入解析Java Stream（中）：OP操作流&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2021-07-22 18:09:33&#34;,&#34;dateFormat&#34;:&#34;2021-07-22 06:09:33&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamzhong-op-cao-zuo-liu/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:342000,&#34;words&#34;:1152,&#34;minutes&#34;:6},&#34;description&#34;:&#34;几个疑问\n\n各个中间操作是如何进行关联的？\n如何执行完一个中间操作，然后执行下一个？\n有状态的中间操作是怎么保存状态的？\n懒加载如何实现的\n\n\n使用方式\nStream&amp;lt;Integer&amp;gt; st = headStream.filte...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE\&#34;&gt;几个疑问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\&#34;&gt;使用方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#filter\&#34;&gt;Filter&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#distinct\&#34;&gt;Distinct&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94\&#34;&gt;疑问解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;了解Stream中Sink和Pipline的概念，以及剖析Stream是如何创建。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;类图\&#34;&gt;类图&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fccb594381b4b488f58abd47d935f06~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;概念解释\&#34;&gt;概念解释&lt;/h2&gt;\n&lt;h3 id=\&#34;pipline和stage\&#34;&gt;Pipline和Stage&lt;/h3&gt;\n&lt;p&gt;Pipline是流水线，表示一整个流程。Stage表示流水线的其中一个阶段。是一个比较抽象层面的描述，因为stage主要表示一种逻辑上的顺序关系，而具体每一个阶段要干嘛、怎么干，使用Sink来进行描述。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;new stream          //stage 0\n    .filter()       //stage 1\n    .sort()         //stage 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37dd9b847b014b8c9ae5710c0be1907c~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;sink\&#34;&gt;Sink&lt;/h3&gt;\n&lt;p&gt;直译为水槽，生活中水槽的作用无非&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;打开水龙头，知道有水要来&lt;/li&gt;\n&lt;li&gt;水在水槽里, 可以进行一些操作&lt;/li&gt;\n&lt;li&gt;打开水闸，放水&lt;br&gt;\nJava中的Sink核心功能为：&lt;/li&gt;\n&lt;li&gt;begin(): 告诉该水槽水流要来了，可以进行一些初始化操作&lt;/li&gt;\n&lt;li&gt;accept()：接受水流，然后进行操作&lt;/li&gt;\n&lt;li&gt;end()：水流全部处理完了。&lt;br&gt;\n看一个sort()的示例,sort这个stage的目的就是对所有水流进行排序，然后再流到下游。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private static final class SizedRefSortingSink&amp;lt;T&amp;gt; extends AbstractRefSortingSink&amp;lt;T&amp;gt; {\n        private T[] array;  //要进行排序，需要一个数组进行缓存\n        private int offset; \n\n        SizedRefSortingSink(Sink&amp;lt;? super T&amp;gt; sink, Comparator&amp;lt;? super T&amp;gt; comparator) {\n            super(sink, comparator);\n        }\n\n        @Override\n        @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n        public void begin(long size) {\n            if (size &amp;gt;= Nodes.MAX_ARRAY_SIZE)\n                throw new IllegalArgumentException(Nodes.BAD_SIZE);\n            //上游调用begin(),通知sort进行初始化操作，生产一个数组\n            array = (T[]) new Object[(int) size];\n        }\n\n    \t//上游调用end()方法，告诉sort水已经全部流过来了。sort开始执行操作\n        @Override\n        public void end() {\n            //操作\n            Arrays.sort(array, 0, offset, comparator);\n            //告诉sort的下游准备接受水流\n            downstream.begin(offset);\n            //一个个元素的传递给下游\n            if (!cancellationWasRequested) {\n                for (int i = 0; i &amp;lt; offset; i++)\n                    downstream.accept(array[i]);\n            }\n            else {\n                for (int i = 0; i &amp;lt; offset &amp;amp;&amp;amp; !downstream.cancellationRequested(); i++)\n                    downstream.accept(array[i]);\n            }\n            //告诉下游水流传递结束\n            downstream.end();\n            //缓存清空\n            array = null;\n        }\n\n    \t//上游调用accept()方法，将水流存储到到sort的缓存数组中\n        @Override\n        public void accept(T t) {\n            array[offset++] = t;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;创建head\&#34;&gt;创建Head&lt;/h2&gt;\n&lt;h3 id=\&#34;疑问\&#34;&gt;疑问&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;官方说Stream不存储数据，那么数据保存在那里呢？&lt;br&gt;\n解答在后面。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;使用方式\&#34;&gt;使用方式&lt;/h3&gt;\n&lt;p&gt;可以使用Stream.of()创建一个流，例如&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;//创建方式 of()\nStream&amp;lt;Integer&amp;gt; stream = Stream.of(1, 2, 3);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;源码分析\&#34;&gt;源码分析&lt;/h3&gt;\n&lt;p&gt;of()方法调用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;StreamSupport.stream(Arrays.spliterator(arr, 0, arr.length), false);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;stream()方法逻辑：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static &amp;lt;T&amp;gt; Stream&amp;lt;T&amp;gt; stream(Spliterator&amp;lt;T&amp;gt; spliterator, boolean parallel) {\n    Objects.requireNonNull(spliterator);\n    return new ReferencePipeline.Head&amp;lt;&amp;gt;(spliterator,\n                                        StreamOpFlag.fromCharacteristics(spliterator),\n                                        parallel);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;调用了&lt;code&gt;ReferencePipeline.Head&amp;lt;&amp;gt;&lt;/code&gt;，返回一个Head对象。Head是ReferencePipeline的子类。可以理解为Head是流水线的第一个stage。&lt;br&gt;\n构造方法的主要了逻辑要一直super()到&lt;code&gt;AbstractPipeline&lt;/code&gt;类&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    /**\n     * The source spliterator. Only valid for the head pipeline.\n     * Before the pipeline is consumed if non-null then {@code sourceSupplier}\n     * must be null. After the pipeline is consumed if non-null then is set to\n     * null.\n     */\n    private Spliterator&amp;lt;?&amp;gt; sourceSpliterator;\n\n    /**\n     * Constructor for the head of a stream pipeline.\n     *\n     * @param source {@code Spliterator} describing the stream source\n     * @param sourceFlags the source flags for the stream source, described in\n     * {@link StreamOpFlag}\n     * @param parallel {@code true} if the pipeline is parallel\n     */\n    AbstractPipeline(Spliterator&amp;lt;?&amp;gt; source,\n                     int sourceFlags, boolean parallel) {\n        this.previousStage = null;\n        //使用一个字段指向数据集合的Spliterator,后续终结操作的时候，引用的方式操作数据\n        this.sourceSpliterator = source;\n        this.sourceStage = this;\n        this.sourceOrOpFlags = sourceFlags &amp;amp; StreamOpFlag.STREAM_MASK;\n        // The following is an optimization of:\n        // StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);\n        this.combinedFlags = (~(sourceOrOpFlags &amp;lt;&amp;lt; 1)) &amp;amp; StreamOpFlag.INITIAL_OPS_VALUE;\n        this.depth = 0;\n        this.parallel = parallel;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6bb4ba6d9042e3a1f6b4547b68edec~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;疑问解答\&#34;&gt;疑问解答&lt;/h3&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;strong&gt;官方说Stream不存储数据，那么数据保存在那里呢？&lt;/strong&gt;\n&lt;ul&gt;\n&lt;li&gt;Head中保存数据源的Spliterator对象，后续操作Spliterator的方式操作数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;参考引用：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://colobu.com/2014/11/18/Java-8-Stream/\&#34;&gt;Java 8 Stream探秘 (colobu.com)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;\&#34;&gt;原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;1V4Hrg06J&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;了解Stream中Sink和Pipline的概念，以及剖析Stream是如何创建。&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;深入解析Java Stream源码（上）：初始化 Sink&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-07-09 13:09:05&#34;,&#34;dateFormat&#34;:&#34;2021-07-09 01:09:05&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/1V4Hrg06J/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:238000,&#34;words&#34;:879,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n了解Stream中Sink和Pipline的概念，以及剖析Stream是如何创建。\n\n\n类图\n\n概念解释\nPipline和Stage\nPipline是流水线，表示一整个流程。Stage表示流水线的其中一个阶段。是一个比较抽象层面的描述，因...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E5%9B%BE\&#34;&gt;类图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A\&#34;&gt;概念解释&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#pipline%E5%92%8Cstage\&#34;&gt;Pipline和Stage&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#sink\&#34;&gt;Sink&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BAhead\&#34;&gt;创建Head&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE\&#34;&gt;疑问&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\&#34;&gt;使用方式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\&#34;&gt;源码分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94\&#34;&gt;疑问解答&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Java里泛型，与c#比起来，更算是一种语法糖。关于语法糖，是编译时的一种“小把戏”，目的是让使用者可以有更多的手段是编写代码。&lt;br&gt;\n好处是效率，了解Rust的可以感受到，编写Rust的代码极其高效的，代价就是学习成本非常高，原因之一就是大量的语法糖。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;在java 中:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void foo(Person&amp;lt;String&amp;gt; p){}\n\npublic void foo(Person&amp;lt;Long&amp;gt; p){}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b95e4b789e245b581f3159d90c25eec~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;泛型擦除-字节码分析\&#34;&gt;泛型擦除-字节码分析&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void foo(Person&amp;lt;String&amp;gt; p){}  ==&amp;gt; public void foo(Person&amp;lt;Object&amp;gt; p){}\n\npublic void foo(Person&amp;lt;Long&amp;gt; p){} ==&amp;gt; public void foo(Person&amp;lt;Object&amp;gt; p){}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面这个类&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Person&amp;lt;T&amp;gt;{\n\n    T name;\n\n    public static void main(String[] args) {\n        Person&amp;lt;String&amp;gt; p = new Person&amp;lt;String&amp;gt;();\n        p.name = &amp;quot;张三&amp;quot;;\n        GvmOut.to(p.name);\n    }\n\n    public void foo(T t){}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/356e67eb94044e85bc0270e8dbd05805~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498461b0cf404349baaf98ca47e5f2c7~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;字段的签名和方法的签名都是Object对象，那为什么还需要范型，直接用Object声明不就好了吗。答案是约束，使用泛型可以保证类型符合要求。&lt;/p&gt;\n&lt;p&gt;在字节码指令中，会添加checkcast命令去检查类型是否匹配。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a2ceac67b4b4b8e98e3725639bbca97~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d997841902ca4fb9b4c1473a45265c7b~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;泛型上下边界-字节码分析\&#34;&gt;泛型上下边界-字节码分析&lt;/h3&gt;\n&lt;p&gt;泛型常见的场景之一是使用extends，可以约束参数的范围。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Son&amp;lt;T extends Person&amp;gt;{\n\n    T father;\n\n    public static void main(String[] args) {\n        Son&amp;lt;Person&amp;gt; son = new Son&amp;lt;&amp;gt;();\n        son.father = new Person();\n    }\n\n    public T name(T t){\n        return t;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6005fb3ea7494860b1a9669d34bda1c5~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1e578969da44529d65f459c4baf301~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h2&gt;\n&lt;p&gt;本质上，编译后，泛型依然被擦除了，但是不再是Object类，而是Person类。&lt;/p&gt;\n&lt;h3 id=\&#34;为什么选择这种方式实现范型\&#34;&gt;为什么选择这种方式实现范型&lt;/h3&gt;\n&lt;p&gt;向下兼容。向下兼容。向下兼容。&lt;/p&gt;\n&lt;h2 id=\&#34;参考\&#34;&gt;参考：&lt;/h2&gt;\n&lt;p&gt;-《虚拟机规范(SE8)》&lt;br&gt;\n-《自己动手些虚拟机》&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;nL7teffDj&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Java里泛型，与c#比起来，更算是一种语法糖。关于语法糖，是编译时的一种“小把戏”，目的是让使用者可以有更多的手段是编写代码。&lt;br&gt;\n好处是效率，了解Rust的可以感受到，编写Rust的代码极其高效的，代价就是学习成本非常高，原因之一就是大量的语法糖。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;从字节码剖析泛型&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JVM&#34;,&#34;slug&#34;:&#34;jjLsZt3QW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/jjLsZt3QW/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2021-05-06 16:30:29&#34;,&#34;dateFormat&#34;:&#34;2021-05-06 04:30:29&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/nL7teffDj/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:107000,&#34;words&#34;:418,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Java里泛型，与c#比起来，更算是一种语法糖。关于语法糖，是编译时的一种“小把戏”，目的是让使用者可以有更多的手段是编写代码。\n好处是效率，了解Rust的可以感受到，编写Rust的代码极其高效的，代价就是学习成本非常高，原因之一就是大量的...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4-%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90\&#34;&gt;泛型擦除-字节码分析&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C-%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90\&#34;&gt;泛型上下边界-字节码分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!!&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E8%8C%83%E5%9E%8B\&#34;&gt;为什么选择这种方式实现范型&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在jvm中，定义了有205条指令，从0x00 -&amp;gt; 0xCA , 0xFE -&amp;gt; 0xFF。我们在方法中写的所有逻辑，最终都会转换成这些指令，而虚拟机的最重要的一个任务就是解释执行这些指令。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;jvm指令集\&#34;&gt;JVM指令集&lt;/h1&gt;\n&lt;p&gt;指令类型种类很多&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ebfd1be8ab947b1b8452e46405b1839~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;比较常见的类型有：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;load ： 数据从局部变量表 -&amp;gt; 操作数栈中&lt;/li&gt;\n&lt;li&gt;store ： 数据从操作数栈 -&amp;gt; 局部变量表中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;references : 方法调用、类型强转、monitor锁等&lt;/li&gt;\n&lt;li&gt;math ：运算操作相关&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;comparisons : 逻辑操作，if，while，for，goto等&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;指令格式\&#34;&gt;指令格式&lt;/h3&gt;\n&lt;p&gt;指令都是由两部分组成，&lt;strong&gt;操作码&lt;/strong&gt;和&lt;strong&gt;操作数。&lt;/strong&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;操作码：&lt;/strong&gt; 用于表示是什么指令. 0x1a , 0x45 ,0x57 是操作码&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;操作数：&lt;/strong&gt; 有些指令需要操作局部变量表和操作数栈，需要知道索引的位置.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;//匹配指令\nswitch opcode {\n    ...\n    case 0x1a:\n\t\treturn iload_0\n    ...\n\tcase 0x45:\n\t\treturn fstore_2\n    ...\n    case 0x57:\n\t\treturn pop\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;超级指令\&#34;&gt;超级指令&lt;/h3&gt;\n&lt;p&gt;解释的速度通常比较慢，原因之一是解释器在判断指令类型的时候涉及到分支，cpu层面分支预测失败和指令缓存未命中的开销都很大。&lt;/p&gt;\n&lt;p&gt;解决办法很容易想到，把两个或者多个代码合并成一个代码，在一趟处理中可以直接获取然后执行指令，这样就减少了分支的次数，这些指令便称为超级指令、快速指令、虚拟指令。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;...\ncase 0x59:\n\treturn dup\n...\ncase 0x60:\n\treturn iadd\n...\ncase 0x84:\n\treturn iinc\n...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;例如&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;dup: 指令表示将操作数栈顶的元素复制一份。&lt;/li&gt;\n&lt;li&gt;iinc: 表示局部变量表+1，省略了经过操作数栈+1，然后再保存的过程。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;指令流获取\&#34;&gt;指令流获取&lt;/h3&gt;\n&lt;p&gt;在类加载过程-加载步骤。在字节码文件中，指令的数据保存在在methods的的属性表的code字段中。在类加载阶段，读取字节码文件时候会生成一份等价的对象，对象的构建就是从头到尾的把所有数据都进行读取，然后解析。每个不同组件都有不同的方法读取。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5bde907abd949a4a154053757390bf2~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;// 读取length长度的数据\nfunc parseMethod(count uint16, reader *loader.ClassReader, pool *constant_pool.ConstantPool, k *Klass) Methods {\n\tmethods := make([]*MethodKlass, count)\n\tfor i := range methods {\n\t\tmethod := &amp;amp;MethodKlass{}\n\t\t//设置常量池\n\t\tmethod.ConstantPool = pool\n\t\t//设置访问标记\n\t\tmethod.accessFlag = reader.ReadUint16()\n\t\t//name常量池索引\n\t\tmethod.nameIdx = reader.ReadUint16()\n\t\t//描述符常量池索引\n\t\tmethod.descriptorIdx = reader.ReadUint16()\n\t\t//属性表数量\n\t\tmethod.attrCount = reader.ReadUint16()\n\t\t// 解析方法表中的属性表字段\n\t\tmethod.AttributesInfo = attribute.ParseAttributes(method.attrCount, reader, pool)\n\t\t// 绑定klass&amp;amp;method\n\t\tmethod.Klass = k\n\t\t// 本地方法注入字节码\n\t\tmethod.InjectCodeAttrIfNative()\n\t}\n\treturn methods\n}\n\nfunc (c *AttrCode) parse(reader *loader.ClassReader) {\n\tc.MaxStack = reader.ReadUint16()\n\tc.MaxLocals = reader.ReadUint16()\n\t//code长度\n\tc.codeLen = reader.ReadUint32()\n\t//读取len长度的字节\n\tc.code = reader.ReadBytes(c.codeLen)\n\tc.ExceptionTable = parseExceptionTable(reader)\n\tc.attrCount = reader.ReadUint16()\n\tc.AttributesInfo = ParseAttributes(c.attrCount, reader, c.ConstantPool)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;指令的解释过程\&#34;&gt;指令的解释过程&lt;/h3&gt;\n&lt;p&gt;指令的执行是由解释器负责的，解析器的流程简单说就是:&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://tva1.sinaimg.cn/large/e6c9d24egy1h0e47eze27j211s03cq3e.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;指令解释就是将这三步重复循环，其中要注意的点是栈帧中的pc和整体pc寄存器的值要保持一致。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;//循环解释\nfunc loop(thread *runtime.Thread) {\n    methodReader := &amp;amp;base.MethodCodeReader{}\n        for {\n        // 更新pc寄存器\n        updatePC(thread)\n        // 更新方法code\n        updateCodeArrt(thread, methodReader)\n        //执行指令\n        execInst(thread, methodReader)\n        if finished(thread) {\n                break\n        }\n    }\n}\n\n//执行\nfunc execInst(thread *runtime.Thread, reader *base.MethodCodeReader) {\n    curFrame := thread.PeekFrame()\n    //获取操作码\n    opcode := reader.ReadOpenCdoe()\n    //创建指令\n    inst := instructions.NewInstruction(opcode)\n    //获取操作数\n    inst.FetchOperands(reader)\n    curFrame.SetFramePC(reader.MethodReaderPC())\n    //执行指令\n    inst.Execute(curFrame)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;指令解释执行\&#34;&gt;指令解释执行&lt;/h3&gt;\n&lt;p&gt;获取到指令后，&lt;code&gt;inst.Execute(curFrame)&lt;/code&gt; 执行指令。每条指令都有各自的执行逻辑&lt;/p&gt;\n&lt;p&gt;每条指令都有不同的执行逻辑。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func iload_0(frame *runtime.Frame) {\n\tval := frame.LocalVars().GetInt(0)\n\tframe.OperandStack().PushInt(val)\n}\n\nfunc iload_1(frame *runtime.Frame) {\n\tval := frame.LocalVars().GetInt(1)\n\tframe.OperandStack().PushInt(val)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;i-i\&#34;&gt;i++ &amp;amp; ++i&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;int i = 1;\nprint(i++);  \nprint(++i);  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;编译后字节码两者是不同的，原因与java编译器的遍历AST（javac采用逆波兰表达算法）有关。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/268c4ab96e09427194ff1d0ac6ff94d3~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func (i *IINC) Execute(frame *runtime.Frame) {\n\tidx := i.Index &amp;gt;&amp;gt; 8         //局部变量表下标\n\ttoAdd := i.Index &amp;amp; 0x0011   //值\n\told := frame.LocalVars().GetInt(uint(idx)) \n\tframe.LocalVars().SetInt(uint(idx), int32(toAdd)+old) //设置新的值\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;i++ ：先把i保存到了操作数栈，然后再对局部变量表的i+1。&lt;/p&gt;\n&lt;p&gt;++i ：先对局部变量表的i+1，然后再把i保存到了操作数栈。&lt;/p&gt;\n&lt;h4 id=\&#34;ifelse关键字\&#34;&gt;if..else..关键字&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;public static void if_test() {\n    int n = 10;\n    GvmOut.to(&amp;quot;testing if&amp;quot;);\n    GvmOut.to(&amp;quot;10 &amp;gt; 9 ?&amp;quot;);\n    if (n &amp;gt; 9) {\n        GvmOut.to(&amp;quot;yes&amp;quot;);\n    } else {\n        GvmOut.to(&amp;quot;no&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5de568db80345d2ba675a334dc78683~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;for关键字\&#34;&gt;for..关键字&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;public static void for_test() {\n    GvmOut.to(&amp;quot;testing for&amp;quot;);\n    for (int i = 0; i &amp;lt; 5; i++) {\n        GvmOut.to(i);\n\t}\n}\n    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9b03ddacdcc42b2ac9061589646298b~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;// Execute to branch if and only if val1 great or equals val2\nfunc (icmp *IfIcmpge) Execute(frame *runtime.Frame) {\n\tval2 := frame.PopInt()      //弹出栈顶的int\n\tval1 := frame.PopInt()      //弹出栈顶的int\n\tgoNext := icmp.Index        //获取挑战地址\n\tif val1 &amp;gt;= val2 {           //比较\n\t\tbase.Branch(frame, int(goNext))  \n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;while\&#34;&gt;while&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void while_test() {\n    GvmOut.to(&amp;quot;testing while&amp;quot;);\n    int x = 100;\n    while (x &amp;lt; 105) {\n        x++;\n        GvmOut.to(x);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd42f104f9fd43079416b393a2624003~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;l7YU2lRvP&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在jvm中，定义了有205条指令，从0x00 -&amp;gt; 0xCA , 0xFE -&amp;gt; 0xFF。我们在方法中写的所有逻辑，最终都会转换成这些指令，而虚拟机的最重要的一个任务就是解释执行这些指令。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JVM 指令运行 解析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JVM&#34;,&#34;slug&#34;:&#34;jjLsZt3QW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/jjLsZt3QW/&#34;}],&#34;date&#34;:&#34;2021-02-17 11:19:49&#34;,&#34;dateFormat&#34;:&#34;2021-02-17 11:19:49&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/l7YU2lRvP/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:316000,&#34;words&#34;:1218,&#34;minutes&#34;:6},&#34;description&#34;:&#34;在jvm中，定义了有205条指令，从0x00 -&amp;gt; 0xCA , 0xFE -&amp;gt; 0xFF。我们在方法中写的所有逻辑，最终都会转换成这些指令，而虚拟机的最重要的一个任务就是解释执行这些指令。\n\nJVM指令集\n指令类型种类很多\n\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#jvm%E6%8C%87%E4%BB%A4%E9%9B%86\&#34;&gt;JVM指令集&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F\&#34;&gt;指令格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B6%85%E7%BA%A7%E6%8C%87%E4%BB%A4\&#34;&gt;超级指令&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E6%B5%81%E8%8E%B7%E5%8F%96\&#34;&gt;指令流获取&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A%E8%BF%87%E7%A8%8B\&#34;&gt;指令的解释过程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C\&#34;&gt;指令解释执行&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#i-i\&#34;&gt;i++ &amp;amp; ++i&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ifelse%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;if..else..关键字&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#for%E5%85%B3%E9%94%AE%E5%AD%97\&#34;&gt;for..关键字&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#while\&#34;&gt;while&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;项目代码：&lt;a href=\&#34;https://github.com/zexho994/gvm\&#34;&gt;https://github.com/zexho994/gvm&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;虚拟机整体的流程\&#34;&gt;虚拟机整体的流程&lt;/h2&gt;\n&lt;h2 id=\&#34;不同类型的虚拟机\&#34;&gt;不同类型的虚拟机&lt;/h2&gt;\n&lt;p&gt;从解释器的实现方式上来看，有两种类型的虚拟机执行架构。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;基于栈结构&lt;/li&gt;\n&lt;li&gt;基于寄存器&lt;br&gt;\njvm家族的虚拟机基本都是基于栈的，基于栈的实现稍微简单，移植性高。基于寄存器的虚拟机和cpu的执行方式类似，性能更快，例如v8。Lua虚拟机从5.0之前是栈虚拟机，5.0时转变为寄存器虚拟机&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Lars Bak 是v8的作者，也是hotspot的作者之一，还是Dart语言的作者。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;栈虚拟机\&#34;&gt;栈虚拟机&lt;/h3&gt;\n&lt;p&gt;一段java代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void foo(){\n\tint a = 1;  \n    int b = 2;  \n    int c = a*b;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在不同类型的虚拟机中，要执行这段代码，首先编译的方式也会有不同,在基于栈的虚拟机中，编译后的指令为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void fooj();\n    Code:\n       0: iconst_1   //常量1存入到操作数栈\n       1: istore_1   //操作数栈顶pop到局部变量表1\n       2: iconst_2   \n       3: istore_2\n       4: iload_1    //局部变量表索引1数push到操作数栈\n       5: iload_2    \n       6: iadd       //操作数栈顶两个数相加\n       7: iconst_5\n       8: imul       //操作数栈顶两个数相乘\n       9: istore_3\n      10: return  \n          \n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dffe4e0c06c44ec1a3d74146ab023cd1~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;寄存器虚拟机\&#34;&gt;寄存器虚拟机&lt;/h3&gt;\n&lt;p&gt;和汇编的风格类似，因为cpu本质上也是一个基于寄存器的解释器。寄存器虚拟机最大的优点就是性能好，支持随机访问，相比起来栈虚拟机的指令执行就显得十分麻烦的。&lt;/p&gt;\n&lt;p&gt;在基于寄存器的虚拟机中：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;add ax bx\t//其中AX寄存器的值为1,BX寄存器的值为2，将结果放入AX\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c9bd9e740241a3b9e8154f39a15106~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;虚拟机类型的抉择\&#34;&gt;虚拟机类型的抉择&lt;/h3&gt;\n&lt;p&gt;为什么JVM选择了使用栈虚拟机的方式? 原因有很多，从历史的角度上看：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;栈虚拟机中，指令的平台无关性好。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;栈虚拟机的优点之一是指令更短，只用1字节，而基于寄存器的需要额外保存地址，一般为2字节。在当时，内存是比较重要的。&lt;/li&gt;\n&lt;li&gt;James Gosling 对这种方式的实现比较熟悉（之前他实现了PostScript虚拟机）。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;对java的影响\&#34;&gt;对Java的影响&lt;/h3&gt;\n&lt;p&gt;指令重排序之一的编译器重排序，是IR优化阶段的一种手段，叫表达式提升、表达式下沉。&lt;/p&gt;\n&lt;p&gt;优化的原因之一就是考虑栈的特性。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a=1;         b=2;\nb=2;         a=1;\nc=a+1;  ==&amp;gt;  c=a+1;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;方法执行\&#34;&gt;方法执行&lt;/h2&gt;\n&lt;h3 id=\&#34;栈帧\&#34;&gt;栈帧&lt;/h3&gt;\n&lt;p&gt;栈帧是方法的执行单位，一个方法对应一个栈帧。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;//栈帧\ntype Frame struct {\n\tframePC   uint\n\tnextFrame *Frame\n\t*LocalVars\n\t*OperandStack\n\t*klass.MethodKlass\n\t*Thread\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1478dbbbd6704bbe98da7eea1d55b726~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h3&gt;\n&lt;h3 id=\&#34;虚拟机栈\&#34;&gt;虚拟机栈&lt;/h3&gt;\n&lt;p&gt;虚拟机栈是线程私有的，用于存放栈帧。当一个方法准备执行时候，栈帧push进行，完成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;//线程模型\ntype Thread struct {\n    ...\n\t*Stack  //虚拟机栈,存放栈帧\n    ...\n}\n//虚拟机栈\ntype Stack struct {\n    ...\n\t// 栈最大大小\n\tmaxSize uint\n\t// 当前栈的大小\n\tsize uint\n\t// 顶层帧\n\ttop *Frame\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;-2\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edf832f25aed447c87e2fc26fd868add~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/h3&gt;\n&lt;h3 id=\&#34;局部变量表和操作数栈size\&#34;&gt;局部变量表和操作数栈size&lt;/h3&gt;\n&lt;p&gt;局部变量表和操作数栈的大小如何确定？在code属性表中，MaxStack表示栈的最大深度，MaxLocals表示局部变量表的最大深度。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc1b27cd5c64897ba2677d8cdaffe6f~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;type Attr_Code struct {\n\tNameIdx uint16\n\tname    string\n\tAttrLen uint32\n\tcp      constant_pool.ConstantPool\n\t// 方法的操作数栈在任何时间点的最大深度，在编译期就可以确定\n\tMaxStack uint16\n\t// 局部变量表大小，包括方法的参数\n\tMaxLocals uint16\n\tcodeLen   uint32\n\tcode      []byte\n\t// 异常表\n\tExceptionTable []*ExceptionTable\n\t// 属性表\n\tattrCount uint16\n\tattrInfo  AttributesInfo\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;两个值的大小已经在编译期间确定，在字节码中保存，最后在类加载过程中，获取这两个字段。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func (c *Attr_Code) parse(reader *classfile.ClassReader) {\n\tc.MaxStack = reader.ReadUint16()\n\tc.MaxLocals = reader.ReadUint16()\n\tc.codeLen = reader.ReadUint32()\n\tc.code = reader.ReadBytes(c.codeLen)\n\tc.ExceptionTable = parseExceptionTable(reader)\n\tc.attrCount = reader.ReadUint16()\n\tc.attrInfo = ParseAttributes(c.attrCount, reader, c.cp)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;方法调用\&#34;&gt;方法调用&lt;/h2&gt;\n&lt;h3 id=\&#34;invoke-指令簇\&#34;&gt;Invoke 指令簇&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;invokeinterface : 调用接口方法&lt;/li&gt;\n&lt;li&gt;invokespecial : 调用实例方法，（父类方法、私有方法、实例初始化方法）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;invokevirtual : 调用虚方法，会根据实例的类型进行分派&lt;/li&gt;\n&lt;li&gt;invokestatic : 调用静态方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!----&gt;\n&lt;ul&gt;\n&lt;li&gt;invokedynamic : 调用动态方法(java7新增，支持动态语言的方法调用)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用执行逻辑\&#34;&gt;调用执行逻辑&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Invokevirtual {\n    \n    public static void main(String[] args) {\n        Invokevirtual invokevirtual = new Invokevirtual();\n        int res = invokevirtual.additive(1, 2);\n        GvmOut.to(res);\n    }\n\n    public int additive(int x, int y) {\n        int r = x + y;\n        return r;\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;java中函数调用如何实现？&lt;br&gt;\nmain方法的code指令流：&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9610b89aa564ef08ab23c577af54559~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;additive方法的code指令流：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c31c3e99e2c04fd2b774172edde8fd13~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91cbecea94264be485a5a7dc87f010df~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;静态绑定与动态绑定\&#34;&gt;静态绑定与动态绑定&lt;/h2&gt;\n&lt;p&gt;网上很多文章对于这两者的解释为重载是静态绑定（编译时多态），重写是动态绑定。其实不完全正确，重载也可能被子类重写的情况，一样需要在运行期间判断。&lt;/p&gt;\n&lt;p&gt;准确地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。概括就是&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;静态绑定&lt;/strong&gt;只在编译期间就可以知道具体要调用的方法。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;动态绑定&lt;/strong&gt;指要到运行期间才能知道要调用的方法。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在invoke命令中，invokestatic对应的为静态绑定（使用static修饰），invokevirtual、invokeinterface为动态绑定的。&lt;/p&gt;\n&lt;p&gt;用代码进行说明就是&lt;/p&gt;\n&lt;h4 id=\&#34;invokestatic的逻辑\&#34;&gt;invokestatic的逻辑&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func (i *INVOKE_STATIC) Execute(frame *runtime.Frame) {\n\tcp := frame.Method().CP()\n\tcontantMethod := cp.GetConstantInfo(i.Index).(*constant_pool.ConstantMethod)\n\tclassName := contantMethod.ClassName()\n\tperm := jclass.GetPerm()\n\tclass := perm.Space[className]\n\tif class == nil {\n\t\tclass = jclass.ParseInstanceByClassName(className)\n\t}\n\tname, _type := contantMethod.NameAndDescriptor()\n\tmethodInfo, err := class.FindStaticMethod(name, _type)        //获取目标方法\n\tif err != nil {\n\t\tpanic(&amp;quot;[gvm]&amp;quot; + err.Error())\n\t}\n\tif !jclass.IsStatic(methodInfo.AccessFlag()) {\n\t\tpanic(&amp;quot;[gvm] invoke static error&amp;quot;)\n\t}\n\tmethodInfo.SetJClass(class)\n\tbase.InvokeMethod(frame, methodInfo, true)\n}\n\nfunc (j JClass_Instance) FindStaticMethod(name, descriptor string) (*MethodInfo, error) {       // 在本类中获取\n\tfor i := range j.Methods {\n\t\tmethodInfo := j.Methods[i]\n\t\tif !IsStatic(methodInfo.accessFlag) {\n\t\t\tcontinue\n\t\t}\n\t\tmName := j.ConstantPool.GetUtf8(methodInfo.nameIdx)\n\t\tmDesc := j.ConstantPool.GetUtf8(methodInfo.descriptorIdx)\n\t\tif name != mName || mDesc != descriptor {\n\t\t\tcontinue\n\t\t}\n\t\treturn j.Methods[i], nil\n\t}\n\treturn nil, exception.GvmError{Msg: &amp;quot;not find static method it name &amp;quot; + name}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;invokevirtual的逻辑\&#34;&gt;invokevirtual的逻辑&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func (i *INVOKE_VIRTUAL) Execute(frame *runtime.Frame) {\n\tconstantMethod := frame.Method().CP().GetConstantInfo(i.Index).(*constant_pool.ConstantMethod)\n\tmethodNameStr, methodDescStr := constantMethod.NameAndDescriptor()\n\texception.AssertTrue(methodNameStr != &amp;quot;&amp;lt;init&amp;gt;&amp;quot; &amp;amp;&amp;amp; methodNameStr != &amp;quot;&amp;lt;clinit&amp;gt;&amp;quot;, &amp;quot;IncompatibleClassChangeError&amp;quot;)\n\n\tclassNameStr := constantMethod.ClassName()\n\tpermSpace := jclass.GetPerm().Space\n\tjc := permSpace[classNameStr]\n\tif jc == nil {\n\t\tjc = jclass.ParseInstanceByClassName(classNameStr)\n\t}\n\texception.AssertTrue(jc != nil, &amp;quot;NullPointerException&amp;quot;)\n    \n    //*****查找目标实例方法*****\n\tmethodInfo, err, _ := jc.FindMethod(methodNameStr, methodDescStr)     \n\texception.AssertTrue(err == nil, &amp;quot;no find the method of &amp;quot;+methodNameStr)\n\texception.AssertFalse(jclass.IsStatic(methodInfo.AccessFlag()), &amp;quot;IncompatibleClassChangeError&amp;quot;)\n\n\tif jclass.IsProteced(methodInfo.AccessFlag()) {\n\t\t// todo if is proteced , need to judge the relation between caller and called\n\t}\n\n\tbase.InvokeMethod(frame, methodInfo, false)\n}\n\n\nfunc (j *JClass_Instance) FindMethod(name, descriptor string) (*MethodInfo, error, *JClass_Instance) {\n\tfor i := range j.Methods {\n\t\tmethodInfo := j.Methods[i]\n\t\tif IsStatic(methodInfo.accessFlag) {\n\t\t\tcontinue\n\t\t}\n\t\tmName := j.ConstantPool.GetUtf8(methodInfo.nameIdx)\n\t\tmDesc := j.ConstantPool.GetUtf8(methodInfo.descriptorIdx)\n\t\tif mName == name &amp;amp;&amp;amp; mDesc == descriptor {\n\t\t\treturn j.Methods[i], nil, j\n\t\t}\n\t}\n\t// 在父类中遍历查找\n\tm, err, jc := j.SuperClass.FindMethod(name, descriptor)\n\tif err == nil {\n\t\treturn m, nil, jc\n\t}\n\t// 在接口中遍历查找\n\tfor i := range j.Interfaces {\n\t\tm, err, jc := j.Interfaces[i].FindMethod(name, descriptor)\n\t\tif err == nil {\n\t\t\treturn m, nil, jc\n\t\t}\n\t}\n\treturn nil, exception.GvmError{Msg: &amp;quot;not find method it name &amp;quot; + name}, nil\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;jni方法简述\&#34;&gt;JNI方法简述&lt;/h2&gt;\n&lt;p&gt;有一些场景中，java本身没有能力去完成，最常见的就是当要系统调用时候,就要使用JNI（Java Native Interface）这种方式。&lt;/p&gt;\n&lt;p&gt;例如nio中的Selector&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private native int poll0(long var1, int var3, long var4);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;unsafe.cas&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种方式本质上也是调用另一个地方的函数，链接的工作由虚拟机完成。GvmOut是invoke调用时基于Go的Print方法实现，使用native方法可以进行非常多的扩展操作。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class GvmOut{\n    public native static void to(int i);\n    public native static void to(float i);\n    public native static void to(double i);\n    public native static void to(boolean i);\n    public native static void to(long i);\n    public native static void to(String i);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;参考\&#34;&gt;参考：&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.zhihu.com/question/35777031\&#34;&gt;栈式虚拟机和寄存器式虚拟机？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://www.iteye.com/blog/rednaxelafx-492667\&#34;&gt;虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩 - Script Ahead, Code Behind - ITeye博客&lt;/a&gt;&lt;br&gt;\n-《虚拟机规范(SE8)》&lt;br&gt;\n-《自己动手些虚拟机》&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;65lQ_SxQ1&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;项目代码：&lt;a href=\&#34;https://github.com/zexho994/gvm\&#34;&gt;https://github.com/zexho994/gvm&lt;/a&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;JVM 方法调用与执行&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JVM&#34;,&#34;slug&#34;:&#34;jjLsZt3QW&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/jjLsZt3QW/&#34;}],&#34;date&#34;:&#34;2021-02-02 22:31:28&#34;,&#34;dateFormat&#34;:&#34;2021-02-02 10:31:28&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/65lQ_SxQ1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:510000,&#34;words&#34;:1962,&#34;minutes&#34;:9},&#34;description&#34;:&#34;\n项目代码：https://github.com/zexho994/gvm\n\n\n虚拟机整体的流程\n不同类型的虚拟机\n从解释器的实现方式上来看，有两种类型的虚拟机执行架构。\n\n基于栈结构\n基于寄存器\njvm家族的虚拟机基本都是基于栈的，基于栈...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E4%BD%93%E7%9A%84%E6%B5%81%E7%A8%8B\&#34;&gt;虚拟机整体的流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA\&#34;&gt;不同类型的虚拟机&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%88%E8%99%9A%E6%8B%9F%E6%9C%BA\&#34;&gt;栈虚拟机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E5%AD%98%E5%99%A8%E8%99%9A%E6%8B%9F%E6%9C%BA\&#34;&gt;寄存器虚拟机&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8A%89%E6%8B%A9\&#34;&gt;虚拟机类型的抉择&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9java%E7%9A%84%E5%BD%B1%E5%93%8D\&#34;&gt;对Java的影响&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C\&#34;&gt;方法执行&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%88%E5%B8%A7\&#34;&gt;栈帧&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#\&#34;&gt;!&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\&#34;&gt;虚拟机栈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#-2\&#34;&gt;!&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88size\&#34;&gt;局部变量表和操作数栈size&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\&#34;&gt;方法调用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#invoke-%E6%8C%87%E4%BB%A4%E7%B0%87\&#34;&gt;Invoke 指令簇&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91\&#34;&gt;调用执行逻辑&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A\&#34;&gt;静态绑定与动态绑定&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokestatic%E7%9A%84%E9%80%BB%E8%BE%91\&#34;&gt;invokestatic的逻辑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#invokevirtual%E7%9A%84%E9%80%BB%E8%BE%91\&#34;&gt;invokevirtual的逻辑&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jni%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0\&#34;&gt;JNI方法简述&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%82%E8%80%83\&#34;&gt;参考：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;github地址：https://github.com/zexho994/IOC-AOP&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;核心实现\&#34;&gt;核心实现&lt;/h1&gt;\n&lt;h3 id=\&#34;流程\&#34;&gt;流程&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba70855125c48d280678e5d1538979d~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;bean的声明\&#34;&gt;Bean的声明&lt;/h3&gt;\n&lt;p&gt;以注解的方式为例，在类上添加@Bean注解即表示该Class为一个Bean，例如：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic class BeanTest1 implements BeanTest {\n\n    @Override\n    public void print() {\n        System.out.println(&amp;quot;BeanTest1&amp;quot;);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在项目启动的时候会扫描目录下所有的Class，流程如下:&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/585f5fd3ead84ba491753ffa4276d292~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; findAllBean() {\n    ClassLoader contextClassLoader = getDefaultClassLoader();  //获取默认类加载器\n    List&amp;lt;String&amp;gt; classes = scanClasses(contextClassLoader);    //扫描所有Class类\n    return filtersAndLoadBeans(classes, contextClassLoader);   //过滤，获取所有Bean\n}\n\npublic void loadBean() {\n    BeanScanner\n        .findAllBean()\n        .forEach(bean -&amp;gt; AnnotationDefinitionLoaderRegistry.\n                 this.register(bean.getSimpleName(), bean));  //注册所有的bean\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;具体的的代码细节不详细展开，需要的可以看源码。&lt;/p&gt;\n&lt;p&gt;到此，所有的Bean都已经保存到了map结构中，当需要使用Bean的时候根据bean name进行获取就好了。&lt;/p&gt;\n&lt;h3 id=\&#34;autowired实现\&#34;&gt;@Autowired实现&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d52d41f1d9d4b7fa7da3e63563931e7~tplv-k3u1fbpfcp-watermark.image\&#34; alt=\&#34;image.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic class AutowiredTest {\n\n    @Autowired\n    public BeanTest1 beanTest1;\n    @Autowired\n    public BeanTest2 beanTest2;\n\n    public void print1() {\n        beanTest1.print();\n    }\n\n    public void print2() {\n        beanTest2.print();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 初始化bean\nprivate void initBean(BeanDefinition beanDefinition) throws IllegalAccessException {\n    Object instance = beanDefinition.getInstance();\n\n    // 初始化Autowired\n    this.initAutowire(instance);\n\n    beanDefinition.setStatusInitialized();\n}\n\n/** \n* 设置bean里面的注入字段\n*/\nprivate void initAutowire(Object instance) throws IllegalAccessException {\n    // 获取所有字段，如果有Autowired注解，获取该bean，然后赋值给字段\n    for (Field field : instance.getClass().getFields()) {\n        if (field.getDeclaredAnnotationsByType(Autowired.class).length == 0) {\n            continue;\n        }\n        Class&amp;lt;?&amp;gt; fieldType = field.getType();\n        Object bean = this.getBean(fieldType.getSimpleName());\n        field.set(instance, bean);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;解决循环依赖\&#34;&gt;解决循环依赖&lt;/h1&gt;\n&lt;p&gt;在spring中使用“3级缓存”来解决循环依赖问题，不要纠结spring为何要使用3个map来实现，抛开实现的细节，从问题原因着手，这个问题其实使用很好理解。&lt;/p&gt;\n&lt;h2 id=\&#34;何为循环依赖\&#34;&gt;何为循环依赖？&lt;/h2&gt;\n&lt;p&gt;下面的A和B就互相依赖彼此，这样就会有一个问题，在创建A的时候需要创建B，但是创建B的时候又需要创建A，看起来像是一个先有鸡还是蛋的问题。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;@Bean\npublic class ClassA {\n    @Autowired\n    public ClassB ib;\n\n}\n\n@Bean\npublic class ClassB {\n    @Autowired\n    public ClassA ia;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是要知道Bean的创建其实是分为多个步骤的，就好理解了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-mermaid\&#34;&gt;graph LR\nn0(start) --&amp;gt; n1(创建instance) --&amp;gt; n2(填充需要注入的fields字段) --&amp;gt; n3(end)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在创建完instance后，里面的字段其实都还是null的,例如已经创建ClassA实例a，和ClassB实例b，此时&lt;code&gt;a.ib = null&lt;/code&gt;和&lt;code&gt;b.ia = null&lt;/code&gt;. 然后赋值 &lt;code&gt;a.ib = b&lt;/code&gt; 和 &lt;code&gt;b.ia = a&lt;/code&gt;，这之后，a和b中的字段都赋值完了，且都是完整可用的对象了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public Object getBean(String beanName) {\n    BeanDefinition bean = this.getBeanInstance(beanName);\n    if (!bean.isInit()) {\n        try {\n            this.initBean(bean);\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n    return bean.getInstance();\n}\n\n// 初始化bean\nprivate void initBean(BeanDefinition beanDefinition) throws IllegalAccessException {\n    Object instance = beanDefinition.getInstance(); // 获取bean的isntance\n    beanDefinition.setStatusInitialized();  //设置为已初始化\n    this.initAutowire(instance);\n}\n\n// 遍历所有字段，为有@Authwired注解的实现注入\nprivate void initAutowire(Object instance) throws IllegalAccessException {\n    Field[] fields = instance.getClass().getFields();\n    for (Field field : fields) {\n        if (field.getDeclaredAnnotationsByType(Autowired.class).length == 0) {\n            continue;\n        }\n        Class&amp;lt;?&amp;gt; fieldType = field.getType();\n        Object bean = this.getBean(fieldType.getSimpleName());\n        field.set(instance, bean);  //field赋值\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有一个比较好的类比，leetcode的一道算法题two sum &lt;a href=\&#34;https://leetcode-cn.com/problems/two-sum/\&#34;&gt;https://leetcode-cn.com/problems/two-sum/&lt;/a&gt;，其中一种题解就是遍历一边，存储所有值和索引到map中，然后遍历一次map，每次判断是否有要的数。&lt;/p&gt;\n&lt;p&gt;这个也是，先讲instance存到map中，然后把map中instance的fields都进行填充，就可以了。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ioc_2&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;github地址：https://github.com/zexho994/IOC-AOP&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;参考Spring实现 IOC（下）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;P-ZT7Pj1-8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/P-ZT7Pj1-8/&#34;},{&#34;name&#34;:&#34;造轮子&#34;,&#34;slug&#34;:&#34;KrLfgh9WlS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/&#34;}],&#34;date&#34;:&#34;2020-10-30 19:36:08&#34;,&#34;dateFormat&#34;:&#34;2020-10-30 07:36:08&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/ioc_2/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:211000,&#34;words&#34;:795,&#34;minutes&#34;:4},&#34;description&#34;:&#34;github地址：https://github.com/zexho994/IOC-AOP\n\n核心实现\n流程\n\nBean的声明\n以注解的方式为例，在类上添加@Bean注解即表示该Class为一个Bean，例如：\n@Bean\npublic cl...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0\&#34;&gt;核心实现&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%81%E7%A8%8B\&#34;&gt;流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bean%E7%9A%84%E5%A3%B0%E6%98%8E\&#34;&gt;Bean的声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#autowired%E5%AE%9E%E7%8E%B0\&#34;&gt;@Autowired实现&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96\&#34;&gt;解决循环依赖&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%95%E4%B8%BA%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96\&#34;&gt;何为循环依赖？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;基本概念\&#34;&gt;基本概念&lt;/h1&gt;\n&lt;h3 id=\&#34;控制反转和依赖注入\&#34;&gt;控制反转和依赖注入&lt;/h3&gt;\n&lt;blockquote&gt;\n&lt;p&gt;控制反转（IOC），依赖注入（DI）&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;什么是控制反转？简单的说，控制反转就是一种思想，目的是将对象的创建由主动变成被动。&lt;br&gt;\n下面的实例就是主动new了一个对象。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Service{\n    public DependObject object1 = new DenpendObject();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么如何做到不使用new呢？依赖注入便是其中一种实现方式。&lt;/p&gt;\n&lt;p&gt;依赖注入的方式有三种&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;构造器注入&lt;/li&gt;\n&lt;li&gt;setter注入&lt;/li&gt;\n&lt;li&gt;接口注入&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Service{\n    public DependObject object;\n\n    // 构造器注入\n    public Service (DependObject obj){\n        this.object = obj;\n    }\n\n    // setter注入\n    public void setDependObject(DependObject obj){\n        this.object = obj;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到，对象的生命周期不再由Service类中主动创建，而是通过注入的方式赋值。&lt;br&gt;\n顺便比较一下3中方式的优劣：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;接口注入：&lt;/strong&gt; 从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退 役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter 方法注入则不需要如此。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;构造方法注入：&lt;/strong&gt; 这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以 马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反 射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且 在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多 个构造方法，而参数数量的变动可能造成维护上的不便。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;setter方法注入：&lt;/strong&gt; 因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外， setter方法可以被继承， 允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无 法在构造完成后马上进入就绪状态。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;ioc容器\&#34;&gt;IOC容器&lt;/h3&gt;\n&lt;p&gt;为了所有对象的统一管理，需要有一个角色负责将这些相互依赖的对象绑定到一起，IOC容器就是这样一个角色。它的主要职责可以分为两个：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;业务对象的构建管理：例如如何加载类，管理类的生命周期等。&lt;/li&gt;\n&lt;li&gt;业务对象间的依赖绑定：提供构建好的对象给业务方使用。&lt;br&gt;\n总结就是创建和绑定&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;IOC容器如何知道管理哪些对象呢？本系列将实现两种方式：1.使用编码申明，2. 使用注解@Bean声明，熟悉Spring的知道常用的还有XML的方式，这个可以自行实现。&lt;/p&gt;\n&lt;p&gt;在Spring中，使用Bean的概念表示IOC管理的对象，在这里依然采用这种定义方式，下篇文章介绍IOC模块的结构设计。&lt;/p&gt;\n&lt;h3 id=\&#34;拓展阅读\&#34;&gt;拓展阅读&lt;/h3&gt;\n&lt;p&gt;对IOC的基本概念不熟悉的可以阅读：&lt;br&gt;\n《spring揭密》2.1 IOC基本概念&lt;/p&gt;\n&lt;h1 id=\&#34;预期实现效果\&#34;&gt;预期实现效果&lt;/h1&gt;\n&lt;h2 id=\&#34;bean的声明方式\&#34;&gt;Bean的声明方式&lt;/h2&gt;\n&lt;h3 id=\&#34;通过编码方式进行声明\&#34;&gt;通过编码方式进行声明&lt;/h3&gt;\n&lt;p&gt;继承CodeDefinitionLoderRegistry类，重写loadBean()方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class MyCodeBeanDefinition extends CodeDefinitionLoaderRegistry {\n\n    @Override\n    public void loadBean() {\n        this.register(&amp;quot;BeanTest1&amp;quot;, BeanTest1.class);\n        this.register(&amp;quot;BeanTest2&amp;quot;, BeanTest2.class);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后编码使用register(bean的名称，bean所对应类)进行注册，和XML的声明方式是类似的。&lt;/p&gt;\n&lt;h3 id=\&#34;通过注解bean的方式声明\&#34;&gt;通过注解@Bean的方式声明&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic class BeanTest1 implements BeanTest {\n\n    @Override\n    public void print() {\n        System.out.println(&amp;quot;BeanTest1&amp;quot;);\n    }\n\n}\n\n@Bean\npublic class BeanTest2 implements BeanTest {\n\n    @Override\n    public void print() {\n        System.out.println(&amp;quot;BeanTest2&amp;quot;);\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;获取bean\&#34;&gt;获取Bean&lt;/h2&gt;\n&lt;h3 id=\&#34;从工厂中获取bean\&#34;&gt;从工厂中获取Bean&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void foo() {\n\n    // 第一步：c根据声明的方式选择 1 or 2\n    // 方式一： 创建注册类,注册类中使用编码实现注册逻辑\n    AbstractDefinitionLoaderRegistry registry = new MyCodeBeanDefinition();\n    // 方式二： 创建注册类,Bean通过注解的方式自动注入\n    AbstractDefinitionLoaderRegistry registry = new AnnotationDefinitionLoaderRegistry();\n    \n    // 第二步：注册类添加到工厂中\n    ApplicationContext factory = new ApplicationContext(registry);\n\n    // 第三步：获取Bean\n    BeanTest obj1 = factory.getBeanInstance(&amp;quot;BeanTest1&amp;quot;, BeanTest1.class);\n    BeanTest obj2 = factory.getBeanInstance(&amp;quot;BeanTest2&amp;quot;, BeanTest2.class);\n    \n    obj1.print();\n    obj2.print();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;通过注解自动注入bean\&#34;&gt;通过注解自动注入Bean&lt;/h3&gt;\n&lt;p&gt;使用@Autowired自动注入&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;@Bean\npublic class AutowiredTest {\n\n    @Autowired\n    public BeanTest1 beanTest1;\n    @Autowired\n    public BeanTest2 beanTest2;\n\n    public void print1() {\n        beanTest1.print();\n    }\n\n    public void print2() {\n        beanTest2.print();\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;项目组织结构\&#34;&gt;项目组织结构&lt;/h1&gt;\n&lt;h2 id=\&#34;spring中的ioc设计\&#34;&gt;Spring中的IOC设计&lt;/h2&gt;\n&lt;p&gt;spring中ioc模块可以分为3中角色，分别对应3个最顶层接口：&lt;br&gt;\n&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c03834b5a348a18794a7ee8aed7546~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;通俗的理解：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;BeanDefinition: 就是我们常说的Bean，理解为图书。&lt;/li&gt;\n&lt;li&gt;BeanDefinitionRegistry: 书架，存放书的地方。&lt;/li&gt;\n&lt;li&gt;BeanFactory: 图书馆，借书的地方。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;在我们的实现中，同样使用了这3个概念，看下3个接口都有哪些方法：&lt;/p&gt;\n&lt;h3 id=\&#34;beandefinition\&#34;&gt;BeanDefinition&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface BeanDefinition {\n    // 0表示未初始化\n    int STATUS_UNINITIALIZED = 0;\n    // 1表示已初始化\n    int STATUS_INITIALIZED = 1;\n\n    /**\n     * Sets name.\n     *\n     * @param beanClassName the bean class name\n     */\n    void setName(String beanClassName);\n\n    /**\n     * Gets name.\n     *\n     * @return the name\n     */\n    String getName();\n\n    /**\n     * Sets instance.\n     *\n     * @param instance the instance\n     */\n    void setInstance(Object instance);\n\n    /**\n     * Gets instance.\n     *\n     * @return the instance\n     */\n    Object getInstance();\n\n    /**\n     * Gets bean class.\n     *\n     * @return bean class\n     */\n    Class&amp;lt;?&amp;gt; getBeanClass();\n\n    /**\n     * 判断bean是否有初始化\n     *\n     * @return status == {@link #STATUS_INITIALIZED} ?\n     */\n    Boolean isInit();\n\n    /**\n     * set status to {@link #STATUS_INITIALIZED}\n     */\n    void setStatusInitialized();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;beandefinitionregistry\&#34;&gt;BeanDefinitionRegistry&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface BeanDefinitionRegistry {\n\n    /**\n     * 注册一个新的Bean\n     *\n     * @param beanName       bean的注册使用名称\n     * @param beanDefinition bean的类型\n     */\n    void registerBean(String beanName, BeanDefinition beanDefinition);\n\n    /**\n     * 移除一个Bean\n     *\n     * @param beanName 要移除的Bean的名称\n     */\n    void removeBean(String beanName);\n\n    /**\n     * 根据名称获取Bean\n     *\n     * @param beanName bean名称\n     * @return 已注册的 {@link BeanDefinition} 对象\n     */\n    BeanDefinition getBean(String beanName);\n\n    /**\n     * 获取Bean\n     * {@link BeanDefinition}\n     *\n     * @param beanName     bean名称\n     * @param requiredType bean类型，会进行校验\n     * @return 已注册的 {@link BeanDefinition} 对象\n     */\n    &amp;lt;T&amp;gt; BeanDefinition getBean(String beanName, Class&amp;lt;T&amp;gt; requiredType);\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;beanfactory\&#34;&gt;BeanFactory&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface BeanFactory {\n\n    /**\n     * 根据名称获取bean\n     *\n     * @param beanName bean名称\n     * @return bean名称对应的Bean\n     */\n    BeanDefinition getBeanInstance(String beanName);\n\n    /**\n     * 根据名称获取一个bean\n     *\n     * @param beanName     bean的名称\n     * @param requiredType bean类型\n     * @return bean名称对应的Bean\n     */\n    &amp;lt;T&amp;gt; T getBeanInstance(String beanName, Class&amp;lt;T&amp;gt; requiredType);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;我们的ioc类图\&#34;&gt;我们的IOC类图&lt;/h3&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a49e7bfb13849aeb2e2c96eccd438cb~tplv-k3u1fbpfcp-zoom-1.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n对3个顶层接口都添加了默认实现类，其中比较重要的几个点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;BeanDefinitionRegistry 使用Map进行Bean的存储，Key为Bean的名称，Val为BeanDefinition&lt;/li&gt;\n&lt;li&gt;BeanDefinition中有3个字段&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private String beanName;  //bean名称\nprivate T beanInstance = null; // bean的实例\nprivate final Class&amp;lt;T&amp;gt; beanClass; //bean对应的class\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;\n&lt;li&gt;BeanFactory中存储BeanDefinitionRegistry类，封装获取bean的接口，工厂对外提供&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ioc_1&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;参考Spring实现 IOC（上）&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;P-ZT7Pj1-8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/P-ZT7Pj1-8/&#34;},{&#34;name&#34;:&#34;造轮子&#34;,&#34;slug&#34;:&#34;KrLfgh9WlS&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/&#34;}],&#34;date&#34;:&#34;2020-10-17 15:29:12&#34;,&#34;dateFormat&#34;:&#34;2020-10-17 03:29:12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/ioc_1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:379000,&#34;words&#34;:1553,&#34;minutes&#34;:7},&#34;description&#34;:&#34;基本概念\n控制反转和依赖注入\n\n控制反转（IOC），依赖注入（DI）\n\n什么是控制反转？简单的说，控制反转就是一种思想，目的是将对象的创建由主动变成被动。\n下面的实例就是主动new了一个对象。\npublic class Service{\n ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\&#34;&gt;基本概念&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5\&#34;&gt;控制反转和依赖注入&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ioc%E5%AE%B9%E5%99%A8\&#34;&gt;IOC容器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB\&#34;&gt;拓展阅读&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%84%E6%9C%9F%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C\&#34;&gt;预期实现效果&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#bean%E7%9A%84%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F\&#34;&gt;Bean的声明方式&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E8%BF%87%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%A3%B0%E6%98%8E\&#34;&gt;通过编码方式进行声明&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3bean%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A3%B0%E6%98%8E\&#34;&gt;通过注解@Bean的方式声明&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96bean\&#34;&gt;获取Bean&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%B7%A5%E5%8E%82%E4%B8%AD%E8%8E%B7%E5%8F%96bean\&#34;&gt;从工厂中获取Bean&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5bean\&#34;&gt;通过注解自动注入Bean&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84\&#34;&gt;项目组织结构&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#spring%E4%B8%AD%E7%9A%84ioc%E8%AE%BE%E8%AE%A1\&#34;&gt;Spring中的IOC设计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#beandefinition\&#34;&gt;BeanDefinition&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#beandefinitionregistry\&#34;&gt;BeanDefinitionRegistry&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#beanfactory\&#34;&gt;BeanFactory&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%88%91%E4%BB%AC%E7%9A%84ioc%E7%B1%BB%E5%9B%BE\&#34;&gt;我们的IOC类图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;找到License.class&lt;br&gt;\n在words的jar包中找到License类.验证方法入口在这里&lt;br&gt;\n虽然有两个setLicense（）方法，细心点看，最后调用的都是zzV方法，只是不同的重载。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class License {\n    private zz2B zzYIM = zz2B.zzoF();\n\n    public License() {\n    }\n\n    public void setLicense(String licenseName) throws Exception {\n        if (licenseName == null) {\n            throw new NullPointerException(this.zzYIM.zzZu(new byte[]{108, 105, 99, 101, 110, 115, 101, 78, 97, 109, 101}));\n        } else {\n            (new zzZJ5()).zzV(licenseName, zzZY2.zzkc());\n        }\n    }\n\n    public void setLicense(InputStream stream) throws Exception {\n        if (stream == null) {\n            throw new NullPointerException(this.zzYIM.zzZu(new byte[]{115, 116, 114, 101, 97, 109}));\n        } else {\n            (new zzZJ5()).zzV(stream);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;进入zzV()方法&lt;br&gt;\n在zzV()方法下面有两个方法，类似于下面这样。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;zzZaQ就是要修改的方法。让他始终返回1就好了&lt;/strong&gt;。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;static int zzZaQ() {\n        boolean var0 = zzYIF == null || zzYIF.zzYIH == 0 || (new Date()).after(zzYIF.zzYII) || zzYNP.zzYlS() == 4096;\n        boolean var1 = zzZE1.zzYZQ() == 0;\n        int var2 = var0 &amp;amp;&amp;amp; var1 ? 0 : 1;\n        return var2; // update , return 1\n    }\n\n    static int zzZaP() {\n        boolean var0 = zzYIF == null || zzYIF.zzYIH == 0 || (new Date()).after(zzYIF.zzYII) || zzYNP.zzYlS() == 4096;\n        boolean var1 = zzZE1.zzYZQ() == 0;\n        int var2 = var0 &amp;amp;&amp;amp; var1 ? 0 : 1;\n        return var2;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-利用javassist修改字节码\&#34;&gt;2. 利用Javassist修改字节码&lt;/h2&gt;\n&lt;h3 id=\&#34;maven添加依赖\&#34;&gt;Maven添加依赖&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;&amp;lt;dependency&amp;gt;\n    &amp;lt;groupId&amp;gt;org.javassist&amp;lt;/groupId&amp;gt;\n    &amp;lt;artifactId&amp;gt;javassist&amp;lt;/artifactId&amp;gt;\n    &amp;lt;version&amp;gt;${javaassist.version}&amp;lt;/version&amp;gt;\n&amp;lt;/dependency&amp;gt;\n \n&amp;lt;properties&amp;gt;\n    &amp;lt;javaassist.version&amp;gt;3.21.0-GA&amp;lt;/javaassist.version&amp;gt;\n&amp;lt;/properties&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;编写方法\&#34;&gt;编写方法&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public void removeWatermark() throws NotFoundException, CannotCompileException, IOException {\n        ClassPool.getDefault().insertClassPath(&amp;quot;xxxx&amp;quot;); // jar包的绝对路径\n        CtClass targetClass = ClassPool.getDefault().getCtClass(&amp;quot;com.aspose.words.zzZJ5&amp;quot;); //类路径\n        CtMethod targetMethod = targetClass.getDeclaredMethod(&amp;quot;zzZaQ&amp;quot;); //方法路径\n        targetMethod.setBody(&amp;quot;{return 1;}&amp;quot;); //修改方法体，始终返回1\n        targetClass.writeFile(&amp;quot;/Users/zexho/Documents/&amp;quot;); //保存修改，内容为保存的路径。\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;3-更新jar包\&#34;&gt;3. 更新Jar包&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;将.jar包名后缀改为其他压缩格式。mac的改为tar，win可以改为zip&lt;/li&gt;\n&lt;li&gt;解压tar,将新生成class文件替换旧的&lt;/li&gt;\n&lt;li&gt;删除META-INF文件中的RSA和SF文件&lt;/li&gt;\n&lt;li&gt;确保当前位置在一级目录中，看到这两个文件的位置。&lt;br&gt;\n&lt;img src=\&#34;https://tva1.sinaimg.cn/large/007S8ZIlgy1gi3x36zscbj306403zdfo.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;重新打包Jar &lt;code&gt;jar cvf [新文件的名字.jar] .&lt;/code&gt;例如&lt;code&gt;jar cvf aspose-slides-20.5-jdk16.jar .&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;4-maven重新导入jar包\&#34;&gt;4. Maven重新导入Jar包&lt;/h2&gt;\n&lt;p&gt;在maven中导入该jar包。然后刷新就可以用了。&lt;br&gt;\n&lt;img src=\&#34;https://tva1.sinaimg.cn/large/007S8ZIlgy1gi3x5s3oxsj307n04bjre.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;只能个人使用，不可商用&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;fileName&#34;:&#34;u5bZtrIU8&#34;,&#34;abstract&#34;:&#34;&lt;ol&gt;\n&lt;li&gt;找到License.class&lt;br&gt;\n在words的jar包中找到License类.验证方法入口在这里&lt;br&gt;\n虽然有两个setLicense（）方法，细心点看，最后调用的都是zzV方法，只是不同的重载。&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;反编译+字节码注入破解 Aspose Words 20.6&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;知识分享&#34;,&#34;slug&#34;:&#34;Yh19JUBym&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/Yh19JUBym/&#34;}],&#34;date&#34;:&#34;2020-08-13 11:06:19&#34;,&#34;dateFormat&#34;:&#34;2020-08-13 11:06:19&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/u5bZtrIU8/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:150000,&#34;words&#34;:513,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n找到License.class\n在words的jar包中找到License类.验证方法入口在这里\n虽然有两个setLicense（）方法，细心点看，最后调用的都是zzV方法，只是不同的重载。\n\n\npublic class License ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%88%A9%E7%94%A8javassist%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82%E7%A0%81\&#34;&gt;2. 利用Javassist修改字节码&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#maven%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\&#34;&gt;Maven添加依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95\&#34;&gt;编写方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E6%9B%B4%E6%96%B0jar%E5%8C%85\&#34;&gt;3. 更新Jar包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-maven%E9%87%8D%E6%96%B0%E5%AF%BC%E5%85%A5jar%E5%8C%85\&#34;&gt;4. Maven重新导入Jar包&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;java负数的计算过程\&#34;&gt;Java负数的计算过程&lt;/h2&gt;\n&lt;p&gt;java中最高位表示符号位,0表示正数，1表示负数&lt;/p&gt;\n&lt;h3 id=\&#34;根据十进制推算二进制\&#34;&gt;根据十进制推算二进制&lt;/h3&gt;\n&lt;p&gt;以-5为例子&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;-5的原码：&lt;code&gt;1000 0101&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;求反码 : &lt;code&gt;1111 1010&lt;/code&gt; ，符号位不进行取反&lt;/li&gt;\n&lt;li&gt;求补码（+1）：&lt;code&gt;1111 1011&lt;/code&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;所以-5用二进制表示为&lt;code&gt;1111 1011&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;根据二进制逆推十进制\&#34;&gt;根据二进制逆推十进制&lt;/h3&gt;\n&lt;p&gt;以&lt;code&gt;10001010&lt;/code&gt;为例子&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;获取补码,（-1操作）&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;10001010 - 1 = 10001001&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;获取反码&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;10001001&lt;/code&gt; 的反码 &lt;code&gt;11110110&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;不看符号位，算出大小&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;1110110&lt;/code&gt;  对应的值为 &lt;code&gt;118&lt;/code&gt;，所以10001010的值就是-118&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;可以看出来，对于负数而言，因为&lt;code&gt;1000 0000&lt;/code&gt; 后七位因为要取反，所以后七位越大反而绝对值越小，例如&lt;code&gt;1111 1111&lt;/code&gt; 等于-1，而&lt;code&gt;1111 1110&lt;/code&gt; 等于-2&lt;/p&gt;\n&lt;p&gt;那么对于负数而言 &lt;code&gt;1000 0000&lt;/code&gt; 就是绝对值最大，相对值最小的了，等于-128&lt;/p&gt;\n&lt;h2 id=\&#34;为什么要这样设计\&#34;&gt;为什么要这样设计&lt;/h2&gt;\n&lt;p&gt;首先在计算机中减法实际上是加法，2-1 == 2 + (-1)，那么进行推理一下&lt;/p&gt;\n&lt;h3 id=\&#34;如果都用原码\&#34;&gt;如果都用原码&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;2&lt;/code&gt; 的原码：&lt;code&gt;0000 0010&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;-1&lt;/code&gt; 的原码: &lt;code&gt;1000 0001&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;2 + (-1)&lt;/code&gt;= &lt;code&gt;10000 0011&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;答案是是 -3，答案错误&lt;/p&gt;\n&lt;h3 id=\&#34;如果正数用原码负数用补码\&#34;&gt;如果正数用原码，负数用补码&lt;/h3&gt;\n&lt;p&gt;事例1&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;2&lt;/code&gt;原码:&lt;code&gt;0000 0010&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;-1&lt;/code&gt;补码: &lt;code&gt;1111 1111&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;相加 =&lt;code&gt;0000 0001&lt;/code&gt; ，就等于1&lt;/p&gt;\n&lt;p&gt;事例2&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;10&lt;/code&gt;原码:&lt;code&gt;0000 1010&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;-20&lt;/code&gt;补码: &lt;code&gt;1110 1100&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;10 + (-20)&lt;/code&gt; =  &lt;code&gt;1111 0110&lt;/code&gt; 等于-10&lt;/p&gt;\n&lt;h3 id=\&#34;为什么要用补码表示负数而不是反码\&#34;&gt;为什么要用补码表示负数，而不是反码&lt;/h3&gt;\n&lt;p&gt;或者换个说法，为什么要进行+1操作&lt;/p&gt;\n&lt;p&gt;如果不用补码,而用反码&lt;/p&gt;\n&lt;p&gt;1的原码: &lt;code&gt;0000 0001&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;-1的反码:&lt;code&gt;1111 1110&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;1 + (-1) = &lt;code&gt;1111 1111&lt;/code&gt; = -128&lt;/p&gt;\n&lt;p&gt;很明显答案错误&lt;/p&gt;\n&lt;p&gt;那么为什么要进行+1操作，如果你对&lt;code&gt;1111 11111&lt;/code&gt; +1可以发现 = &lt;code&gt;0001 0000 0000&lt;/code&gt;，而因为byte的大小只有8位，第9位要舍弃也就是&lt;code&gt;0000 0000&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;因为负数最高位存在一个1，也就是说负数天然要比正数多一个1，对于正数而言，你就得额外+1才能保证正数和负数是一样大的。&lt;/p&gt;\n&lt;h2 id=\&#34;关于byte取值范围\&#34;&gt;关于byte取值范围&lt;/h2&gt;\n&lt;p&gt;byte的取值范围为&lt;code&gt;-128 ~ 127&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;为什么负值要大于正值？&lt;/p&gt;\n&lt;p&gt;对于最大值很容易得出：&lt;code&gt;0111 1111&lt;/code&gt; 就等于127&lt;/p&gt;\n&lt;p&gt;但是负数不同，在&lt;code&gt;1000 0000&lt;/code&gt;这个特殊情况下符号位是参与运算的，也就是说，&lt;code&gt;1000 0000&lt;/code&gt; 是最小值，转化成十进制就是-128了&lt;/p&gt;\n&lt;h2 id=\&#34;java代码测试\&#34;&gt;Java代码测试&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public static void main(String[] args) {\n        byte x1 = (byte)0b00000010;\n        byte x2 = (byte)0b11111111;\n\n        System.out.println(&amp;quot;x1 = &amp;quot; + x1);\n        System.out.println(&amp;quot;x2 = &amp;quot; + x2);\n        System.out.println(&amp;quot;x1 + x2 = &amp;quot; +  (x1 + x2));\n\n        byte x3 = (byte)0b11111110;\n        System.out.println(&amp;quot;x3 = &amp;quot; + x3);\n\n        byte negative20 = (byte)0b11101100;\n        System.out.println(&amp;quot;negative20 : &amp;quot; + negative20);\n\n        byte negative10 = (byte)0b11110110;\n        System.out.println(&amp;quot;negative10:&amp;quot;+negative10);\n\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;g8YKXeC-j&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;Java中二进制的补码，反码，正负数&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;}],&#34;date&#34;:&#34;2020-08-08 21:00:26&#34;,&#34;dateFormat&#34;:&#34;2020-08-08 09:00:26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/g8YKXeC-j/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:163000,&#34;words&#34;:659,&#34;minutes&#34;:3},&#34;description&#34;:&#34;Java负数的计算过程\njava中最高位表示符号位,0表示正数，1表示负数\n根据十进制推算二进制\n以-5为例子\n\n-5的原码：1000 0101\n求反码 : 1111 1010 ，符号位不进行取反\n求补码（+1）：1111 1011\n\n所以...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#java%E8%B4%9F%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B\&#34;&gt;Java负数的计算过程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B9%E6%8D%AE%E5%8D%81%E8%BF%9B%E5%88%B6%E6%8E%A8%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6\&#34;&gt;根据十进制推算二进制&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B9%E6%8D%AE%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%86%E6%8E%A8%E5%8D%81%E8%BF%9B%E5%88%B6\&#34;&gt;根据二进制逆推十进制&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1\&#34;&gt;为什么要这样设计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E6%9E%9C%E9%83%BD%E7%94%A8%E5%8E%9F%E7%A0%81\&#34;&gt;如果都用原码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E6%9E%9C%E6%AD%A3%E6%95%B0%E7%94%A8%E5%8E%9F%E7%A0%81%E8%B4%9F%E6%95%B0%E7%94%A8%E8%A1%A5%E7%A0%81\&#34;&gt;如果正数用原码，负数用补码&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E8%B4%9F%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8F%8D%E7%A0%81\&#34;&gt;为什么要用补码表示负数，而不是反码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8Ebyte%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4\&#34;&gt;关于byte取值范围&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#java%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95\&#34;&gt;Java代码测试&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;1-在-docker-hub-下查看-neo4j-镜像\&#34;&gt;1. 在 docker hub 下查看 neo4j 镜像&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;docker search neo4j\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf6017aa71~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200215164627841\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;2-拉取-neo4j-镜像\&#34;&gt;2. 拉取 neo4j 镜像&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;docker pull neo4j\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;拉取完成后输入命令可以看到镜像已经存在&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;docker images\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf6284ad96~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200215164707134\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;3-启动-neo4j-镜像\&#34;&gt;3. 启动 neo4j 镜像&lt;/h2&gt;\n&lt;p&gt;执行命令&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-docker\&#34;&gt;docker run \\\n    --publish=7474:7474 --publish=7687:7687 \\\n    --volume=$HOME/neo4j/data:/data \\\n    --rm -d neo4j\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480f43959d204~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200215164756361\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;​\t&lt;em&gt;参数说明：&lt;/em&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;publish&lt;/strong&gt;: 配置本机与容器之间的映射端口,&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;volume&lt;/strong&gt;:配置共享的宗卷，用于数据持久化&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;4-启动-neo4j-自带的前端页面\&#34;&gt;4. 启动 neo4j 自带的前端页面&lt;/h2&gt;\n&lt;p&gt;在浏览器中输入&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;http://localhost:7474/browser\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到,这里的端口是7474,是我们 run 命令里面设置的.还有一个端口7687用来连接数据库&lt;/p&gt;\n&lt;h2 id=\&#34;5-连接neo4j\&#34;&gt;5. 连接neo4j&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/170480cf628a5e65~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200215165022204\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;账号密码默认都是 neo4j&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;至此就连接上了neo4j&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;docker_1&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;1-在-docker-hub-下查看-neo4j-镜像\&#34;&gt;1. 在 docker hub 下查看 neo4j 镜像&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;docker search neo4j\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;Docker 中搭建 Neo4j 图数据库 &#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;docker&#34;,&#34;slug&#34;:&#34;docker&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/docker/&#34;},{&#34;name&#34;:&#34;图数据库&#34;,&#34;slug&#34;:&#34;tu-shu-ju-ku&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/tu-shu-ju-ku/&#34;}],&#34;date&#34;:&#34;2020-02-15 16:43:43&#34;,&#34;dateFormat&#34;:&#34;2020-02-15 04:43:43&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/docker_1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:44000,&#34;words&#34;:182,&#34;minutes&#34;:1},&#34;description&#34;:&#34;1. 在 docker hub 下查看 neo4j 镜像\ndocker search neo4j\n\n\n\n2. 拉取 neo4j 镜像\ndocker pull neo4j\n\n拉取完成后输入命令可以看到镜像已经存在\ndocker images\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E5%9C%A8-docker-hub-%E4%B8%8B%E6%9F%A5%E7%9C%8B-neo4j-%E9%95%9C%E5%83%8F\&#34;&gt;1. 在 docker hub 下查看 neo4j 镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E6%8B%89%E5%8F%96-neo4j-%E9%95%9C%E5%83%8F\&#34;&gt;2. 拉取 neo4j 镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%90%AF%E5%8A%A8-neo4j-%E9%95%9C%E5%83%8F\&#34;&gt;3. 启动 neo4j 镜像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E5%90%AF%E5%8A%A8-neo4j-%E8%87%AA%E5%B8%A6%E7%9A%84%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2\&#34;&gt;4. 启动 neo4j 自带的前端页面&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E8%BF%9E%E6%8E%A5neo4j\&#34;&gt;5. 连接neo4j&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;在刚开始学习git的时候，我很疑惑git可以同时管理这么多分支，而且切换分支都是瞬间完成。尽管Git官方推荐我们多使用分支去开发，但是天真的我很担心分支太多，导致文件数量会剧增，所以一直不敢使用太多分支。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;直到有一天想要去揭开心中的疑惑，git是怎么样管理这些不同分支的，最后发现和git里面的3个对象有关，搞懂3个对象的关系，相信在以后使用git命令的时候，头脑里会自然而然的浮现这些对象的关系网图&lt;/p&gt;\n&lt;p&gt;在命令行中，可以使用 &lt;code&gt;git cat-file -p &amp;lt;object id&amp;gt;&lt;/code&gt;去查看每个对象里面的内容&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;Commit对象&lt;/p&gt;\n&lt;p&gt;由3部分组成，parent存储父commit对象的ID，每一个commit对象都一个ID，使用&lt;code&gt;git log&lt;/code&gt;可以查看。Tree部分存储一个Tree对象的ID，下面部分存储的就是&lt;code&gt;git commit -m &amp;quot;xxx&amp;quot;&lt;/code&gt;里面的注释内容了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h6 id=\&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b6f68a02e~tplv-t2oaga2asx-imageimage-altimage-20200112200749581-stylezoom50\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b6f68a02e~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112200749581\&#34; style=\&#34;zoom:50%;\&#34; /&gt;&lt;/h6&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;mark&gt;Tree 对象&lt;/mark&gt;&lt;/p&gt;\n&lt;p&gt;可以把Tree对象理解为一个文件夹，每一个commit对象对应一个Tree，可以把这个Tree当作根目录。这个Tree里面存储了根目录下的子Tree的ID，以及BlobId。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;mark&gt;Blob 对象&lt;/mark&gt;&lt;/p&gt;\n&lt;p&gt;一个Tree对应一个文件夹，Blob对应的是文件，Blog里面存储的也真的是文件的内容。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;举个\&#34;&gt;举个🌰&lt;/h4&gt;\n&lt;h6 id=\&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7661d997~tplv-t2oaga2asx-imageimage-altimage-20200112202046245-stylezoom50\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7661d997~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112202046245\&#34; style=\&#34;zoom:50%;\&#34; /&gt;&lt;/h6&gt;\n&lt;p&gt;git的根目录是Java，Java文件夹里有一个test.class文件和一个JDK文件夹，JDK文件夹下面还有一个java8.class文件，那么我们第一次&lt;code&gt;git commit&lt;/code&gt;后的关系图就是这样&lt;/p&gt;\n&lt;h6 id=\&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b78581bba~tplv-t2oaga2asx-imageimage-altimage-20200112202700139-stylezoom-25\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b78581bba~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112202700139\&#34; style=\&#34;zoom: 25%;\&#34; /&gt;&lt;/h6&gt;\n&lt;p&gt;此时我们修改了test.class文件的内容后，重新&lt;code&gt;git add test.class&lt;/code&gt;再&lt;code&gt;git commit -m&#39;update&#39;&lt;/code&gt;，这时候就会产生一个新的commit对象，结构就像这样:&lt;/p&gt;\n&lt;h6 id=\&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7b5e4a69~tplv-t2oaga2asx-imageimage-altimage-20200112203735217-stylezoom25\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7b5e4a69~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112203735217\&#34; style=\&#34;zoom:25%;\&#34; /&gt;&lt;/h6&gt;\n&lt;p&gt;发现只是保存了一个新的test.class的快照，java8.class没有发生改变，就没有生成生成新的快照。这样看来，真的是很节省磁盘了。&lt;/p&gt;\n&lt;p&gt;git还有许许多多的使用场景，如果你能理解以上的关系，那么其他的情况下，都是一样的，不妨自己去命令行 &lt;code&gt;git cat-file -p &amp;lt;object id&amp;gt;&lt;/code&gt; 验证验证吧～&lt;/p&gt;\n&lt;h3 id=\&#34;img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b80651833~tplv-t2oaga2asx-imageimage-alt目录-stylezoom65-推荐阅读\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b80651833~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;目录\&#34; style=\&#34;zoom:65%;\&#34; /&gt;推荐阅读&lt;/h3&gt;\n&lt;p&gt;&lt;a href=\&#34;https://ruby-china.org/topics/20723\&#34;&gt;理解git对象&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;git_1&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;在刚开始学习git的时候，我很疑惑git可以同时管理这么多分支，而且切换分支都是瞬间完成。尽管Git官方推荐我们多使用分支去开发，但是天真的我很担心分支太多，导致文件数量会剧增，所以一直不敢使用太多分支。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Git 中指针与树的实现&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Git&#34;,&#34;slug&#34;:&#34;THZXOECNJ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/THZXOECNJ/&#34;}],&#34;date&#34;:&#34;2019-07-05 20:38:30&#34;,&#34;dateFormat&#34;:&#34;2019-07-05 08:38:30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/git_1/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:127000,&#34;words&#34;:575,&#34;minutes&#34;:3},&#34;description&#34;:&#34;在刚开始学习git的时候，我很疑惑git可以同时管理这么多分支，而且切换分支都是瞬间完成。尽管Git官方推荐我们多使用分支去开发，但是天真的我很担心分支太多，导致文件数量会剧增，所以一直不敢使用太多分支。\n\n直到有一天想要去揭开心中的疑惑，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b6f68a02e~tplv-t2oaga2asx-imageimage-altimage-20200112200749581-stylezoom50\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b6f68a02e~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112200749581\&#34; style=\&#34;zoom:50%;\&#34; /&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BE%E4%B8%AA\&#34;&gt;举个🌰&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7661d997~tplv-t2oaga2asx-imageimage-altimage-20200112202046245-stylezoom50\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7661d997~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112202046245\&#34; style=\&#34;zoom:50%;\&#34; /&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b78581bba~tplv-t2oaga2asx-imageimage-altimage-20200112202700139-stylezoom-25\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b78581bba~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112202700139\&#34; style=\&#34;zoom: 25%;\&#34; /&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b7b5e4a69~tplv-t2oaga2asx-imageimage-altimage-20200112203735217-stylezoom25\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b7b5e4a69~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;image-20200112203735217\&#34; style=\&#34;zoom:25%;\&#34; /&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#img-srchttpsp1-jjbyteimgcomtos-cn-i-t2oaga2asxgold-user-assets202011216f9a15b80651833~tplv-t2oaga2asx-imageimage-alt%E7%9B%AE%E5%BD%95-stylezoom65-%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/12/16f9a15b80651833~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;目录\&#34; style=\&#34;zoom:65%;\&#34; /&gt;推荐阅读&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;今天看到一篇文章，觉得不错。&lt;br&gt;\n原文链接：https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434&lt;br&gt;\n译文：https://www.jianshu.com/p/ab9aa8d4df7d&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;\&#34;&gt;&lt;/h1&gt;\n&lt;p&gt;最近我遇到了一个bug，我试着通过Rails在以“utf8”编码的MariaDB中保存一个UTF-8字符串，然后出现了一个离奇的错误：&lt;/p&gt;\n&lt;p&gt;Incorrect string value:‘ð&amp;lt;…’for column ‘summary’ at row 1&lt;br&gt;\n我用的是UTF-8编码的客户端，服务器也是UTF-8编码的，数据库也是，就连要保存的这个字符串“???? &amp;lt;…”也是合法的UTF-8。&lt;/p&gt;\n&lt;p&gt;问题的症结在于，MySQL的“utf8”实际上不是真正的UTF-8。&lt;/p&gt;\n&lt;p&gt;“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。&lt;/p&gt;\n&lt;p&gt;MySQL一直没有修复这个bug，他们在2010年发布了一个叫作“utf8mb4”的字符集，绕过了这个问题。&lt;/p&gt;\n&lt;p&gt;当然，他们并没有对新的字符集广而告之（可能是因为这个bug让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的。&lt;/p&gt;\n&lt;p&gt;简单概括如下：&lt;/p&gt;\n&lt;p&gt;1.MySQL的“utf8mb4”是真正的“UTF-8”。&lt;/p&gt;\n&lt;p&gt;2.MySQL的“utf8”是一种“专属的编码”，它能够编码的Unicode字符并不多。&lt;/p&gt;\n&lt;p&gt;我要在这里澄清一下：所有在使用“utf8”的MySQL和MariaDB用户都应该改用“utf8mb4”，永远都不要再使用“utf8”。&lt;/p&gt;\n&lt;p&gt;那么什么是编码？什么是UTF-8？&lt;/p&gt;\n&lt;p&gt;我们都知道，计算机使用0和1来存储文本。比如字符“C”被存成“01000011”，那么计算机在显示这个字符时需要经过两个步骤：&lt;/p&gt;\n&lt;p&gt;1、计算机读取“01000011”，得到数字67，因为67被编码成“01000011”。&lt;/p&gt;\n&lt;p&gt;2、计算机在Unicode字符集中查找67，找到了“C”。&lt;/p&gt;\n&lt;p&gt;同样的：&lt;/p&gt;\n&lt;p&gt;1、我的电脑将“C”映射成Unicode字符集中的67。&lt;/p&gt;\n&lt;p&gt;2、我的电脑将67编码成“01000011”，并发送给Web服务器。&lt;/p&gt;\n&lt;p&gt;几乎所有的网络应用都使用了Unicode字符集，因为没有理由使用其他字符集。&lt;/p&gt;\n&lt;p&gt;Unicode字符集包含了上百万个字符。最简单的编码是UTF-32，每个字符使用32位。这样做最简单，因为一直以来，计算机将32位视为数字，而计算机最在行的就是处理数字。但问题是，这样太浪费空间了。&lt;/p&gt;\n&lt;p&gt;UTF-8可以节省空间，在UTF-8中，字符“C”只需要8位，一些不常用的字符，比如“”需要32位。其他的字符可能使用16位或24位。一篇类似本文这样的文章，如果使用UTF-8编码，占用的空间只有UTF-32的四分之一左右。&lt;/p&gt;\n&lt;p&gt;MySQL的“utf8”字符集与其他程序不兼容，它所谓的“”，可能真的是一坨……&lt;br&gt;\nMySQL简史&lt;/p&gt;\n&lt;p&gt;为什么MySQL开发者会让“utf8”失效？我们或许可以从提交日志中寻找答案。&lt;br&gt;\nMySQL从4.1版本开始支持UTF-8，也就是2003年，而今天使用的UTF-8标准（RFC3629）是随后才出现的。&lt;/p&gt;\n&lt;p&gt;旧版的UTF-8标准（RFC2279）最多支持每个字符6个字节。2002年3月28日，MySQL开发者在第一个MySQL4.1预览版中使用了RFC2279。&lt;/p&gt;\n&lt;p&gt;同年9月，他们对MySQL源代码进行了一次调整：“UTF8现在最多只支持3个字节的序列”。&lt;br&gt;\n是谁提交了这些代码？他为什么要这样做？这个问题不得而知。在迁移到Git后（MySQL最开始使用的是BitKeeper），MySQL代码库中的很多提交者的名字都丢失了。2003年9月的邮件列表中也找不到可以解释这一变更的线索。&lt;/p&gt;\n&lt;p&gt;不过我可以试着猜测一下。&lt;/p&gt;\n&lt;p&gt;2002年，MySQL做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么MySQL就可以在性能方面来一个大提升。为此，用户需要将文本列定义为“CHAR”，每个“CHAR”列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。&lt;/p&gt;\n&lt;p&gt;MySQL开发者在最开始尝试UTF-8时使用了每个字符6个字节，CHAR(1)使用6个字节，CHAR(2)使用12个字节，并以此类推。&lt;/p&gt;\n&lt;p&gt;应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解UTF-8的人都认同文档里写的东西。&lt;/p&gt;\n&lt;p&gt;不过很显然，MySQL开发者或厂商担心会有用户做这两件事：&lt;/p&gt;\n&lt;p&gt;1、使用CHAR定义列（在现在看来，CHAR已经是老古董了，但在那时，在MySQL中使用CHAR会更快，不过从2005年以后就不是这样子了）。&lt;/p&gt;\n&lt;p&gt;2、将CHAR列的编码设置为“utf8”。&lt;/p&gt;\n&lt;p&gt;我的猜测是MySQL开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了“utf8”编码。&lt;/p&gt;\n&lt;p&gt;所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用“utf8”的CHAR列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用“utf8”编码时，却无法保存像“”这样的字符。&lt;/p&gt;\n&lt;p&gt;在这个不合法的字符集发布了之后，MySQL就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL在2010年重新发布了“utf8mb4”来支持真正的UTF-8。&lt;/p&gt;\n&lt;p&gt;为什么这件事情会让人如此抓狂？&lt;/p&gt;\n&lt;p&gt;因为这个问题，我整整抓狂了一个礼拜。我被“utf8”愚弄了，花了很多时间才找到这个bug。但我一定不是唯一的一个，网络上几乎所有的文章都把“utf8”当成是真正的UTF-8。&lt;br&gt;\n“utf8”只能算是个专有的字符集，它给我们带来了新问题，却一直没有得到解决。&lt;/p&gt;\n&lt;p&gt;总结&lt;/p&gt;\n&lt;p&gt;如果你在使用MySQL或MariaDB，不要用“utf8”编码，改用“utf8mb4”。这里（https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4）提供了一个指南用于将现有数据库的字符编码从“utf8”转成“utf8mb4”。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;编号3722，输入编号直达本文&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;输入m获取文章目录&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;个人总结\&#34;&gt;个人总结&lt;/h2&gt;\n&lt;p&gt;对于作者说的不要再使用utf-8，本人不完全认同，完全可以在需要的时候才使用utf8mb4（毕竟utf-8更省空间）像微信小程序，编码的坑大家应该都踩过，可是除了这个外，似乎也没遇到过什么问题。所以了解这么一个问题后，以后完全可以按需要来确定使用何种编码。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;Uh0rKjiE0&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;今天看到一篇文章，觉得不错。&lt;br&gt;\n原文链接：https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434&lt;br&gt;\n译文：https://www.jianshu.com/p/ab9aa8d4df7d&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;Mysql UTF-8 编码注意事项&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;知识分享&#34;,&#34;slug&#34;:&#34;Yh19JUBym&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/Yh19JUBym/&#34;}],&#34;date&#34;:&#34;2019-06-14 15:50:24&#34;,&#34;dateFormat&#34;:&#34;2019-06-14 03:50:24&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/Uh0rKjiE0/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:379000,&#34;words&#34;:1731,&#34;minutes&#34;:7},&#34;description&#34;:&#34;\n今天看到一篇文章，觉得不错。\n原文链接：https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434\n译文：https://www.jian...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93\&#34;&gt;个人总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;有一次我的项目中采用了前后端分离的模式，引起了跨域问题，本文将介绍我所采用的跨域解决方法。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;首先要了解产生跨域的本质，也就是同源策略的限制，源是指域名、端口号、协议，有一者不相同将被浏览器拒绝接受响应信息，（请求可以发送出去，但是浏览器不接受响应）。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;解决方法\&#34;&gt;解决方法：&lt;/h2&gt;\n&lt;h3 id=\&#34;1-jsonp\&#34;&gt;1. jsonp&lt;/h3&gt;\n&lt;p&gt;jsonp的原理的 src=&amp;quot;&amp;quot; 属性不受同源策略的限制，动态创建一个callback回调函数，服务器调用回调函数把数据放进去，具体的细节打算以后做一个专门讲解。&lt;/p&gt;\n&lt;p&gt;这里给一个模版:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;            $.ajax({\n             type: &amp;quot;get&amp;quot;,               //jsonp只能使用get\n             async: false,\n             url: &amp;quot;&amp;quot;\n             dataType: &amp;quot;jsonp&amp;quot;,\n             jsonp: &amp;quot;callback&amp;quot;,        \n             jsonpCallback:&amp;quot;message&amp;quot;,       //注意这里给回调函数起的名字\n                 success: function(json){\n                 \n                }\n            })\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果这里你的回调函数起名为message，那么你在后端返回json的时候，也要注意在最外面包一层message{}。&lt;/p&gt;\n&lt;p&gt;这里jsonp的缺点也可以明显的看出，只支持get请求，原因就是因为通过src=“”发送请求，所以可以知道是url传参。&lt;/p&gt;\n&lt;p&gt;那么jsonp的好处是什么呢，兼容性，几乎所有浏览器都支持（包括一些版本比较老的），不需要XMLHttpRequest或ActiveX的支持。&lt;/p&gt;\n&lt;h3 id=\&#34;2-cors\&#34;&gt;2. cors&lt;/h3&gt;\n&lt;p&gt;又称跨域访问，浏览器将cors请求分为简单请求和非简单请求，因为本文主要讲解具体的方法，所以关于细节部分有兴趣可以去看其他博客或者我以后再做一篇具体的讲解（和jsonp一起）。在springboot中，官方已经提供了支持。直接贴代码：&lt;/p&gt;\n&lt;h3 id=\&#34;方式一全局定义\&#34;&gt;方式一：全局定义&lt;/h3&gt;\n&lt;p&gt;注意@Order这个注解，不加的话很大可能导致配置失效&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    @Component\n    @Order(Ordered.HIGHEST_PRECEDENCE)\n    public class CorsFilter implements Filter {\n        @Override\n        public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n            HttpServletResponse response = (HttpServletResponse) res;\n            HttpServletRequest request = (HttpServletRequest) req;\n            response.setHeader(&amp;quot;Access-Control-Allow-Origin&amp;quot;, &amp;quot;*&amp;quot;);\n            response.setHeader(&amp;quot;Access-Control-Allow-Credentials&amp;quot;, &amp;quot;true&amp;quot;);\n            response.setHeader(&amp;quot;Access-Control-Allow-Methods&amp;quot;,\n                    &amp;quot;ACL, CANCELUPLOAD, CHECKIN, CHECKOUT, COPY, DELETE, GET, HEAD, LOCK, MKCALENDAR, MKCOL, MOVE, OPTIONS, POST, PROPFIND, PROPPATCH, PUT, REPORT, SEARCH, UNCHECKOUT, UNLOCK, UPDATE, VERSION-CONTROL&amp;quot;);\n            response.setHeader(&amp;quot;Access-Control-Max-Age&amp;quot;, &amp;quot;3600&amp;quot;);\n            response.setHeader(&amp;quot;Access-Control-Allow-Headers&amp;quot;,\n                    &amp;quot;Origin, X-Requested-With, Content-Type, Accept, x-userId&amp;quot;);\n\n            if (&amp;quot;OPTIONS&amp;quot;.equalsIgnoreCase(request.getMethod())) {\n                response.setStatus(HttpServletResponse.SC_OK);\n            } else {\n                chain.doFilter(req, res);\n            }\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;方式二局部定义\&#34;&gt;方式二：局部定义&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;        @CrossOrigin(origins = &amp;quot;*&amp;quot;,allowCredentials=&amp;quot;true&amp;quot;,allowedHeaders = &amp;quot;&amp;quot;,methods = {})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;直接在需要跨域的方法上添加注解,十分方便。也可以在类上使用该注解.&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结：&lt;/h2&gt;\n&lt;p&gt;个人推荐使用cors，如果因为兼容性问题不得不使用jsonp那也没办法。然后如果是前后端分离的模式下，对于用户权限验证这一块也是一个需要注意点，如果使用cookie-session，跨域会导致后台获取不到session，我们可以利用token的方法来解决这个问题，我打算以后介绍一下jwt（Json web Token）来实现用户认证。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wNJouB2lg&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;有一次我的项目中采用了前后端分离的模式，引起了跨域问题，本文将介绍我所采用的跨域解决方法。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;首先要了解产生跨域的本质，也就是同源策略的限制，源是指域名、端口号、协议，有一者不相同将被浏览器拒绝接受响应信息，（请求可以发送出去，但是浏览器不接受响应）。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;SpringBoot 跨域 Jsonp 和 Cors&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Spring&#34;,&#34;slug&#34;:&#34;P-ZT7Pj1-8&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/P-ZT7Pj1-8/&#34;}],&#34;date&#34;:&#34;2019-06-07 11:53:26&#34;,&#34;dateFormat&#34;:&#34;2019-06-07 11:53:26&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/wNJouB2lg/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:189000,&#34;words&#34;:770,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n有一次我的项目中采用了前后端分离的模式，引起了跨域问题，本文将介绍我所采用的跨域解决方法。\n\n首先要了解产生跨域的本质，也就是同源策略的限制，源是指域名、端口号、协议，有一者不相同将被浏览器拒绝接受响应信息，（请求可以发送出去，但是浏览器...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\&#34;&gt;解决方法：&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-jsonp\&#34;&gt;1. jsonp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-cors\&#34;&gt;2. cors&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%B8%80%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89\&#34;&gt;方式一：全局定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%B1%80%E9%83%A8%E5%AE%9A%E4%B9%89\&#34;&gt;方式二：局部定义&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;前一阵子要给实验室的学弟们技术分享，当时收到建议给他们普及一些计算机网络的知识，可是关&lt;br&gt;\n有理论知识讲课肯定不够吸引人，于是便一边学习Wireshark一边做PPT一边写讲稿。忙碌了两个星期后，分享会后还是得到了不错的的评价😁，我也在博客中总结下一些使用技巧，内容主要面向新手&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;1-wireshark的用途\&#34;&gt;1. WireShark的用途&lt;/h2&gt;\n&lt;h3 id=\&#34;用途一-学习网络知识提供实际操作\&#34;&gt;用途一： 学习网络知识，提供实际操作&lt;/h3&gt;\n&lt;p&gt;在我大二学习计算机网络的时候，老师上课只负责书本的讲解，导致我产生了计算机网络很无聊的错觉，所以那时候也没太认真的学习这门课程。但是后来当我自己边抓包边温习计网知识的时候，才发现是如此的有趣。而在抓包工具中，我使用过小花瓶（charles）和小鲨鱼（wireshark），我推荐小鲨鱼。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;还有一款比较流行，叫fiddler，因为本人使用mac，fiddler未推出mac版，所以未接触过它&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;用途二-获取网络资源信息\&#34;&gt;用途二： 获取网络资源信息&lt;/h3&gt;\n&lt;p&gt;通俗点讲就是抓包，wireshark可以抓的请求类型非常多，新手常见的像http、https（需要下载补丁）、tcp、udp、arp等等都可以。&lt;/p&gt;\n&lt;h3 id=\&#34;用途三进行网络状况分析\&#34;&gt;用途三：进行网络状况分析&lt;/h3&gt;\n&lt;p&gt;比如网络故障排查，因为本人也没利用wireshark分析过，所以就不误导大家了，不过我推荐一本书，也是我学习wireshark的一本书。&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b034e550e178ea~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n作者的风格真的很风趣，读起来就像小说一样，指不定哪个地方就会偷偷冒出一段笑话。&lt;/p&gt;\n&lt;h2 id=\&#34;2-抓包前的准备工作\&#34;&gt;2. 抓包前的准备工作&lt;/h2&gt;\n&lt;h3 id=\&#34;1-修改着色规则\&#34;&gt;1. 修改着色规则&lt;/h3&gt;\n&lt;p&gt;我们第一次使用的适合，显示的界面可能像这样&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/14/16f04764d3d10a9f~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n一片白的，对于我们快速分辨不同请求类型是有妨碍的，所以简单操作下：&lt;/p&gt;\n&lt;h4 id=\&#34;1-打开视图选项找到着色规则就像\&#34;&gt;1）： 打开视图选项，找到着色规则，就像&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b03844f45a802a~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;2-修改背景配色\&#34;&gt;2）： 修改背景配色&lt;/h4&gt;\n&lt;p&gt;我们根据自己的颜色偏好，设置不同的配色（想要搭配出一套养眼的配色真的是一件费力的事），我这里主要修改&lt;strong&gt;SYN报文&lt;/strong&gt;（&lt;strong&gt;绿色&lt;/strong&gt;）和&lt;strong&gt;FIN报文&lt;/strong&gt;（&lt;strong&gt;灰色&lt;/strong&gt;），配完后，就可以发现界面人性化许多，这下一眼就可以知道tcp握手和挥手的请求啦～&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b03873fb04efdf~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;2-只抓包头\&#34;&gt;2. 只抓包头&lt;/h3&gt;\n&lt;p&gt;众所周知，一个数据帧是由多个部分组成，对于我们所要获取的数据，我们也只要前面部分即可。单击菜单栏上的Capture--&amp;gt;Options，然后在弹出的窗口上定义“Limit each packet to”的值即可。一般可以设置一个偏大一点的数字：80字节，这样就可以只抓前80字节了。这样的话，TCP层、网络层和数据链路层的信息都可以包括在内了。我推荐设置200字节，这样可以获取到http、tcp、网络层协议的数据了。&lt;/p&gt;\n&lt;!--![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b038b192f25302~tplv-t2oaga2asx-image.image)--&gt;\n&lt;h3 id=\&#34;3-认识下分层\&#34;&gt;3. 认识下分层&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/14/16f047976a357b7f~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;注意：在这里网络层对应Ipv4，传输层对应tcp，应用层对应http。如果是udp，长这样⬇&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b0397dc455cff5~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;4-数据过滤技巧\&#34;&gt;4. 数据过滤技巧&lt;/h3&gt;\n&lt;p&gt;这也是比较重要的一个小技巧，会使用过滤器的话对于快速定位还是有很大帮助的，我这里列出一些比较常用的技巧，一通则百通。&lt;/p&gt;\n&lt;h4 id=\&#34;1协议过滤\&#34;&gt;1）协议过滤&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b2a5642e35~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b40ea70225~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b515b268f2~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;2-端口过滤\&#34;&gt;2） 端口过滤&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039b9b618a472~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039bab4fddc54~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039bbc3d5152a~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;3ip过滤\&#34;&gt;3）Ip过滤&lt;/h4&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c72b129565~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c8a6e3c3ec~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039c9eb316c96~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039d555376068~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;4标识符过滤\&#34;&gt;4）标识符过滤&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039db9dd136f4~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;5长度过滤\&#34;&gt;5）长度过滤&lt;/h4&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/29/16b039df7abb24f7~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;先分享到这里，这几天在忙着写微信小程序，过几天通过wireshark分析下tcp3次握手和4次挥手来实战操作下～ 如果哪里有错误，还恳请大家指出。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;gei-xue-di-men-fen-xi-wireshark&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;前一阵子要给实验室的学弟们技术分享，当时收到建议给他们普及一些计算机网络的知识，可是关&lt;br&gt;\n有理论知识讲课肯定不够吸引人，于是便一边学习Wireshark一边做PPT一边写讲稿。忙碌了两个星期后，分享会后还是得到了不错的的评价😁，我也在博客中总结下一些使用技巧，内容主要面向新手&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;给学弟们分析 WireShark&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;知识分享&#34;,&#34;slug&#34;:&#34;Yh19JUBym&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/Yh19JUBym/&#34;}],&#34;date&#34;:&#34;2019-05-11 17:59:02&#34;,&#34;dateFormat&#34;:&#34;2019-05-11 05:59:02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/gei-xue-di-men-fen-xi-wireshark/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:196000,&#34;words&#34;:939,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n前一阵子要给实验室的学弟们技术分享，当时收到建议给他们普及一些计算机网络的知识，可是关\n有理论知识讲课肯定不够吸引人，于是便一边学习Wireshark一边做PPT一边写讲稿。忙碌了两个星期后，分享会后还是得到了不错的的评价😁，我也在博客...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-wireshark%E7%9A%84%E7%94%A8%E9%80%94\&#34;&gt;1. WireShark的用途&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E9%80%94%E4%B8%80-%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%8F%90%E4%BE%9B%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C\&#34;&gt;用途一： 学习网络知识，提供实际操作&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E9%80%94%E4%BA%8C-%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%E4%BF%A1%E6%81%AF\&#34;&gt;用途二： 获取网络资源信息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E9%80%94%E4%B8%89%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E7%8A%B6%E5%86%B5%E5%88%86%E6%9E%90\&#34;&gt;用途三：进行网络状况分析&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E6%8A%93%E5%8C%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\&#34;&gt;2. 抓包前的准备工作&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E4%BF%AE%E6%94%B9%E7%9D%80%E8%89%B2%E8%A7%84%E5%88%99\&#34;&gt;1. 修改着色规则&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E6%89%93%E5%BC%80%E8%A7%86%E5%9B%BE%E9%80%89%E9%A1%B9%E6%89%BE%E5%88%B0%E7%9D%80%E8%89%B2%E8%A7%84%E5%88%99%E5%B0%B1%E5%83%8F\&#34;&gt;1）： 打开视图选项，找到着色规则，就像&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E4%BF%AE%E6%94%B9%E8%83%8C%E6%99%AF%E9%85%8D%E8%89%B2\&#34;&gt;2）： 修改背景配色&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E5%8F%AA%E6%8A%93%E5%8C%85%E5%A4%B4\&#34;&gt;2. 只抓包头&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E8%AE%A4%E8%AF%86%E4%B8%8B%E5%88%86%E5%B1%82\&#34;&gt;3. 认识下分层&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4%E6%8A%80%E5%B7%A7\&#34;&gt;4. 数据过滤技巧&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E5%8D%8F%E8%AE%AE%E8%BF%87%E6%BB%A4\&#34;&gt;1）协议过滤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E7%AB%AF%E5%8F%A3%E8%BF%87%E6%BB%A4\&#34;&gt;2） 端口过滤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3ip%E8%BF%87%E6%BB%A4\&#34;&gt;3）Ip过滤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4%E6%A0%87%E8%AF%86%E7%AC%A6%E8%BF%87%E6%BB%A4\&#34;&gt;4）标识符过滤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E9%95%BF%E5%BA%A6%E8%BF%87%E6%BB%A4\&#34;&gt;5）长度过滤&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;我们在写小程序的时候，手机端预览发现获取不到后台数据，只能用真机调试才可以，可是mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了。ps：我室友预览的时候一样可也以有数据。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;关键点\&#34;&gt;关键点：&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;手机，服务器，保持同一局域网。&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;第一步开启局域网\&#34;&gt;第一步：开启局域网&lt;/h2&gt;\n&lt;h3 id=\&#34;方法1使用电脑开启共享wifi手机连接此wifi-不过这里因为我们学校内部网需要账号登陆所以我没采用这种方法不过这种方法的后续流程和第二种方法差不多\&#34;&gt;方法1）&lt;strong&gt;使用电脑开启共享wifi，手机连接此wifi&lt;/strong&gt;。不过这里因为我们学校内部网需要账号登陆，所以我没采用这种方法，不过这种方法的后续流程和第二种方法差不多。&lt;/h3&gt;\n&lt;h3 id=\&#34;方法2手机开启热点电脑连接此热点\&#34;&gt;方法2）&lt;strong&gt;手机开启热点，电脑连接此热点&lt;/strong&gt;。&lt;/h3&gt;\n&lt;h4 id=\&#34;1连接后首先找到分配给电脑的ip-mac获取ip在设置-网络里面就可以看到\&#34;&gt;1）连接后，首先找到分配给电脑的IP。mac获取IP在设置-&amp;gt;网络，里面就可以看到。&lt;/h4&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b071a3d75c0c24~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n或者在终端输入&lt;strong&gt;ifconfig&lt;/strong&gt;，可以找到&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b071e4ad724f4e~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;第二步修改服务器地址\&#34;&gt;第二步：修改服务器地址&lt;/h2&gt;\n&lt;p&gt;我后台使用的SpringBoot，在properties里面直接修改&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b0720284e518d4~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;第三步修改url地址\&#34;&gt;第三步：修改url地址：&lt;/h2&gt;\n&lt;p&gt;之前使用的url地址类似于：&lt;strong&gt;http://localhost:8080/user/login/&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;修改后服务器地址后同一修改为：&lt;strong&gt;http://172.20.10.2:8080/user/login/&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;重启后台，然后在postman测试一下：&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b07252a4316a41~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\nok，可以获取到数据。&lt;br&gt;\n然后我们把小程序里的request里的url全部使用这种方法。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b072a3158b4750~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n重新编译后，测试一下可不可以获取到数据，如果之前步骤没错，肯定没问题的。&lt;br&gt;\n我们直接使用预览，也是一样可以获取到数据的。&lt;/p&gt;\n&lt;h2 id=\&#34;注意点\&#34;&gt;注意点：&lt;/h2&gt;\n&lt;p&gt;1） 在后台修改了地址后，以后必须在热点环境下运行项目，不然会报错。（我就是有一次忘记连热点，结果一直启动失败，我还以为是8080端口占用问题）&lt;/p&gt;\n&lt;p&gt;2）如果要别人预览你的小程序，得先连接你的热点，才能获取到数据。&lt;/p&gt;\n&lt;h2 id=\&#34;总结\&#34;&gt;总结：&lt;/h2&gt;\n&lt;p&gt;对了，如果你还有了网页，那么一样可以使用这种方法在手机上访问你的界面的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;小程序截图：&lt;/strong&gt;&lt;br&gt;\n&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b0739305696dd0~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;网页手机截图：&lt;/strong&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/30/16b073aa9f2958a9~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;hwe1uEAHe&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;我们在写小程序的时候，手机端预览发现获取不到后台数据，只能用真机调试才可以，可是mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了。ps：我室友预览的时候一样可也以有数据。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;微信小程序：预览页实现与后台通信&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;微信小程序&#34;,&#34;slug&#34;:&#34;59D97ArOs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/59D97ArOs/&#34;}],&#34;date&#34;:&#34;2019-04-19 12:47:17&#34;,&#34;dateFormat&#34;:&#34;2019-04-19 12:47:17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/hwe1uEAHe/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:120000,&#34;words&#34;:572,&#34;minutes&#34;:3},&#34;description&#34;:&#34;我们在写小程序的时候，手机端预览发现获取不到后台数据，只能用真机调试才可以，可是mac端的开发者工具对于真机调试的体验苦不堪言，各种bug（官方bug）。所以我想有没有什么办法直接使用预览也可以一样获取到数据呢。花了一天的时间，终于是成功了...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E9%94%AE%E7%82%B9\&#34;&gt;关键点：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%BC%80%E5%90%AF%E5%B1%80%E5%9F%9F%E7%BD%91\&#34;&gt;第一步：开启局域网&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%951%E4%BD%BF%E7%94%A8%E7%94%B5%E8%84%91%E5%BC%80%E5%90%AF%E5%85%B1%E4%BA%ABwifi%E6%89%8B%E6%9C%BA%E8%BF%9E%E6%8E%A5%E6%AD%A4wifi-%E4%B8%8D%E8%BF%87%E8%BF%99%E9%87%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%AD%A6%E6%A0%A1%E5%86%85%E9%83%A8%E7%BD%91%E9%9C%80%E8%A6%81%E8%B4%A6%E5%8F%B7%E7%99%BB%E9%99%86%E6%89%80%E4%BB%A5%E6%88%91%E6%B2%A1%E9%87%87%E7%94%A8%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%8D%E8%BF%87%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8E%E7%BB%AD%E6%B5%81%E7%A8%8B%E5%92%8C%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%E5%B7%AE%E4%B8%8D%E5%A4%9A\&#34;&gt;方法1）&lt;strong&gt;使用电脑开启共享wifi，手机连接此wifi&lt;/strong&gt;。不过这里因为我们学校内部网需要账号登陆，所以我没采用这种方法，不过这种方法的后续流程和第二种方法差不多。&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B9%E6%B3%952%E6%89%8B%E6%9C%BA%E5%BC%80%E5%90%AF%E7%83%AD%E7%82%B9%E7%94%B5%E8%84%91%E8%BF%9E%E6%8E%A5%E6%AD%A4%E7%83%AD%E7%82%B9\&#34;&gt;方法2）&lt;strong&gt;手机开启热点，电脑连接此热点&lt;/strong&gt;。&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E8%BF%9E%E6%8E%A5%E5%90%8E%E9%A6%96%E5%85%88%E6%89%BE%E5%88%B0%E5%88%86%E9%85%8D%E7%BB%99%E7%94%B5%E8%84%91%E7%9A%84ip-mac%E8%8E%B7%E5%8F%96ip%E5%9C%A8%E8%AE%BE%E7%BD%AE-%E7%BD%91%E7%BB%9C%E9%87%8C%E9%9D%A2%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0\&#34;&gt;1）连接后，首先找到分配给电脑的IP。mac获取IP在设置-&amp;gt;网络，里面就可以看到。&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80\&#34;&gt;第二步：修改服务器地址&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%BF%AE%E6%94%B9url%E5%9C%B0%E5%9D%80\&#34;&gt;第三步：修改url地址：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E6%84%8F%E7%82%B9\&#34;&gt;注意点：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;最近在学习微信小程序，遇到了一些坑，有些问题我看官网或者其他博客，可能讲的不是那么易懂，所以自己找到解决方法后，写下来供大家参考，如有不对指出，还恳请大家指出～&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;比如在实现购物车批量购买的时候，我们需要向后台请求一个list，包含所有勾选的物品信息，在微信小程序里，page里的data是这样定义&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;        data {  \n            orders：[]  \n        }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在我们给它赋值后，数据类似于&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc450f3dd4a23~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果我们利用wx.request把这个list发送的时候，根据微信官方文档的解释：&lt;/p&gt;\n&lt;!--![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc476b45019b8~tplv-t2oaga2asx-image.image)--&gt;\n&lt;p&gt;&lt;strong&gt;data 参数说明&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String 。转换规则如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;对于 GET 方法的数据，会将数据转换成 query string（encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/li&gt;\n&lt;li&gt;对于 POST 方法且 header[&#39;content-type&#39;] 为 application/json 的数据，会对数据进行 JSON 序列化&lt;/li&gt;\n&lt;li&gt;对于 POST 方法且 header[&#39;content-type&#39;] 为 application/x-www-form-urlencoded 的数据，会将数据转换成 query string （encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;a href=\&#34;https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html\&#34;&gt;微信对于该部位解释官网文档地址&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;意思就是所有的data数据都会以String类型发送。所以很多朋友可能刚开始和我一样，请求总是错误，或者后台接收了请求，可是值却是null。许多博客给的方法比如&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;        header: {\n        &#39;content-type&#39;: &#39;application/json&#39;\n      },\n      改为\n      header: {\n          &#39;content-type&#39;: &#39;application/x-www-form-urlencoded&#39;\n        },\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我尝试之后发现请求还是报错，下面给出我的解决方法：&lt;/p&gt;\n&lt;h2 id=\&#34;微信小程序\&#34;&gt;微信小程序：&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;        wx.request({\n          url: &#39;http://172.20.10.2:8080/order/wx/buy&#39;,\n          header: {\n               &#39;content-type&#39;: &#39;application/json&#39;\n            },\n          method: &amp;quot;POST&amp;quot;,\n          data:{\n            buyGoodsDTOS:this.data.orders,\n            user_id:this.data.user_info.user_id\n        },\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;data里面有列表类型的orders，以及一个用户ID，&lt;br&gt;\n我们就这直接这样发起请求，orders和user_id都会被序列化为json&lt;/p&gt;\n&lt;h2 id=\&#34;后台接收\&#34;&gt;后台接收&lt;/h2&gt;\n&lt;p&gt;利用阿里的&lt;strong&gt;fastjson&lt;/strong&gt;，我使用的&lt;strong&gt;SpringBoot&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;pomxml里添加\&#34;&gt;pom.xml里添加：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;        &amp;lt;dependency&amp;gt;\n            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;\n            &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;\n            &amp;lt;version&amp;gt;1.2.46&amp;lt;/version&amp;gt;\n        &amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;controller里面\&#34;&gt;Controller里面：&lt;/h3&gt;\n&lt;p&gt;利用&lt;strong&gt;fastjson&lt;/strong&gt;的&lt;strong&gt;JSONObject&lt;/strong&gt;接收wx序列化后的json数据&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc9d899d22dda~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过JSONObject类的源码，可以发现他实现类Map接口&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;        public class JSONObject extends JSON implements Map&amp;lt;String, Object&amp;gt;,。。。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以知道，它是利用键值对存储微信小程序发送的json数据，存储方式类似于&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/28/16afc685bf16f9d4~tplv-t2oaga2asx-image.image\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n下划线部分为key，名称相同，value就是传过来的数据。&lt;br&gt;\n对于里面jsonData里面orders数据（list）的获取：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;        JSONArray jsonArray = jsonData.getJSONArray(&amp;quot;buyGoodsDTOS&amp;quot;);    //根据key名获取\n        List&amp;lt;BuyGoodsDTO&amp;gt; list = jsonArray.toJavaList(BuyGoodsDTO.class); //将数组对象转化为list，BuyGoodsDTO是与orders里面对象要对应\n        \n        String user_id = jsonData.get(&amp;quot;user_id&amp;quot;).toString();    //获取user_id\n        Integer id = Integer.parseInt(user_id);         //转化类型\n```j\n这样所有的数据都获取到啦～\n\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;dU5Kti6_I&#34;,&#34;abstract&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;最近在学习微信小程序，遇到了一些坑，有些问题我看官网或者其他博客，可能讲的不是那么易懂，所以自己找到解决方法后，写下来供大家参考，如有不对指出，还恳请大家指出～&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;微信小程序：POST 传输 List 数据&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;源码&#34;,&#34;slug&#34;:&#34;yuan-ma&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/&#34;},{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;6j9B3b2nb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/&#34;},{&#34;name&#34;:&#34;微信小程序&#34;,&#34;slug&#34;:&#34;59D97ArOs&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/tag/59D97ArOs/&#34;}],&#34;date&#34;:&#34;2019-03-15 13:09:09&#34;,&#34;dateFormat&#34;:&#34;2019-03-15 01:09:09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://zexho994.github.io/blog.zexho.life/post/dU5Kti6_I/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:176000,&#34;words&#34;:719,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n最近在学习微信小程序，遇到了一些坑，有些问题我看官网或者其他博客，可能讲的不是那么易懂，所以自己找到解决方法后，写下来供大家参考，如有不对指出，还恳请大家指出～\n\n\n比如在实现购物车批量购买的时候，我们需要向后台请求一个list，包含所有...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F\&#34;&gt;微信小程序：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8E%E5%8F%B0%E6%8E%A5%E6%94%B6\&#34;&gt;后台接收&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#pomxml%E9%87%8C%E6%B7%BB%E5%8A%A0\&#34;&gt;pom.xml里添加：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#controller%E9%87%8C%E9%9D%A2\&#34;&gt;Controller里面：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


</html>