<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>利用Cglib和JDK动态代理实现AOP | Zexho&#39; blog</title>
<link rel="shortcut icon" href="https://zexho994.github.io/blog.zexho.life/favicon.ico?v=1647649964163">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zexho994.github.io/blog.zexho.life/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="利用Cglib和JDK动态代理实现AOP | Zexho&#39; blog - Atom Feed" href="https://zexho994.github.io/blog.zexho.life/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="前提：本文假设你已经了解AOP切面编程的基础概念
项目地址：https://github.com/zexho994/IOC-AOP

AOP的逻辑
首先我们定义一个被代理类
@Bean
public class A interface I{..." />
    <meta name="keywords" content="Java,造轮子" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zexho994.github.io/blog.zexho.life">
  <img class="avatar" src="https://zexho994.github.io/blog.zexho.life/images/avatar.png?v=1647649964163" alt="">
  </a>
  <h1 class="site-title">
    Zexho&#39; blog
  </h1>
  <p class="site-description">
    日积跬步，以致千里
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间线
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签集
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/zexho994" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              利用Cglib和JDK动态代理实现AOP
            </h2>
            <div class="post-info">
              <span>
                2021-11-11
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/" class="post-tag">
                  # Java
                </a>
              
                <a href="https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/" class="post-tag">
                  # 造轮子
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>前提：本文假设你已经了解AOP切面编程的基础概念<br>
项目地址：<a href="https://github.com/zexho994/IOC-AOP">https://github.com/zexho994/IOC-AOP</a></p>
<!-- more -->
<h1 id="aop的逻辑">AOP的逻辑</h1>
<p>首先我们定义一个被代理类</p>
<pre><code class="language-java">@Bean
public class A interface I{

    public void print() {
        System.out.println(&quot;aaa&quot;);
    }

}
</code></pre>
<p>定义切点和切面</p>
<pre><code class="language-java">@Bean
@Aspect
public class AdviceSample {

    @Before
    @Pointcut(beanName = &quot;A&quot;)
    public void enhance2Before() {
        System.out.println(&quot;before&quot;);
    }


}
</code></pre>
<p>后续我们使用A的时候，都会先打印切面的内容，也就是：</p>
<pre><code>before
aaa
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83758a4da5594e43aee236ff3ba476df~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>如何将切面的内容添加到代理的方法里面去呢？</p>
<h1 id="切面切入实现">切面切入实现</h1>
<h2 id="jdk动态代理实现">JDK动态代理实现</h2>
<p>提到代理，最先想到的是JDK提供的动态代理类<code>InvocationHandler</code>，下面尝试使用JDK动态代理实现 ，切入的方式假设使用<code>before</code>，而<code>after</code>和<code>around</code>看完就懂如何实现了。</p>
<pre><code class="language-java">public class JDKDynamicProxy implements InvocationHandler {
    
    private Method before = null;
    private Object beforeObj = null;

    
    /**
     * @param proxy  代理的真实对象
     * @param method 要调用的真实对象的方法
     * @param args   方法的参数
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 执行before方法
        if (before != null) {
            before.invoke(beforeObj);
        }

        // 执行本体方法
        Object invoke = method.invoke(target, args);

        return invoke;
    }
    
    /**
     * 获取动态代理对象
     *
     * @param obj 被代理类
     * @return obj的父接口实现子类, 因为返回的是T父接口重写的类
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getDynamicProxyImpl(T obj,Method before, Object beforeObj) {
        assert obj != null;
        this.before = before;
        this.beforeObj = beforeObj;

        // newProxyInstance() 会创建类$A，$A实现了obj的父接口，所有接口方法内容都为 {@link #invoke()} 。
        return (T) newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
    
}
</code></pre>
<p>统一调用<code>getDynamicProxyImpl()</code>来获取新的代理类，参数里面传入before的Method对象，<code>invoke()</code>方法定义了在执行本体方法之前执行<code>before</code>方法，这样新的代理类都会先执行<code>before</code>方法再执行本体方法了。</p>
<p>实现非常简单易懂，那么要实现<code>after</code>方法就是可以传入after的<code>Method</code>对象，然后在<code>invoke()</code>的本体方法之后执行，<code>around</code>的实现不用再增加新的逻辑了，只要同时传入<code>before</code>和<code>after</code>的<code>Method</code>对象，这样新的代理类就会同时执行<code>before()</code>和<code>after()</code>了。</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e5dca4c4a049519f0edaa0986605f5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="cglib实现">Cglib实现</h2>
<p>JDK动态代理可以实现，但是有约束条件就是被代理类必须要有父接口，因为JDK动态实现的原理就是实现接口生成增强的子类。那么如果一个类没有父接口该如何进行切面增强呢？<code>Spring</code>中使用了<code>cglib</code>这个库来实现。</p>
<pre><code class="language-java">public class CglibProxy implements MethodInterceptor {

    public static final Enhancer ENHANCER = new Enhancer();

    private Method before = null;
    private Object beforeObj = null;

    private Method after = null;
    private Object afterObj = null;

    /**
     * @param obj         cglib动态代理生成的实例
     * @param method      被调用的方法的引用
     * @param params      参数列表
     * @param methodProxy 代理类对方法的代理引用
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {
        if (before != null) {
            before.invoke(beforeObj);
        }
        Object result = methodProxy.invokeSuper(obj, params);
        if (after != null) {
            after.invoke(afterObj);
        }
        return result;
    }

    public void setBefore(Method before, Object beforeObj) {
        this.before = before;
        this.beforeObj = beforeObj;
    }

    public void setAfter(Method after, Object afterObj) {
        this.after = after;
        this.afterObj = afterObj;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T getProxy(T target, Method before, Object beforeObj, Method after, Object afterObj) {
        ENHANCER.setSuperclass(target.getClass());
        CglibProxy cglibProxy = new CglibProxy();
        cglibProxy.setBefore(before, beforeObj);
        cglibProxy.setAfter(after, afterObj);

        ENHANCER.setCallback(cglibProxy);
        return (T) ENHANCER.create();
    }

}
</code></pre>
<p>实现的思路和JDK动态代理几乎一致，通过调用<code>getProxy()</code>方法传入<code>before()</code>或<code>after()</code>方法就可以获得代理类了。</p>
<p>为什么cglib的实现不需要接口呢？cglib的实现原理是为被代理类创建一个子类，然后将切面通过ASM提供的字节码技术织入到目标方法中，这样子类的方法就包含了本体和切面的逻辑了。</p>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8116c3d61d4f8d8b72d525d210355d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#aop%E7%9A%84%E9%80%BB%E8%BE%91">AOP的逻辑</a></li>
<li><a href="#%E5%88%87%E9%9D%A2%E5%88%87%E5%85%A5%E5%AE%9E%E7%8E%B0">切面切入实现</a>
<ul>
<li><a href="#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0">JDK动态代理实现</a></li>
<li><a href="#cglib%E5%AE%9E%E7%8E%B0">Cglib实现</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/">
              <h3 class="post-title">
                RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://zexho994.github.io/blog.zexho.life/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
