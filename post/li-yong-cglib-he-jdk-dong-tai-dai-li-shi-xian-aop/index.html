<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>利用Cglib和JDK动态代理实现AOP | Zexho&#39; blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zexho994.github.io/blog.zexho.life/favicon.ico?v=1647602001405">
<link rel="stylesheet" href="https://zexho994.github.io/blog.zexho.life/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="前提：本文假设你已经了解AOP切面编程的基础概念
项目地址：https://github.com/zexho994/IOC-AOP

AOP的逻辑
首先我们定义一个被代理类
@Bean
public class A interface I{..." />
    <meta name="keywords" content="Java,造轮子" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zexho994.github.io/blog.zexho.life">
        <img src="https://zexho994.github.io/blog.zexho.life/images/avatar.png?v=1647602001405" class="site-logo">
        <h1 class="site-title">Zexho&#39; blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      日积跬步，以致千里
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://zexho994.github.io/blog.zexho.life/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">利用Cglib和JDK动态代理实现AOP</h2>
            <div class="post-date">2021-11-11</div>
            
            <div class="post-content" v-pre>
              <p>前提：本文假设你已经了解AOP切面编程的基础概念<br>
项目地址：<a href="https://github.com/zexho994/IOC-AOP">https://github.com/zexho994/IOC-AOP</a></p>
<!-- more -->
<h1 id="aop的逻辑">AOP的逻辑</h1>
<p>首先我们定义一个被代理类</p>
<pre><code class="language-java">@Bean
public class A interface I{

    public void print() {
        System.out.println(&quot;aaa&quot;);
    }

}
</code></pre>
<p>定义切点和切面</p>
<pre><code class="language-java">@Bean
@Aspect
public class AdviceSample {

    @Before
    @Pointcut(beanName = &quot;A&quot;)
    public void enhance2Before() {
        System.out.println(&quot;before&quot;);
    }


}
</code></pre>
<p>后续我们使用A的时候，都会先打印切面的内容，也就是：</p>
<pre><code>before
aaa
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83758a4da5594e43aee236ff3ba476df~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<p>如何将切面的内容添加到代理的方法里面去呢？</p>
<h1 id="切面切入实现">切面切入实现</h1>
<h2 id="jdk动态代理实现">JDK动态代理实现</h2>
<p>提到代理，最先想到的是JDK提供的动态代理类<code>InvocationHandler</code>，下面尝试使用JDK动态代理实现 ，切入的方式假设使用<code>before</code>，而<code>after</code>和<code>around</code>看完就懂如何实现了。</p>
<pre><code class="language-java">public class JDKDynamicProxy implements InvocationHandler {
    
    private Method before = null;
    private Object beforeObj = null;

    
    /**
     * @param proxy  代理的真实对象
     * @param method 要调用的真实对象的方法
     * @param args   方法的参数
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// 执行before方法
        if (before != null) {
            before.invoke(beforeObj);
        }

        // 执行本体方法
        Object invoke = method.invoke(target, args);

        return invoke;
    }
    
    /**
     * 获取动态代理对象
     *
     * @param obj 被代理类
     * @return obj的父接口实现子类, 因为返回的是T父接口重写的类
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T getDynamicProxyImpl(T obj,Method before, Object beforeObj) {
        assert obj != null;
        this.before = before;
        this.beforeObj = beforeObj;

        // newProxyInstance() 会创建类$A，$A实现了obj的父接口，所有接口方法内容都为 {@link #invoke()} 。
        return (T) newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }
    
}
</code></pre>
<p>统一调用<code>getDynamicProxyImpl()</code>来获取新的代理类，参数里面传入before的Method对象，<code>invoke()</code>方法定义了在执行本体方法之前执行<code>before</code>方法，这样新的代理类都会先执行<code>before</code>方法再执行本体方法了。</p>
<p>实现非常简单易懂，那么要实现<code>after</code>方法就是可以传入after的<code>Method</code>对象，然后在<code>invoke()</code>的本体方法之后执行，<code>around</code>的实现不用再增加新的逻辑了，只要同时传入<code>before</code>和<code>after</code>的<code>Method</code>对象，这样新的代理类就会同时执行<code>before()</code>和<code>after()</code>了。</p>
<figure data-type="image" tabindex="2"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e5dca4c4a049519f0edaa0986605f5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>
<h2 id="cglib实现">Cglib实现</h2>
<p>JDK动态代理可以实现，但是有约束条件就是被代理类必须要有父接口，因为JDK动态实现的原理就是实现接口生成增强的子类。那么如果一个类没有父接口该如何进行切面增强呢？<code>Spring</code>中使用了<code>cglib</code>这个库来实现。</p>
<pre><code class="language-java">public class CglibProxy implements MethodInterceptor {

    public static final Enhancer ENHANCER = new Enhancer();

    private Method before = null;
    private Object beforeObj = null;

    private Method after = null;
    private Object afterObj = null;

    /**
     * @param obj         cglib动态代理生成的实例
     * @param method      被调用的方法的引用
     * @param params      参数列表
     * @param methodProxy 代理类对方法的代理引用
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] params, MethodProxy methodProxy) throws Throwable {
        if (before != null) {
            before.invoke(beforeObj);
        }
        Object result = methodProxy.invokeSuper(obj, params);
        if (after != null) {
            after.invoke(afterObj);
        }
        return result;
    }

    public void setBefore(Method before, Object beforeObj) {
        this.before = before;
        this.beforeObj = beforeObj;
    }

    public void setAfter(Method after, Object afterObj) {
        this.after = after;
        this.afterObj = afterObj;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; T getProxy(T target, Method before, Object beforeObj, Method after, Object afterObj) {
        ENHANCER.setSuperclass(target.getClass());
        CglibProxy cglibProxy = new CglibProxy();
        cglibProxy.setBefore(before, beforeObj);
        cglibProxy.setAfter(after, afterObj);

        ENHANCER.setCallback(cglibProxy);
        return (T) ENHANCER.create();
    }

}
</code></pre>
<p>实现的思路和JDK动态代理几乎一致，通过调用<code>getProxy()</code>方法传入<code>before()</code>或<code>after()</code>方法就可以获得代理类了。</p>
<p>为什么cglib的实现不需要接口呢？cglib的实现原理是为被代理类创建一个子类，然后将切面通过ASM提供的字节码技术织入到目标方法中，这样子类的方法就包含了本体和切面的逻辑了。</p>
<figure data-type="image" tabindex="3"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8116c3d61d4f8d8b72d525d210355d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png" loading="lazy"></figure>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/" class="tag">
                    Java
                  </a>
                
                  <a href="https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/" class="tag">
                    造轮子
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zexho994.github.io/blog.zexho.life/post/rocketmq491-yuan-ma-fen-xi-namesrv-fu-wu-zhu-ce-andlu-you-fa-xian/">
                  <h3 class="post-title">
                    RocketMQ4.9.1源码分析-Namesrv服务注册&amp;路由发现
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
