<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>深入解析Java Stream（下）：终结操作 | Zexho&#39; blog</title>
<link rel="shortcut icon" href="https://zexho994.github.io/blog.zexho.life/favicon.ico?v=1647649964163">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zexho994.github.io/blog.zexho.life/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="深入解析Java Stream（下）：终结操作 | Zexho&#39; blog - Atom Feed" href="https://zexho994.github.io/blog.zexho.life/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="几个疑问

终结方法是如何进行操作的？
如何实现由终结操作触发流的运作的？
如何保证一个流一次只能执行一个终结方法？


使用方式
列举四种终结操作，在Stream提供的API中，也是四类：

// 计算流中元素数量，FindOP
long..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zexho994.github.io/blog.zexho.life">
  <img class="avatar" src="https://zexho994.github.io/blog.zexho.life/images/avatar.png?v=1647649964163" alt="">
  </a>
  <h1 class="site-title">
    Zexho&#39; blog
  </h1>
  <p class="site-description">
    日积跬步，以致千里
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          时间线
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签集
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/zexho994" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              深入解析Java Stream（下）：终结操作
            </h2>
            <div class="post-info">
              <span>
                2021-08-06
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h3 id="几个疑问">几个疑问</h3>
<ol>
<li>终结方法是如何进行操作的？</li>
<li>如何实现由终结操作触发流的运作的？</li>
<li>如何保证一个流一次只能执行一个终结方法？</li>
</ol>
<!-- more -->
<h3 id="使用方式">使用方式</h3>
<p>列举四种终结操作，在Stream提供的API中，也是四类：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f302257d5bb44e519c5bb32da6fb5daa~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></figure>
<pre><code class="language-java">// 计算流中元素数量，FindOP
long count = afterLimit.count();

// 遍历所有元素,ForEachOp
afterLimit.forEach(System.out::printl);

// 获取第一个元素,MatchOp
Optional&lt;Integer&gt; any = afterLimit.findFirst();

// 判断是否,ReduceOp
boolean flag = afterLimit.anyMatch(i -&gt; i == 1);
</code></pre>
<h3 id="count">count()</h3>
<p>在<code>ReferencePipeline</code>类中实现</p>
<pre><code class="language-java">@Override
public final long count() {
 	// 调用mapToLong将所有元素变成1，然后计算sum
    return mapToLong(e -&gt; 1L).sum();
}
</code></pre>
<h4 id="maotolong">maoToLong()</h4>
<p>mapToLong()方法，是一个中间操作</p>
<pre><code class="language-java">@Override
    public final LongStream mapToLong(ToLongFunction&lt;? super P_OUT&gt; mapper) {
        Objects.requireNonNull(mapper);
        return new LongPipeline.StatelessOp&lt;P_OUT&gt;(this, StreamShape.REFERENCE,
                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;Long&gt; sink) {
                return new Sink.ChainedReference&lt;P_OUT, Long&gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        //
                        downstream.accept(mapper.applyAsLong(u));
                    }
                };
            }
        };
    }
</code></pre>
<p>ToLongFunction是一个函数式接口类, accept()里的逻辑便是<code>e -&gt; 1L</code>.</p>
<pre><code class="language-java">@FunctionalInterface
public interface ToLongFunction&lt;T&gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    long applyAsLong(T value);
}
</code></pre>
<p>看下Sum()方法,在LongPipeline类中，传入参数是一个Long::sum, sum的作用是相加两个值。</p>
<pre><code class="language-java">@Override
public final long sum() {
    // use better algorithm to compensate for intermediate overflow?
    return reduce(0, Long::sum);
}

//public static long sum(long a, long b) {
//    return a + b;
//}
</code></pre>
<h4 id="reduce">reduce()</h4>
<p>reduce方法,将操作函数op封装成一个Sink，makeLong()的作用就是会生产一个Sink</p>
<pre><code class="language-java">@Override
public final long reduce(long identity, LongBinaryOperator op) {
    return evaluate(ReduceOps.makeLong(identity, op));
}
</code></pre>
<pre><code class="language-java">    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code long} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Long, Long&gt;
    makeLong(long identity, LongBinaryOperator operator) {
        Objects.requireNonNull(operator);
        class ReducingSink
                implements AccumulatingSink&lt;Long, Long, ReducingSink&gt;, Sink.OfLong {
                
            //state是一个用作记录的值
            private long state;

            @Override
            public void begin(long size) {
                state = identity;
            }

			//参数传进来的就是sun(),所以这里的accept()的作用就是对state不断进行累加
            @Override
            public void accept(long t) {
                state = operator.applyAsLong(state, t);
            }

            @Override
            public Long get() {
                return state;
            }

            @Override
            public void combine(ReducingSink other) {
                accept(other.state);
            }
        }
        return new ReduceOp&lt;Long, Long, ReducingSink&gt;(StreamShape.LONG_VALUE) {
            @Override
            public ReducingSink makeSink() {
                return new ReducingSink();
            }
        };
    }
</code></pre>
<h4 id="evaluate">evaluate()</h4>
<p>看回evaluate()方法，这个方法用来执行终结操作的</p>
<pre><code class="language-java">final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp) {
    assert getOutputShape() == terminalOp.inputShape();
    //判断流是否已被使用
    if (linkedOrConsumed)
        throw new IllegalStateException(MSG_STREAM_LINKED);
    //设置使用标记为true
    linkedOrConsumed = true;

    //根据流类型，执行相应的推断操作
    return isParallel()
        ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
        : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}
</code></pre>
<p>关注时序流的推断方法，可以看到这个方法的实现分为四种，对应上面提到的四类类型操作，count属于ReduceOp，进去看下。</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140540bd57794266af310e7c016400f5~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<pre><code class="language-java">
@Override
public &lt;P_IN&gt; R evaluateSequential(PipelineHelper&lt;T&gt; helper,
                                   Spliterator&lt;P_IN&gt; spliterator) {
    //调用wrapAndCopyInto()方法
    return helper.wrapAndCopyInto(makeSink(), spliterator).get();
}
</code></pre>
<h4 id="wrapandcopyinto">wrapAndCopyInto()</h4>
<p>保证所有stage -&gt; sink链表，然后执行copyInto()方法</p>
<pre><code class="language-java">	@Override
    final &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; S wrapAndCopyInto(S sink, Spliterator&lt;P_IN&gt; spliterator) {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        return sink;
    }
</code></pre>
<h4 id="warpsink">warpSink()</h4>
<p>就是在这里，从后向前，包装所有的stage阶段，形成一条sink链表。这样将之前一个个stage的链表结构包装成一个个Sink。</p>
<pre><code class="language-java">	@Override
    @SuppressWarnings(&quot;unchecked&quot;)
    final &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) {
        Objects.requireNonNull(sink);
		
        //从后向前遍历
        for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &gt; 0; p=p.previousStage) {
            //执行每个opWrapSink()方法，这个方法在每个操作类中都进行了重写
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        //返回头sink
        return (Sink&lt;P_IN&gt;) sink;
    }
</code></pre>
<h4 id="copyinto">copyInto()</h4>
<p>这个方法是整个流水线的启动开关，流程如下：</p>
<ol>
<li>调用第一个sink的begin()方法</li>
<li>执行数据源的spliterator.forEachRemaining(wrappendSink)方法遍历调用accept()方法</li>
<li>end() 通知结束</li>
</ol>
<pre><code class="language-java">	@Override
    final &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) {
        Objects.requireNonNull(wrappedSink);

        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            //通知第一个sink，做好准备接受流
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            //执行
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
        }
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }
</code></pre>
<h4 id="foreachremaining">forEachRemaining()</h4>
<p>在各个容器中都有实现forEachRemaining()这个方法，在ArrayList中:</p>
<pre><code class="language-java">public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
    if (action == null)
        throw new NullPointerException();
    int hi = getFence(), i = index;
    if (i &lt; hi) {
        index = i + 1;
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E)list.elementData[i];
        //执行accept()方法
        action.accept(e);
        if (list.modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return true;
    }
    return false;
}
</code></pre>
<h3 id="其他终结操作">其他终结操作</h3>
<h4 id="foreach">forEach()</h4>
<p>在<code>ReferencePipeline</code>类中，实现了forEach()方法，</p>
<pre><code class="language-java">// from ReferencePipeline.class

@Override
public void forEach(Consumer&lt;? super P_OUT&gt; action) {
    // ForEachOps..
    evaluate(ForEachOps.makeRef(action, false));
}
</code></pre>
<p>evaluate后面的逻辑与count后面的一样了，略。</p>
<h4 id="findfirst-anymatch">findFirst() anyMatch()</h4>
<p>findFirst()和anyMatch()的逻辑也不再多说了，一个套路，看下实现</p>
<pre><code class="language-java">@Override
public final Optional&lt;P_OUT&gt; findFirst() {
    return evaluate(FindOps.makeRef(true));
}

@Override
public final boolean anyMatch(Predicate&lt;? super P_OUT&gt; predicate) {
    return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
}
</code></pre>
<h3 id="疑问解答">疑问解答</h3>
<ol>
<li>终结方法是如何进行操作的？
<ul>
<li>终结操作的实现里面都有调用evaluate()方法，这个方法最后会warp所有操作变成一串sink，然后从头开始执行begin(),accept(),end()方法</li>
</ul>
</li>
<li>如何实现由终结操作触发流的运作的？
<ul>
<li>触发的开关是wrapAndCopyInto(),这个方法只有在终结操作中才有被调用。</li>
</ul>
</li>
<li>如何保证一个流一次只能执行一个终结方法？
<ul>
<li>evaluate()方法中执行一次后<code>linkedOrConsumed</code>设为true，后续再出发evaluate()方法就会异常。</li>
</ul>
</li>
</ol>
<p>参考引用：</p>
<ul>
<li><a href="https://colobu.com/2014/11/18/Java-8-Stream/">Java 8 Stream探秘 (colobu.com)</a></li>
<li><a href="">原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)</a></li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%87%A0%E4%B8%AA%E7%96%91%E9%97%AE">几个疑问</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">使用方式</a></li>
<li><a href="#count">count()</a>
<ul>
<li><a href="#maotolong">maoToLong()</a></li>
<li><a href="#reduce">reduce()</a></li>
<li><a href="#evaluate">evaluate()</a></li>
<li><a href="#wrapandcopyinto">wrapAndCopyInto()</a></li>
<li><a href="#warpsink">warpSink()</a></li>
<li><a href="#copyinto">copyInto()</a></li>
<li><a href="#foreachremaining">forEachRemaining()</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C">其他终结操作</a>
<ul>
<li><a href="#foreach">forEach()</a></li>
<li><a href="#findfirst-anymatch">findFirst() anyMatch()</a></li>
</ul>
</li>
<li><a href="#%E7%96%91%E9%97%AE%E8%A7%A3%E7%AD%94">疑问解答</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamzhong-op-cao-zuo-liu/">
              <h3 class="post-title">
                深入解析Java Stream（中）：OP操作流
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://zexho994.github.io/blog.zexho.life/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
