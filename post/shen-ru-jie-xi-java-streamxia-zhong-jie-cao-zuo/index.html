<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>深入解析Java Stream（下）：终结操作 | Zexho&#39; blog</title>
<meta name="description" content="芝兰生于幽谷，不因无人而不芳">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://zexho994.github.io/blog.zexho.life/favicon.ico?v=1657628531424">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://zexho994.github.io/blog.zexho.life/styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://zexho994.github.io/blog.zexho.life">Zexho&#39; blog</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="https://zexho994.github.io/blog.zexho.life" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="https://zexho994.github.io/blog.zexho.life/archives" class="menu">
                时间线
              </a>
            
          </li>
        
          <li>
            
              <a href="https://zexho994.github.io/blog.zexho.life/tags" class="menu">
                标签集
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>深入解析Java Stream（下）：终结操作</h1>
            <p class="article-meta">
              2021-08-06 11:13:20
              
                <a href="https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/" class="badge secondary">
                  源码
                </a>
              
                <a href="https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/" class="badge secondary">
                  Java
                </a>
              
            </p>
            
            <div class="post-content">
              <h3 id="几个疑问">几个疑问</h3>
<ol>
<li>终结方法是如何进行操作的？</li>
<li>如何实现由终结操作触发流的运作的？</li>
<li>如何保证一个流一次只能执行一个终结方法？</li>
</ol>
<!-- more -->
<h3 id="使用方式">使用方式</h3>
<p>列举四种终结操作，在Stream提供的API中，也是四类：</p>
<figure data-type="image" tabindex="1"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f302257d5bb44e519c5bb32da6fb5daa~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy"></figure>
<pre><code class="language-java">// 计算流中元素数量，FindOP
long count = afterLimit.count();

// 遍历所有元素,ForEachOp
afterLimit.forEach(System.out::printl);

// 获取第一个元素,MatchOp
Optional&lt;Integer&gt; any = afterLimit.findFirst();

// 判断是否,ReduceOp
boolean flag = afterLimit.anyMatch(i -&gt; i == 1);
</code></pre>
<h3 id="count">count()</h3>
<p>在<code>ReferencePipeline</code>类中实现</p>
<pre><code class="language-java">@Override
public final long count() {
 	// 调用mapToLong将所有元素变成1，然后计算sum
    return mapToLong(e -&gt; 1L).sum();
}
</code></pre>
<h4 id="maotolong">maoToLong()</h4>
<p>mapToLong()方法，是一个中间操作</p>
<pre><code class="language-java">@Override
    public final LongStream mapToLong(ToLongFunction&lt;? super P_OUT&gt; mapper) {
        Objects.requireNonNull(mapper);
        return new LongPipeline.StatelessOp&lt;P_OUT&gt;(this, StreamShape.REFERENCE,
                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;Long&gt; sink) {
                return new Sink.ChainedReference&lt;P_OUT, Long&gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        //
                        downstream.accept(mapper.applyAsLong(u));
                    }
                };
            }
        };
    }
</code></pre>
<p>ToLongFunction是一个函数式接口类, accept()里的逻辑便是<code>e -&gt; 1L</code>.</p>
<pre><code class="language-java">@FunctionalInterface
public interface ToLongFunction&lt;T&gt; {

    /**
     * Applies this function to the given argument.
     *
     * @param value the function argument
     * @return the function result
     */
    long applyAsLong(T value);
}
</code></pre>
<p>看下Sum()方法,在LongPipeline类中，传入参数是一个Long::sum, sum的作用是相加两个值。</p>
<pre><code class="language-java">@Override
public final long sum() {
    // use better algorithm to compensate for intermediate overflow?
    return reduce(0, Long::sum);
}

//public static long sum(long a, long b) {
//    return a + b;
//}
</code></pre>
<h4 id="reduce">reduce()</h4>
<p>reduce方法,将操作函数op封装成一个Sink，makeLong()的作用就是会生产一个Sink</p>
<pre><code class="language-java">@Override
public final long reduce(long identity, LongBinaryOperator op) {
    return evaluate(ReduceOps.makeLong(identity, op));
}
</code></pre>
<pre><code class="language-java">    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code long} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Long, Long&gt;
    makeLong(long identity, LongBinaryOperator operator) {
        Objects.requireNonNull(operator);
        class ReducingSink
                implements AccumulatingSink&lt;Long, Long, ReducingSink&gt;, Sink.OfLong {
                
            //state是一个用作记录的值
            private long state;

            @Override
            public void begin(long size) {
                state = identity;
            }

			//参数传进来的就是sun(),所以这里的accept()的作用就是对state不断进行累加
            @Override
            public void accept(long t) {
                state = operator.applyAsLong(state, t);
            }

            @Override
            public Long get() {
                return state;
            }

            @Override
            public void combine(ReducingSink other) {
                accept(other.state);
            }
        }
        return new ReduceOp&lt;Long, Long, ReducingSink&gt;(StreamShape.LONG_VALUE) {
            @Override
            public ReducingSink makeSink() {
                return new ReducingSink();
            }
        };
    }
</code></pre>
<h4 id="evaluate">evaluate()</h4>
<p>看回evaluate()方法，这个方法用来执行终结操作的</p>
<pre><code class="language-java">final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp) {
    assert getOutputShape() == terminalOp.inputShape();
    //判断流是否已被使用
    if (linkedOrConsumed)
        throw new IllegalStateException(MSG_STREAM_LINKED);
    //设置使用标记为true
    linkedOrConsumed = true;

    //根据流类型，执行相应的推断操作
    return isParallel()
        ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
        : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
}
</code></pre>
<p>关注时序流的推断方法，可以看到这个方法的实现分为四种，对应上面提到的四类类型操作，count属于ReduceOp，进去看下。</p>
<figure data-type="image" tabindex="2"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140540bd57794266af310e7c016400f5~tplv-k3u1fbpfcp-zoom-1.image" alt="" loading="lazy"></figure>
<pre><code class="language-java">
@Override
public &lt;P_IN&gt; R evaluateSequential(PipelineHelper&lt;T&gt; helper,
                                   Spliterator&lt;P_IN&gt; spliterator) {
    //调用wrapAndCopyInto()方法
    return helper.wrapAndCopyInto(makeSink(), spliterator).get();
}
</code></pre>
<h4 id="wrapandcopyinto">wrapAndCopyInto()</h4>
<p>保证所有stage -&gt; sink链表，然后执行copyInto()方法</p>
<pre><code class="language-java">	@Override
    final &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; S wrapAndCopyInto(S sink, Spliterator&lt;P_IN&gt; spliterator) {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        return sink;
    }
</code></pre>
<h4 id="warpsink">warpSink()</h4>
<p>就是在这里，从后向前，包装所有的stage阶段，形成一条sink链表。这样将之前一个个stage的链表结构包装成一个个Sink。</p>
<pre><code class="language-java">	@Override
    @SuppressWarnings(&quot;unchecked&quot;)
    final &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) {
        Objects.requireNonNull(sink);
		
        //从后向前遍历
        for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &gt; 0; p=p.previousStage) {
            //执行每个opWrapSink()方法，这个方法在每个操作类中都进行了重写
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        //返回头sink
        return (Sink&lt;P_IN&gt;) sink;
    }
</code></pre>
<h4 id="copyinto">copyInto()</h4>
<p>这个方法是整个流水线的启动开关，流程如下：</p>
<ol>
<li>调用第一个sink的begin()方法</li>
<li>执行数据源的spliterator.forEachRemaining(wrappendSink)方法遍历调用accept()方法</li>
<li>end() 通知结束</li>
</ol>
<pre><code class="language-java">	@Override
    final &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) {
        Objects.requireNonNull(wrappedSink);

        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            //通知第一个sink，做好准备接受流
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            //执行
            spliterator.forEachRemaining(wrappedSink);
            wrappedSink.end();
        }
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }
</code></pre>
<h4 id="foreachremaining">forEachRemaining()</h4>
<p>在各个容器中都有实现forEachRemaining()这个方法，在ArrayList中:</p>
<pre><code class="language-java">public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
    if (action == null)
        throw new NullPointerException();
    int hi = getFence(), i = index;
    if (i &lt; hi) {
        index = i + 1;
        @SuppressWarnings(&quot;unchecked&quot;) E e = (E)list.elementData[i];
        //执行accept()方法
        action.accept(e);
        if (list.modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return true;
    }
    return false;
}
</code></pre>
<h3 id="其他终结操作">其他终结操作</h3>
<h4 id="foreach">forEach()</h4>
<p>在<code>ReferencePipeline</code>类中，实现了forEach()方法，</p>
<pre><code class="language-java">// from ReferencePipeline.class

@Override
public void forEach(Consumer&lt;? super P_OUT&gt; action) {
    // ForEachOps..
    evaluate(ForEachOps.makeRef(action, false));
}
</code></pre>
<p>evaluate后面的逻辑与count后面的一样了，略。</p>
<h4 id="findfirst-anymatch">findFirst() anyMatch()</h4>
<p>findFirst()和anyMatch()的逻辑也不再多说了，一个套路，看下实现</p>
<pre><code class="language-java">@Override
public final Optional&lt;P_OUT&gt; findFirst() {
    return evaluate(FindOps.makeRef(true));
}

@Override
public final boolean anyMatch(Predicate&lt;? super P_OUT&gt; predicate) {
    return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
}
</code></pre>
<h3 id="疑问解答">疑问解答</h3>
<ol>
<li>终结方法是如何进行操作的？
<ul>
<li>终结操作的实现里面都有调用evaluate()方法，这个方法最后会warp所有操作变成一串sink，然后从头开始执行begin(),accept(),end()方法</li>
</ul>
</li>
<li>如何实现由终结操作触发流的运作的？
<ul>
<li>触发的开关是wrapAndCopyInto(),这个方法只有在终结操作中才有被调用。</li>
</ul>
</li>
<li>如何保证一个流一次只能执行一个终结方法？
<ul>
<li>evaluate()方法中执行一次后<code>linkedOrConsumed</code>设为true，后续再出发evaluate()方法就会异常。</li>
</ul>
</li>
</ol>
<p>参考引用：</p>
<ul>
<li><a href="https://colobu.com/2014/11/18/Java-8-Stream/">Java 8 Stream探秘 (colobu.com)</a></li>
<li><a href="">原来你是这样的 Stream：浅析 Java Stream 实现原理 (https_toutiao.io)</a></li>
</ul>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-jie-xi-java-streamzhong-op-cao-zuo-liu/">
                <h3 class="post-title">
                  深入解析Java Stream（中）：OP操作流
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://zexho994.github.io/blog.zexho.life/images/avatar.png?v=1657628531424" class="no-responsive avatar">
    <div class="text-muted">芝兰生于幽谷，不因无人而不芳</div>
    <div class="social-container">
      
        
          <a href="https://github.com/zexho994" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/mit6830-shu-ju-ku-shi-xian-lab1-ji-lu/">MIT6.830 数据库实现：lab1 记录</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/shen-ru-qian-chu-raft-xie-yi/">深入浅出 Raft 协议</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/mit6824-lab2-raft2c-chi-jiu-hua-shi-xian-yao-dian-and-cai-keng-ji-lu/">[MIT6.824 lab2] Raft2C-持久化 实现要点 &amp; 踩坑记录</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/mit6824-lab2-raft2b-ri-zhi-tong-bu-shi-xian-yao-dian-and-cai-keng-ji-lu/">[MIT6.824 lab2] Raft2B-日志同步 实现要点 &amp; 踩坑记录</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/mit6824-lab2-raft-leader-election-dai-ma-shi-xian-and-cai-keng-ji-lu/">[MIT6.824 lab2] Raft-Leader election 代码实现 &amp; 踩坑记录</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/mit-6824-lab1-mapreduce-she-ji/">Mit 6.824 lab1 MapReduce 设计</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/ji-ge-you-qu-de-gai-lu-wen-ti/">几个有趣的概率问题</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/tong-su-li-jie-basic-pasox/">通俗理解 Basic Paxos</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/wo-li-jie-de-cap/">我理解的CAP</a>
            </li>
          
        
          
            <li>
              <a href="https://zexho994.github.io/blog.zexho.life/post/kuai-su-kan-qing-lambda-de-ben-zhi/">快速看清lambda的本质</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/fen-bu-shi/" class="badge warning">
          分布式
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/Yh19JUBym/" class="badge success">
          知识分享
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/KrLfgh9WlS/" class="badge secondary">
          造轮子
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/xue-xi-gui-na/" class="badge secondary">
          学习归纳
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/6j9B3b2nb/" class="badge secondary">
          Java
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/_Ywd8fi71/" class="badge ">
          RocketMQ
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/yuan-ma/" class="badge warning">
          源码
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/jjLsZt3QW/" class="badge warning">
          JVM
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/P-ZT7Pj1-8/" class="badge secondary">
          Spring
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/docker/" class="badge ">
          docker
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/tu-shu-ju-ku/" class="badge secondary">
          图数据库
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/THZXOECNJ/" class="badge ">
          Git
        </a>
      
        <a href="https://zexho994.github.io/blog.zexho.life/tag/59D97ArOs/" class="badge secondary">
          微信小程序
        </a>
      
    </div>
  </div>
  <div class="paper">
    Life & Coding | <a class="rss" href="https://zexho994.github.io/blog.zexho.life/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
